//This file is automatically generated. DO NOT EDIT!
package com.robotraconteur.testing.TestService3;
import java.util.*;
import com.robotraconteur.*;
public class com__robotraconteur__testing__TestService3Factory extends ServiceFactory
{
    public String defString()
{
    String out="service com.robotraconteur.testing.TestService3\n\nstdver 0.9.2\n#option version 0.9.0\n\nimport com.robotraconteur.testing.TestService1\nusing  com.robotraconteur.testing.TestService1.testroot\nusing  com.robotraconteur.testing.TestService1.teststruct1\nusing  com.robotraconteur.testing.TestService1.teststruct2\nusing  com.robotraconteur.testing.TestService1.testexception1\nusing  com.robotraconteur.testing.TestService1.sub2\nusing  com.robotraconteur.testing.TestService1.sub3\n\nenum testenum1\nvalue1 = 0,	value2,	value3,	anothervalue = -1,\nanothervalue2 = -2,\nanothervalue3 = -3,\nhexval1 = 0x10,\nhexval2,\nneghexval1 = -0x7ffffffb,\nneghexval2,\nmore_values\nend\n\nconstant string strconst \"This is a\\n \\\"string constant\\\" \\\\\\/\\b\\f \\r\\u00FF tabme\\ttabme\\n smile! \\ud83d\\udE01\"\nconstant int32 int32const 3856384\nconstant int32[] int32const_array {182476, 56483, -2947}\nconstant int32 int32hexconst 0x082bc7\nconstant int32 int32hexconst2 -0x7264c17\nconstant int32[] int32hexconst_array { 0x8274ec, -0x0001, +0xABCDEF, 0xabcdef, 0x012345, 0x6789 }\nconstant double[] doubleconst_array {1.5847, 3.14, -548e3, 3452.67e2, 485e-21}\nconstant struct structconst {field1: strconst, field2: int32const_array}\nconstant struct structconst2 {field3: structconst, field4: int32const}\n\nexception test_exception4\n\nnamedarray vector3\nfield double x\nfield double y\nfield double z\nend\n\nnamedarray quaternion\nfield double q0\nfield double q1\nfield double q2\nfield double q3\nend\n\nnamedarray transform\nfield quaternion rotation\nfield vector3 translation\nend\n\nnamedarray pixel\nfield uint8 r\nfield uint8 b\nfield uint8 g\nend\n\nnamedarray pixel2\nfield uint8 c\nfield pixel d\nfield pixel e\nfield pixel[7] f\nfield pixel g\nend\n\npod testpod1\nfield double d1\nfield double[6] d2\nfield double[6-] d3\nfield double[3,3] d4\nfield testpod2 s1\nfield testpod2[8] s2\nfield testpod2[9-] s3\nfield testpod2[2,4] s4\nfield transform t1\nfield transform[4] t2\nfield transform[15-] t3\nfield transform[2,4] t4\nend\n\npod testpod2\nfield int8 i1\nfield int8[15] i2\nfield int8[17-] i3\nend\n\nstruct teststruct3\nfield testpod1 s1\nfield testpod1[] s2\nfield testpod1[11] s3\nfield testpod1[16-] s4\nfield testpod1[3,3] s5\nfield testpod1[*] s6\nfield testpod1{list} s7\nfield testpod1[]{list} s8\nfield testpod1[*]{list} s9\nfield varvalue s10\nfield varvalue s11\nfield varvalue s12\nfield varvalue s13\nfield varvalue s14\nfield varvalue s15\nfield transform t1\nfield transform[4] t2\nfield transform[2,4] t3\nfield varvalue t4\nfield varvalue t5\nfield transform{list} t6\nfield transform[4]{list} t7\nfield transform[2,4]{list} t8\nfield varvalue t9\nfield varvalue t10\nfield varvalue t11\n\nend\n\nobject testroot3\n\nconstant string unknown_modifier_hello \"hello world!\"\n\nproperty int32 readme [readonly]\nproperty int32 writeme [writeonly]\n\npipe int32 unreliable1 [unreliable,readonly]\n\nwire int32 peekwire [readonly]\nwire int32 \\\npokewire [writeonly]\nproperty int32 unknown_modifier [unknown, unknown_3(23, 45.8e-5, unknown_modifier_hello)]\n\nmemory double[] readmem [readonly]\n\nobjref obj4 o4\n\nproperty testenum1 testenum1_prop\n\nproperty testpod1 testpod1_prop\nfunction void testpod1_func1(testpod1 s)\nfunction testpod1 testpod1_func2()\n\nproperty teststruct3 teststruct3_prop\n\nmemory testpod2[] pod_m1\nmemory testpod2[*] pod_m2\n\nfunction double{generator} gen_func1()\nfunction uint8[]{generator} gen_func2(string name)\nfunction void gen_func3(string name, uint8[]{generator} in)\nfunction uint8[]{generator} gen_func4(uint8[]{generator} in)\nfunction teststruct2{generator} gen_func5(teststruct2{generator} in)\n\n#extra tests for fixed length arrays\nproperty double[6]{list} d1\nproperty double[6-]{list} d2\nproperty double[6]{int32} d3\nproperty double[6-]{int32} d4\nproperty double[3,3]{list} d5\nproperty double[3,3]{int32} d6\n\n#Test pipe and wire verification\npipe int32[3] p1\npipe int32[3-] p2\npipe int32[2,2] p3\nwire int32[6] w1\nwire int32[6-] w2\nwire int32[3,2] w3\n\n#namedarray test\nproperty vector3 testnamedarray1\nproperty transform testnamedarray2\nproperty transform[10-] testnamedarray3\nproperty transform[*] testnamedarray4\nproperty transform[3,2] testnamedarray5\n\nmemory transform[] namedarray_m1\nmemory transform[*] namedarray_m2\n\n#new primitive types test\nproperty cdouble c1\nproperty cdouble[] c2\nproperty cdouble[*] c3\nproperty cdouble{list} c4\nproperty cdouble[]{list} c5\nproperty cdouble[*]{list} c6\nproperty csingle c7\nproperty csingle[] c8\nproperty csingle[*] c9\nproperty csingle{list} c10\nproperty csingle[]{list} c11\nproperty csingle[*]{list} c12\n\nproperty bool b1\nproperty bool[] b2\nproperty bool[*] b3\nproperty bool{list} b4\nproperty bool[]{list} b5\nproperty bool[*]{list} b6\n\nmemory cdouble[] c_m1\nmemory cdouble[*] c_m2\nmemory cdouble[] c_m3\nmemory cdouble[*] c_m4\nmemory bool[] c_m5\nmemory bool[*] c_m6\n\nobjref obj5 nolock_test\n\nfunction void test_exception_params1()\nfunction void test_exception_params2()\n\nfunction testenum1{generator} enum_generator1()\nfunction testenum1{generator} enum_generator2(int32 a, int32 b, testenum1{generator} enum_gen)\n\nend\n\nobject obj1\nproperty double[] d1\nend\n\nobject obj2\nimplements obj1\nproperty double[] d1\nend\n\nobject obj3\nimplements obj1\nimplements obj2\nproperty double[] d1\nend\n\nobject obj4\nimplements sub2\nproperty string s_ind\nproperty int32 i_ind\n\nproperty string data\nobjref sub3{string} o3_1\nend\n\nobject obj5\n\nproperty double p1\nproperty double p2 [nolock]\nproperty double p3 [nolockread]\n\nfunction int32 f1()\nfunction int32 f2() [nolock]\n\npipe int32 q1 [readonly]\npipe int32 q2 [readonly,nolock]\n\nwire int32 w1 [readonly]\nwire int32 w2 [readonly,nolock]\n\nmemory int32[] m1\nmemory int32[] m2 [nolock]\nmemory int32[] m3 [nolockread]\n\nend\n\n\n";
    return out;    }
    public String getServiceName() {return "com.robotraconteur.testing.TestService3";}
    public teststruct3_stub teststruct3_stubentry;
    public testpod1_stub testpod1_stubentry;
    public testpod2_stub testpod2_stubentry;
    public vector3_stub vector3_stubentry;
    public quaternion_stub quaternion_stubentry;
    public transform_stub transform_stubentry;
    public pixel_stub pixel_stubentry;
    public pixel2_stub pixel2_stubentry;
    public com__robotraconteur__testing__TestService3Factory()
{
    teststruct3_stubentry=new teststruct3_stub(this);
    testpod1_stubentry=new testpod1_stub(this);
    testpod2_stubentry=new testpod2_stub(this);
    vector3_stubentry=new vector3_stub();
    quaternion_stubentry=new quaternion_stub();
    transform_stubentry=new transform_stub();
    pixel_stubentry=new pixel_stub();
    pixel2_stubentry=new pixel2_stub();
    }
    public IStructureStub findStructureStub(String objecttype)
    {
    if (objecttype.equals("teststruct3"))    return teststruct3_stubentry;
    throw new DataTypeException("Cannot find appropriate structure stub");
    }
    public IPodStub findPodStub(String objecttype)
    {
    if (objecttype.equals("testpod1"))    return testpod1_stubentry;
    if (objecttype.equals("testpod2"))    return testpod2_stubentry;
    throw new DataTypeException("Cannot find appropriate structure stub");
    }
    public INamedArrayStub findNamedArrayStub(String objecttype)
    {
    if (objecttype.equals("vector3"))    return vector3_stubentry;
    if (objecttype.equals("quaternion"))    return quaternion_stubentry;
    if (objecttype.equals("transform"))    return transform_stubentry;
    if (objecttype.equals("pixel"))    return pixel_stubentry;
    if (objecttype.equals("pixel2"))    return pixel2_stubentry;
    throw new DataTypeException("Cannot find appropriate structure stub");
    }
    public ServiceStub createStub(WrappedServiceStub innerstub) {
    String objecttype=innerstub.getRR_objecttype().getServiceDefinition().getName() + "." + innerstub.getRR_objecttype().getName();
    if (RobotRaconteurNode.splitQualifiedName(objecttype)[0].equals( "com.robotraconteur.testing.TestService3")) {
    String objshort=removePath(objecttype);
    if(objshort.equals( "testroot3"))
    return new testroot3_stub(innerstub);
    if(objshort.equals( "obj1"))
    return new obj1_stub(innerstub);
    if(objshort.equals( "obj2"))
    return new obj2_stub(innerstub);
    if(objshort.equals( "obj3"))
    return new obj3_stub(innerstub);
    if(objshort.equals( "obj4"))
    return new obj4_stub(innerstub);
    if(objshort.equals( "obj5"))
    return new obj5_stub(innerstub);
    } else {
    String ext_service_type=(RobotRaconteurNode.splitQualifiedName(objecttype)[0]);
    return RobotRaconteurNode.s().getServiceType(ext_service_type).createStub(innerstub);
    }
    throw new ServiceException("Could not create stub");
    }
    public ServiceSkel createSkel(Object obj) {
    String objtype=ServiceSkelUtil.findParentInterface(obj.getClass()).getName().toString();
    if ((RobotRaconteurNode.splitQualifiedName(objtype.toString())[0]).equals( "com.robotraconteur.testing.TestService3")) {
    String sobjtype=removePath(objtype);
    if(sobjtype.equals( "testroot3"))
    return new testroot3_skel((testroot3)obj);
    if(sobjtype.equals( "obj1"))
    return new obj1_skel((obj1)obj);
    if(sobjtype.equals( "obj2"))
    return new obj2_skel((obj2)obj);
    if(sobjtype.equals( "obj3"))
    return new obj3_skel((obj3)obj);
    if(sobjtype.equals( "obj4"))
    return new obj4_skel((obj4)obj);
    if(sobjtype.equals( "obj5"))
    return new obj5_skel((obj5)obj);
    } else {
    String ext_service_type=(RobotRaconteurNode.splitQualifiedName(objtype.toString())[0]);
    return RobotRaconteurNode.s().getServiceType(ext_service_type).createSkel(obj);
    }
    throw new ServiceException("Could not create skel");
    }
    public RobotRaconteurException downCastException(RobotRaconteurException rr_exp){
    if (rr_exp==null) return rr_exp;
    String rr_type=rr_exp.error;
    if (!rr_type.contains(".")) return rr_exp;
    String[] rr_stype = RobotRaconteurNode.splitQualifiedName(rr_type);
    if (!rr_stype[0].equals("com.robotraconteur.testing.TestService3")) return RobotRaconteurNode.s().downCastException(rr_exp);
    if (rr_stype[1].equals("test_exception4")) return new test_exception4(rr_exp.getMessage(),rr_exp.errorSubName,rr_exp.errorParam);
    return rr_exp;
    }
}
