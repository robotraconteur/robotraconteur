//This file is automatically generated. DO NOT EDIT!

#ifndef ROBOTRACONTEUR_USE_STDAFX
#include "com__robotraconteur__testing__TestService2_stubskel.h"
#include <boost/algorithm/string.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/assign/list_of.hpp>
#else
#include "stdafx.h"
#endif
// NOLINTBEGIN
namespace com
{
namespace robotraconteur
{
namespace testing
{
namespace TestService2
{
std::string com__robotraconteur__testing__TestService2Factory::GetServiceName()
{
return "com.robotraconteur.testing.TestService2";
}
std::string com__robotraconteur__testing__TestService2Factory::DefString()
{
std::string out(
"service com.robotraconteur.testing.TestService2\n"
"\n"
"option version 0.8\n"
"\n"
"exception testexception3\n"
"\n"
"struct ostruct2\n"
"	field double[] a1\n"
"end struct\n"
"\n"
"\n"
"object baseobj\n"
"	property double d1\n"
"	property double[] d2\n"
"\n"
"	function double func3(double d1, double d2)\n"
"\n"
"	event ev1()\n"
"\n"
"	objref subobj o5\n"
"\n"
"	pipe double[] p1\n"
"\n"
"	callback void cb2(double d1, double d2)\n"
"\n"
"	wire double[] w1\n"
"\n"
"	memory double[] m1\n"
"\n"
"\n"
"end object\n"
"\n"
"object subobj\n"
"\n"
"	function double add_val(double v)\n"
"\n"
"end object\n"
"\n"
);
return out;
}
RR_SHARED_PTR<RobotRaconteur::StructureStub> com__robotraconteur__testing__TestService2Factory::FindStructureStub(boost::string_ref s)
{
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(s);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (objecttype=="ostruct2") return RobotRaconteur::rr_cast<RobotRaconteur::StructureStub>(RR_MAKE_SHARED<ostruct2_stub>(GetNode()));
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> com__robotraconteur__testing__TestService2Factory::PackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure>& structin)
{
std::string type=structin->RRType();boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->PackStructure(structin);
RR_SHARED_PTR<RobotRaconteur::StructureStub> stub=FindStructureStub(type);
return stub->PackStructure(structin);
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRValue> com__robotraconteur__testing__TestService2Factory::UnpackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& mstructin)
{
RobotRaconteur::MessageStringPtr type=mstructin->GetTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type.str());
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->UnpackStructure(mstructin);
RR_SHARED_PTR<RobotRaconteur::StructureStub> stub=FindStructureStub(type.str());
return stub->UnpackStructure(mstructin);
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> com__robotraconteur__testing__TestService2Factory::PackPodArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseArray>& structin)
{
boost::string_ref type=structin->RRElementTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->PackPodArray(structin);
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseArray> com__robotraconteur__testing__TestService2Factory::UnpackPodArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& mstructin)
{
RobotRaconteur::MessageStringPtr type=mstructin->GetTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type.str());
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->UnpackPodArray(mstructin);
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> com__robotraconteur__testing__TestService2Factory::PackPodMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseMultiDimArray>& structin)
{
boost::string_ref type=structin->RRElementTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->PackPodMultiDimArray(structin);
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseMultiDimArray> com__robotraconteur__testing__TestService2Factory::UnpackPodMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& mstructin)
{
RobotRaconteur::MessageStringPtr type=mstructin->GetTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type.str());
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->UnpackPodMultiDimArray(mstructin);
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> com__robotraconteur__testing__TestService2Factory::PackNamedArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseArray>& structin)
{
boost::string_ref type=structin->RRElementTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->PackNamedArray(structin);
throw RobotRaconteur::ServiceException("Invalid namedarray type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseArray> com__robotraconteur__testing__TestService2Factory::UnpackNamedArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& mstructin)
{
RobotRaconteur::MessageStringPtr type=mstructin->GetTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type.str());
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->UnpackNamedArray(mstructin);
throw RobotRaconteur::ServiceException("Invalid namedarray type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> com__robotraconteur__testing__TestService2Factory::PackNamedMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseMultiDimArray>& structin)
{
boost::string_ref type=structin->RRElementTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->PackNamedMultiDimArray(structin);
throw RobotRaconteur::ServiceException("Invalid namedarray type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseMultiDimArray> com__robotraconteur__testing__TestService2Factory::UnpackNamedMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& mstructin)
{
RobotRaconteur::MessageStringPtr type=mstructin->GetTypeString();
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type.str());
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->UnpackNamedMultiDimArray(mstructin);
throw RobotRaconteur::ServiceException("Invalid namedarray type.");
}
RR_SHARED_PTR<RobotRaconteur::ServiceStub> com__robotraconteur__testing__TestService2Factory::CreateStub(boost::string_ref type, boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::ClientContext>& context)
{
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->GetServiceType(servicetype)->CreateStub(type,path,context);
if (objecttype=="baseobj") { RR_SHARED_PTR<baseobj_stub> o=(RR_MAKE_SHARED<baseobj_stub>(path,context)); o->RRInitStub(); return o; }
if (objecttype=="subobj") { RR_SHARED_PTR<subobj_stub> o=(RR_MAKE_SHARED<subobj_stub>(path,context)); o->RRInitStub(); return o; }
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_SHARED_PTR<RobotRaconteur::ServiceSkel> com__robotraconteur__testing__TestService2Factory::CreateSkel(boost::string_ref type, const boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::RRObject>& obj, const RR_SHARED_PTR<RobotRaconteur::ServerContext>& context)
{
boost::tuple<boost::string_ref,boost::string_ref> res=RobotRaconteur::SplitQualifiedName(type);
boost::string_ref servicetype=res.get<0>();
boost::string_ref objecttype=res.get<1>();
if (servicetype != "com.robotraconteur.testing.TestService2") return GetNode()->GetServiceType(servicetype)->CreateSkel(type,path,obj,context);
if (objecttype=="baseobj") {RR_SHARED_PTR<baseobj_skel> o=RR_MAKE_SHARED<baseobj_skel>(); o->Init(path,obj,context); return o; }
if (objecttype=="subobj") {RR_SHARED_PTR<subobj_skel> o=RR_MAKE_SHARED<subobj_skel>(); o->Init(path,obj,context); return o; }
throw RobotRaconteur::ServiceException("Invalid structure skel type.");
return RR_SHARED_PTR<RobotRaconteur::ServiceSkel>();
}
void com__robotraconteur__testing__TestService2Factory::DownCastAndThrowException(RobotRaconteur::RobotRaconteurException& rr_exp)
{
std::string rr_type=rr_exp.Error;
if (rr_type.find('.')==std::string::npos)
{
	return;
}
boost::tuple<boost::string_ref,boost::string_ref> rr_res=RobotRaconteur::SplitQualifiedName(rr_type);
if (rr_res.get<0>() != "com.robotraconteur.testing.TestService2") GetNode()->DownCastAndThrowException(rr_exp);
if (rr_res.get<1>()=="testexception3") throw testexception3(rr_exp.Message,rr_exp.ErrorSubName,rr_exp.ErrorParam);
return;
}
RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> com__robotraconteur__testing__TestService2Factory::DownCastException(const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& rr_exp){
if (!rr_exp) return rr_exp;
std::string rr_type=rr_exp->Error;
if (rr_type.find('.')==std::string::npos)
{
	return rr_exp;
}
boost::tuple<boost::string_ref,boost::string_ref> rr_res=RobotRaconteur::SplitQualifiedName(rr_type);
if (rr_res.get<0>() != "com.robotraconteur.testing.TestService2") return GetNode()->DownCastException(rr_exp);
if (rr_res.get<1>()=="testexception3") return RR_MAKE_SHARED<testexception3>(rr_exp->Message,rr_exp->ErrorSubName,rr_exp->ErrorParam);
return rr_exp;
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> ostruct2_stub::PackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::RRValue>& s)
{
RR_INTRUSIVE_PTR<ostruct2 > s2=RobotRaconteur::rr_cast<ostruct2 >(s);
std::vector<RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> > vret;
vret.reserve(1);
vret.push_back(RobotRaconteur::MessageElement_PackArrayElement<double >("a1",s2->a1));
return RobotRaconteur::CreateMessageElementNestedElementList(RobotRaconteur::DataTypes_structure_t,"com.robotraconteur.testing.TestService2.ostruct2",RR_MOVE(vret));
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure> ostruct2_stub::UnpackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& m)
{
std::vector<RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> >& i = m->Elements;
RR_INTRUSIVE_PTR<ostruct2 > ret(new ostruct2());
ret->a1=RobotRaconteur::MessageElement_UnpackArray<double >(RobotRaconteur::MessageElement::FindElement(i,"a1"));
return ret;
}

baseobj_stub::baseobj_stub(boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::ClientContext>& c) : RobotRaconteur::ServiceStub(path,c){ }
void baseobj_stub::RRInitStub()
{
rrvar_p1=RR_MAKE_SHARED<RobotRaconteur::PipeClient<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >("p1",shared_from_this(), false,RobotRaconteur::MemberDefinition_Direction_both) ;
rrvar_cb2=RR_MAKE_SHARED<RobotRaconteur::CallbackClient<boost::function<void(double, double) > > >("cb2") ;
rrvar_w1=RR_MAKE_SHARED<RobotRaconteur::WireClient<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >("w1",shared_from_this(),RobotRaconteur::MemberDefinition_Direction_both);
rrvar_m1=RR_MAKE_SHARED<RobotRaconteur::ArrayMemoryClient<double > >("m1",shared_from_this(),RobotRaconteur::MemberDefinition_Direction_both);
}

double baseobj_stub::get_d1()
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertyGetReq,"d1");
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=ProcessRequest(m);
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=mr->FindElement("value");
return RobotRaconteur::MessageElement_UnpackScalar<double >(me);
}
void baseobj_stub::set_d1(double value)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertySetReq,"d1");
req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("value",value));
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=ProcessRequest(req);
}

RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > baseobj_stub::get_d2()
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertyGetReq,"d2");
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=ProcessRequest(m);
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=mr->FindElement("value");
return RobotRaconteur::MessageElement_UnpackArray<double >(me);
}
void baseobj_stub::set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertySetReq,"d2");
req->AddElement(RobotRaconteur::MessageElement_PackArrayElement<double >("value",value));
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=ProcessRequest(req);
}

double baseobj_stub::func3(double d1, double d2)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"func3");
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("d1",d1));
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("d2",d2));
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_ret=ProcessRequest(rr_req);
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> rr_me=rr_ret->FindElement("return");
return RobotRaconteur::MessageElement_UnpackScalar<double >(rr_me);
}

boost::signals2::signal<void ()>& baseobj_stub::get_ev1()
{
return rrvar_ev1;
}

RR_SHARED_PTR<subobj > baseobj_stub::get_o5()
{
return RobotRaconteur::rr_cast<subobj >(FindObjRefTyped("o5","com.robotraconteur.testing.TestService2.subobj"));
}

RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > baseobj_stub::get_p1()
{
RR_SHARED_PTR<RobotRaconteur::PipeClient<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > value=rrvar_p1;
if (!value) throw RobotRaconteur::InvalidOperationException("Stub has been closed");
return value;
}
void baseobj_stub::set_p1(const RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value)
{
throw RobotRaconteur::InvalidOperationException("Not valid for client");
}

RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > baseobj_stub::get_cb2()
{
RR_SHARED_PTR<RobotRaconteur::CallbackClient<boost::function<void(double, double) > > > value=rrvar_cb2;
if (!value) throw RobotRaconteur::InvalidOperationException("Stub has been closed");
return value;
}
void baseobj_stub::set_cb2(const RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > >& value)
{
throw RobotRaconteur::InvalidOperationException("Not valid for client");
}
RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > baseobj_stub::get_w1()
{
RR_SHARED_PTR<RobotRaconteur::WireClient<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > value=rrvar_w1;
if (!value) throw RobotRaconteur::InvalidOperationException("Stub has been closed");
return value;
}
void baseobj_stub::set_w1(const RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value)
{
throw RobotRaconteur::InvalidOperationException("Not valid for client");
}

RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > baseobj_stub::get_m1()
{
RR_SHARED_PTR<RobotRaconteur::ArrayMemoryClient<double > > value=rrvar_m1;
if (!value) throw RobotRaconteur::InvalidOperationException("Stub has been closed");
return value;
}
void baseobj_stub::DispatchEvent(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& rr_m)
{
if (rr_m->MemberName=="ev1")
{
get_ev1()();
return;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
void baseobj_stub::DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
if (m->MemberName=="p1")
{
rrvar_p1->PipePacketReceived(m);
return;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
void baseobj_stub::DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
if (m->MemberName=="w1")
{
rrvar_w1->WirePacketReceived(m);
return;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>baseobj_stub::CallbackCall(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& rr_m)
{
RobotRaconteur::MessageStringPtr& ename=rr_m->MemberName;
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_CallbackCallRet, ename);
rr_mr->ServicePath=rr_m->ServicePath;
rr_mr->RequestID=rr_m->RequestID;
if (rr_m->MemberName=="cb2")
{
double d1=RobotRaconteur::MessageElement_UnpackScalar<double >(rr_m->FindElement("d1"));
double d2=RobotRaconteur::MessageElement_UnpackScalar<double >(rr_m->FindElement("d2"));
rrvar_cb2->GetFunction()(d1, d2);
rr_mr->AddElement("return",RobotRaconteur::ScalarToRRArray<int32_t>(0));
return rr_mr;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

std::string baseobj_stub::RRType()
{
return "com.robotraconteur.testing.TestService2.baseobj";
}
void baseobj_stub::RRClose()
{
rrvar_p1->Shutdown();
rrvar_w1->Shutdown();
if (rrvar_m1)
{
rrvar_m1->Shutdown();
}
rrvar_ev1.disconnect_all_slots();
if (rrvar_cb2)
{
rrvar_cb2->Shutdown();
}
ServiceStub::RRClose();
}

RR_SHARED_PTR<RobotRaconteur::PipeClientBase> baseobj_stub::RRGetPipeClient(boost::string_ref membername)
{
if (membername =="p1") return rrvar_p1;
return ServiceStub::RRGetPipeClient(membername);
}

RR_SHARED_PTR<RobotRaconteur::WireClientBase> baseobj_stub::RRGetWireClient(boost::string_ref membername)
{
if (membername =="w1") return rrvar_w1;
return ServiceStub::RRGetWireClient(membername);
}

void baseobj_stub::async_get_d1(boost::function<void (double,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertyGetReq,"d1");
AsyncProcessRequest(m,boost::bind(&baseobj_stub::rrend_get_d1, RobotRaconteur::rr_cast<baseobj_stub>(shared_from_this()),RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),rr_handler ),rr_timeout);
}
void baseobj_stub::rrend_get_d1(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (double ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler)
{
if (err)
{
handler(0.0,err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(0.0,RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
double rr_ret;
try
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("value");
rr_ret=RobotRaconteur::MessageElement_UnpackScalar<double >(me);
}
catch (std::exception& err2)
{
RobotRaconteur::detail::InvokeHandlerWithException(node, handler, err2, RobotRaconteur::MessageErrorType_DataTypeError);
}
handler(rr_ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void baseobj_stub::async_set_d1(double value,boost::function<void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertySetReq,"d1");
req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("value",value));
AsyncProcessRequest(req,boost::bind(&baseobj_stub::rrend_set_d1, RobotRaconteur::rr_cast<baseobj_stub>(shared_from_this()),RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),rr_handler ),rr_timeout);
}
void baseobj_stub::rrend_set_d1(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler)
{
if (err)
{
handler(err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
handler(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void baseobj_stub::async_get_d2(boost::function<void (const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >&,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertyGetReq,"d2");
AsyncProcessRequest(m,boost::bind(&baseobj_stub::rrend_get_d2, RobotRaconteur::rr_cast<baseobj_stub>(shared_from_this()),RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),rr_handler ),rr_timeout);
}
void baseobj_stub::rrend_get_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler)
{
if (err)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >(),err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >(),RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > rr_ret;
try
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("value");
rr_ret=RobotRaconteur::MessageElement_UnpackArray<double >(me);
}
catch (std::exception& err2)
{
RobotRaconteur::detail::InvokeHandlerWithException(node, handler, err2, RobotRaconteur::MessageErrorType_DataTypeError);
}
handler(rr_ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void baseobj_stub::async_set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value,boost::function<void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertySetReq,"d2");
req->AddElement(RobotRaconteur::MessageElement_PackArrayElement<double >("value",value));
AsyncProcessRequest(req,boost::bind(&baseobj_stub::rrend_set_d2, RobotRaconteur::rr_cast<baseobj_stub>(shared_from_this()),RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),rr_handler ),rr_timeout);
}
void baseobj_stub::rrend_set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler)
{
if (err)
{
handler(err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
handler(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void baseobj_stub::async_func3(double d1, double d2,boost::function<void (double, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"func3");
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("d1",d1));
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("d2",d2));
AsyncProcessRequest(rr_req,boost::bind(&baseobj_stub::rrend_func3, RobotRaconteur::rr_cast<baseobj_stub>(shared_from_this()),RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),rr_handler ),rr_timeout);
}

void baseobj_stub::rrend_func3(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (double ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler)
{
if (err)
{
handler(0.0,err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(0.0,RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
double rr_ret;
try
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("return");
rr_ret=RobotRaconteur::MessageElement_UnpackScalar<double >(me);
}
catch (std::exception& err2)
{
RobotRaconteur::detail::InvokeHandlerWithException(node, handler, err2, RobotRaconteur::MessageErrorType_DataTypeError);
}
handler(rr_ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void baseobj_stub::async_get_o5(boost::function<void(RR_SHARED_PTR<subobj>,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&)> handler, int32_t timeout)
{
AsyncFindObjRefTyped("o5", "com.robotraconteur.testing.TestService2.subobj", boost::bind(&RobotRaconteur::ServiceStub::EndAsyncFindObjRef<subobj >,RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),handler) ,timeout);
}

subobj_stub::subobj_stub(boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::ClientContext>& c) : RobotRaconteur::ServiceStub(path,c){ }
void subobj_stub::RRInitStub()
{
}

double subobj_stub::add_val(double v)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"add_val");
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("v",v));
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_ret=ProcessRequest(rr_req);
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> rr_me=rr_ret->FindElement("return");
return RobotRaconteur::MessageElement_UnpackScalar<double >(rr_me);
}

void subobj_stub::DispatchEvent(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& rr_m)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
void subobj_stub::DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
void subobj_stub::DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>subobj_stub::CallbackCall(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& rr_m)
{
RobotRaconteur::MessageStringPtr& ename=rr_m->MemberName;
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_CallbackCallRet, ename);
rr_mr->ServicePath=rr_m->ServicePath;
rr_mr->RequestID=rr_m->RequestID;
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

std::string subobj_stub::RRType()
{
return "com.robotraconteur.testing.TestService2.subobj";
}
void subobj_stub::RRClose()
{
ServiceStub::RRClose();
}

RR_SHARED_PTR<RobotRaconteur::PipeClientBase> subobj_stub::RRGetPipeClient(boost::string_ref membername)
{
return ServiceStub::RRGetPipeClient(membername);
}

RR_SHARED_PTR<RobotRaconteur::WireClientBase> subobj_stub::RRGetWireClient(boost::string_ref membername)
{
return ServiceStub::RRGetWireClient(membername);
}

void subobj_stub::async_add_val(double v,boost::function<void (double, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"add_val");
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("v",v));
AsyncProcessRequest(rr_req,boost::bind(&subobj_stub::rrend_add_val, RobotRaconteur::rr_cast<subobj_stub>(shared_from_this()),RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),rr_handler ),rr_timeout);
}

void subobj_stub::rrend_add_val(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (double ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler)
{
if (err)
{
handler(0.0,err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(0.0,RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
double rr_ret;
try
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("return");
rr_ret=RobotRaconteur::MessageElement_UnpackScalar<double >(me);
}
catch (std::exception& err2)
{
RobotRaconteur::detail::InvokeHandlerWithException(node, handler, err2, RobotRaconteur::MessageErrorType_DataTypeError);
}
handler(rr_ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}

void baseobj_skel::Init(boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::RRObject>& object, const RR_SHARED_PTR<RobotRaconteur::ServerContext>& context)
{
uncastobj=object;
rr_InitPipeServersRun=false;
rr_InitWireServersRun=false;
rr_m1_mem.reset();
ServiceSkel::Init(path,object,context);
}
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj > baseobj_skel::get_obj()
{
return RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj >(uncastobj);
}
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_baseobj > baseobj_skel::get_asyncobj()
{
return RR_DYNAMIC_POINTER_CAST<com::robotraconteur::testing::TestService2::async_baseobj >(uncastobj);
}
void baseobj_skel::ReleaseCastObject() 
{
rr_p1_pipe->Shutdown();
rr_w1_wire->Shutdown();
get_obj()->get_cb2()->Shutdown();
}
std::string baseobj_skel::GetObjectType()
{
return "com.robotraconteur.testing.TestService2.baseobj";
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> baseobj_skel::CallGetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertyGetRes,m->MemberName);
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_baseobj > async_obj=get_asyncobj();
if (m->MemberName == "d1")
{
if (async_obj)
{
RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> wp=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj_skel>(shared_from_this());
async_obj->async_get_d1(boost::bind(&com::robotraconteur::testing::TestService2::baseobj_skel::rr_get_d1,wp,RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),m,RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()));
return RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>();
}
else
{
double value=get_obj()->get_d1();
mr->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("value",value));
return mr;
}
}
if (m->MemberName == "d2")
{
if (async_obj)
{
RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> wp=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj_skel>(shared_from_this());
async_obj->async_get_d2(boost::bind(&com::robotraconteur::testing::TestService2::baseobj_skel::rr_get_d2,wp,RR_BOOST_PLACEHOLDERS(_1),RR_BOOST_PLACEHOLDERS(_2),m,RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()));
return RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>();
}
else
{
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > value=get_obj()->get_d2();
mr->AddElement(RobotRaconteur::MessageElement_PackArrayElement<double >("value",value));
return mr;
}
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> baseobj_skel::CallSetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertySetRes,m->MemberName);
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_baseobj > async_obj=get_asyncobj();
if (m->MemberName == "d1")
{
double value=RobotRaconteur::MessageElement_UnpackScalar<double >(m->FindElement("value"));
if (async_obj)
{
RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> wp=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj_skel>(shared_from_this());
async_obj->async_set_d1(value,boost::bind(&RobotRaconteur::ServiceSkel::EndAsyncCallSetProperty,wp,RR_BOOST_PLACEHOLDERS(_1),m,RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()));
return RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>();
}
else
{
get_obj()->set_d1(value);
return mr;
}
}
if (m->MemberName == "d2")
{
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > value=RobotRaconteur::MessageElement_UnpackArray<double >(m->FindElement("value"));
if (async_obj)
{
RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> wp=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj_skel>(shared_from_this());
async_obj->async_set_d2(value,boost::bind(&RobotRaconteur::ServiceSkel::EndAsyncCallSetProperty,wp,RR_BOOST_PLACEHOLDERS(_1),m,RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()));
return RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>();
}
else
{
get_obj()->set_d2(value);
return mr;
}
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void baseobj_skel::rr_get_d1(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel,double value, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::ServerEndpoint>& ep)
{
if(err)
{
EndAsyncCallGetProperty(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),err,m, ep);
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> mr;
try
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel1=skel.lock();
if (!skel1) throw RobotRaconteur::InvalidOperationException("skel release");
mr=RobotRaconteur::MessageElement_PackScalarElement<double >("value",value);
}
catch (std::exception& err2)
{
EndAsyncCallGetProperty(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),RobotRaconteur::RobotRaconteurExceptionUtil::ExceptionToSharedPtr(err2, RobotRaconteur::MessageErrorType_DataTypeError),m, ep);
return;
}
EndAsyncCallGetProperty(skel, mr, err, m,ep);
}
void baseobj_skel::rr_get_d2(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel,RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > value, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::ServerEndpoint>& ep)
{
if(err)
{
EndAsyncCallGetProperty(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),err,m, ep);
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> mr;
try
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel1=skel.lock();
if (!skel1) throw RobotRaconteur::InvalidOperationException("skel release");
mr=RobotRaconteur::MessageElement_PackArrayElement<double >("value",value);
}
catch (std::exception& err2)
{
EndAsyncCallGetProperty(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),RobotRaconteur::RobotRaconteurExceptionUtil::ExceptionToSharedPtr(err2, RobotRaconteur::MessageErrorType_DataTypeError),m, ep);
return;
}
EndAsyncCallGetProperty(skel, mr, err, m,ep);
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> baseobj_skel::CallFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& rr_m)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallRes,rr_m->MemberName);
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_baseobj > async_obj=get_asyncobj();
if (rr_m->MemberName == "func3")
{
double d1 =RobotRaconteur::MessageElement_UnpackScalar<double >(rr_m->FindElement("d1"));
double d2 =RobotRaconteur::MessageElement_UnpackScalar<double >(rr_m->FindElement("d2"));
if (async_obj)
{
RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> rr_wp=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj_skel>(shared_from_this());
async_obj->async_func3(d1, d2, boost::bind(&com::robotraconteur::testing::TestService2::baseobj_skel::rr_func3, rr_wp, RR_BOOST_PLACEHOLDERS(_1), RR_BOOST_PLACEHOLDERS(_2), rr_m, RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()));
return RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>();
}
else
{
double rr_return=get_obj()->func3(d1, d2);
rr_mr->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("return",rr_return));
return rr_mr;
}
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void baseobj_skel::rr_func3(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel, double ret, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep)
{
if(err)
{
EndAsyncCallFunction(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),err,m, ep);
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> mr;
try
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel1=skel.lock();
if (!skel1) throw RobotRaconteur::InvalidOperationException("skel release");
mr=RobotRaconteur::MessageElement_PackScalarElement<double >("return",ret);
}
catch (std::exception& err2)
{
EndAsyncCallFunction(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),RobotRaconteur::RobotRaconteurExceptionUtil::ExceptionToSharedPtr(err2, RobotRaconteur::MessageErrorType_DataTypeError),m, ep);
return;
}
EndAsyncCallFunction(skel, mr, err, m,ep);
}
void baseobj_skel::rr_ev1_Handler()
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_mm=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_EventReq,"ev1");
SendEvent(rr_mm);
}
void baseobj_skel::RegisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj >(rrobj1);
ev1_rrconnection=obj->get_ev1().connect(boost::bind(&baseobj_skel::rr_ev1_Handler, RobotRaconteur::rr_cast<baseobj_skel>(shared_from_this())));
RobotRaconteur::ServiceSkel::RegisterEvents(rrobj1);
}

void baseobj_skel::UnregisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
ev1_rrconnection.disconnect();
RobotRaconteur::ServiceSkel::UnregisterEvents(rrobj1);
}

RR_SHARED_PTR<RobotRaconteur::RRObject> baseobj_skel::GetSubObj(boost::string_ref name, boost::string_ref ind)
{
if (name=="o5")
{
return RobotRaconteur::rr_cast<RobotRaconteur::RRObject>(get_obj()->get_o5());
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void baseobj_skel::InitPipeServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
if (rr_InitPipeServersRun) return;
rr_InitPipeServersRun=true;
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj >(rrobj1);
rr_p1_pipe=RR_MAKE_SHARED<RobotRaconteur::PipeServer<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >("p1",shared_from_this(),false,RobotRaconteur::MemberDefinition_Direction_both);
obj->set_p1(rr_p1_pipe);
}

void baseobj_skel::DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
if (m->MemberName=="p1")
{
rr_p1_pipe->PipePacketReceived(m,e);
return;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> baseobj_skel::CallPipeFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
if (m->MemberName=="p1")
{
return rr_p1_pipe->PipeCommand(m,e);
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void baseobj_skel::InitWireServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
if (rr_InitWireServersRun) return;
rr_InitWireServersRun=true;
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj >(rrobj1);
rr_w1_wire=RR_MAKE_SHARED<RobotRaconteur::WireServer<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >("w1",shared_from_this(),RobotRaconteur::MemberDefinition_Direction_both);
obj->set_w1(rr_w1_wire);
}

void baseobj_skel::DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
if (m->MemberName=="w1")
{
rr_w1_wire->WirePacketReceived(m,e);
return;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> baseobj_skel::CallWireFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
if (m->MemberName=="w1")
{
return rr_w1_wire->WireCommand(m,e);
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void baseobj_skel::InitCallbackServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& o)
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::baseobj >(o);
obj->set_cb2(RR_MAKE_SHARED<RobotRaconteur::CallbackServer<boost::function<void(double, double) > > >("cb2",shared_from_this()));
}
void baseobj_skel::rr_cb2_callback(uint32_t rrendpoint, double d1, double d2){
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_CallbackCallReq,"cb2");
rr_req->ServicePath=GetServicePath();
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("d1",d1));
rr_req->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("d2",d2));
RR_SHARED_PTR<RobotRaconteur::ServerContext> rr_s=GetContext();
if (rr_s==0) throw RobotRaconteur::InvalidOperationException("Service has been closed");
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_ret=rr_s->ProcessCallbackRequest(rr_req,rrendpoint);
}

RR_SHARED_PTR<void> baseobj_skel::GetCallbackFunction(uint32_t endpoint, boost::string_ref membername)
{
if (membername=="cb2")
{
return RR_MAKE_SHARED<boost::function<void(double, double) > >(boost::bind(&baseobj_skel::rr_cb2_callback, RobotRaconteur::rr_cast<baseobj_skel>(shared_from_this()), endpoint, RR_BOOST_PLACEHOLDERS(_1), RR_BOOST_PLACEHOLDERS(_2)));
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> baseobj_skel::CallMemoryFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::Endpoint>& e)
{
if (m->MemberName=="m1")
{
if (rr_m1_mem==0) rr_m1_mem=RR_MAKE_SHARED<RobotRaconteur::ArrayMemoryServiceSkel<double > >("m1",shared_from_this(),RobotRaconteur::MemberDefinition_Direction_both);
return rr_m1_mem->CallMemoryFunction(m,e,get_obj()->get_m1());
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
bool baseobj_skel::IsRequestNoLock(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
return false;
}
void subobj_skel::Init(boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::RRObject>& object, const RR_SHARED_PTR<RobotRaconteur::ServerContext>& context)
{
uncastobj=object;
rr_InitPipeServersRun=false;
rr_InitWireServersRun=false;
ServiceSkel::Init(path,object,context);
}
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj > subobj_skel::get_obj()
{
return RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::subobj >(uncastobj);
}
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_subobj > subobj_skel::get_asyncobj()
{
return RR_DYNAMIC_POINTER_CAST<com::robotraconteur::testing::TestService2::async_subobj >(uncastobj);
}
void subobj_skel::ReleaseCastObject() 
{
}
std::string subobj_skel::GetObjectType()
{
return "com.robotraconteur.testing.TestService2.subobj";
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> subobj_skel::CallGetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertyGetRes,m->MemberName);
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_subobj > async_obj=get_asyncobj();
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> subobj_skel::CallSetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_PropertySetRes,m->MemberName);
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_subobj > async_obj=get_asyncobj();
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> subobj_skel::CallFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& rr_m)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallRes,rr_m->MemberName);
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_subobj > async_obj=get_asyncobj();
if (rr_m->MemberName == "add_val")
{
double v =RobotRaconteur::MessageElement_UnpackScalar<double >(rr_m->FindElement("v"));
if (async_obj)
{
RR_WEAK_PTR<com::robotraconteur::testing::TestService2::subobj_skel> rr_wp=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::subobj_skel>(shared_from_this());
async_obj->async_add_val(v, boost::bind(&com::robotraconteur::testing::TestService2::subobj_skel::rr_add_val, rr_wp, RR_BOOST_PLACEHOLDERS(_1), RR_BOOST_PLACEHOLDERS(_2), rr_m, RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()));
return RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>();
}
else
{
double rr_return=get_obj()->add_val(v);
rr_mr->AddElement(RobotRaconteur::MessageElement_PackScalarElement<double >("return",rr_return));
return rr_mr;
}
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void subobj_skel::rr_add_val(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::subobj_skel> skel, double ret, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep)
{
if(err)
{
EndAsyncCallFunction(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),err,m, ep);
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> mr;
try
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj_skel> skel1=skel.lock();
if (!skel1) throw RobotRaconteur::InvalidOperationException("skel release");
mr=RobotRaconteur::MessageElement_PackScalarElement<double >("return",ret);
}
catch (std::exception& err2)
{
EndAsyncCallFunction(skel,RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement>(),RobotRaconteur::RobotRaconteurExceptionUtil::ExceptionToSharedPtr(err2, RobotRaconteur::MessageErrorType_DataTypeError),m, ep);
return;
}
EndAsyncCallFunction(skel, mr, err, m,ep);
}
void subobj_skel::RegisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::subobj >(rrobj1);
RobotRaconteur::ServiceSkel::RegisterEvents(rrobj1);
}

void subobj_skel::UnregisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
RobotRaconteur::ServiceSkel::UnregisterEvents(rrobj1);
}

RR_SHARED_PTR<RobotRaconteur::RRObject> subobj_skel::GetSubObj(boost::string_ref name, boost::string_ref ind)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void subobj_skel::InitPipeServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
if (rr_InitPipeServersRun) return;
rr_InitPipeServersRun=true;
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::subobj >(rrobj1);
}

void subobj_skel::DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> subobj_skel::CallPipeFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void subobj_skel::InitWireServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1)
{
if (rr_InitWireServersRun) return;
rr_InitWireServersRun=true;
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::subobj >(rrobj1);
}

void subobj_skel::DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> subobj_skel::CallWireFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

void subobj_skel::InitCallbackServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& o)
{
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj > obj=RobotRaconteur::rr_cast<com::robotraconteur::testing::TestService2::subobj >(o);
}
RR_SHARED_PTR<void> subobj_skel::GetCallbackFunction(uint32_t endpoint, boost::string_ref membername)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> subobj_skel::CallMemoryFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::Endpoint>& e)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
bool subobj_skel::IsRequestNoLock(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m)
{
return false;
}

baseobj_default_impl::baseobj_default_impl()
{
rrvar_d1=0.0;
rrvar_d2=RobotRaconteur::AllocateEmptyRRArray<double>(0);
}
double baseobj_default_impl::get_d1()
{
boost::mutex::scoped_lock lock(this_lock);
return rrvar_d1;
}
void baseobj_default_impl::set_d1(double value)
{
boost::mutex::scoped_lock lock(this_lock);
rrvar_d1 = value;
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > baseobj_default_impl::get_d2()
{
boost::mutex::scoped_lock lock(this_lock);
return rrvar_d2;
}
void baseobj_default_impl::set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value)
{
boost::mutex::scoped_lock lock(this_lock);
rrvar_d2 = value;
}
double baseobj_default_impl::func3(double d1, double d2)
{
throw RobotRaconteur::NotImplementedException("");
}
boost::signals2::signal<void ()>& baseobj_default_impl::get_ev1()
{
return rrvar_ev1;
}
RR_SHARED_PTR<subobj > baseobj_default_impl::get_o5()
{
throw RobotRaconteur::NotImplementedException("");
}
RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > baseobj_default_impl::get_p1()
{
throw RobotRaconteur::NotImplementedException("");
}
void baseobj_default_impl::set_p1(const RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value)
{
throw RobotRaconteur::NotImplementedException("");
}
RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > baseobj_default_impl::get_cb2()
{
boost::mutex::scoped_lock lock(this_lock);
return rrvar_cb2;
}
void baseobj_default_impl::set_cb2(const RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > >& value)
{
boost::mutex::scoped_lock lock(this_lock);
if (rrvar_cb2) throw RobotRaconteur::InvalidOperationException("Callback already set");
rrvar_cb2 = value;
}
RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > baseobj_default_impl::get_w1()
{
throw RobotRaconteur::NotImplementedException("");
}
void baseobj_default_impl::set_w1(const RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value)
{
throw RobotRaconteur::NotImplementedException("");
}
RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > baseobj_default_impl::get_m1()
{
throw RobotRaconteur::NotImplementedException("");
}
subobj_default_impl::subobj_default_impl()
{
}
double subobj_default_impl::add_val(double v)
{
throw RobotRaconteur::NotImplementedException("");
}

baseobj_default_abstract_impl::baseobj_default_abstract_impl()
{
rrvar_d1=0.0;
rrvar_d2=RobotRaconteur::AllocateEmptyRRArray<double>(0);
}
double baseobj_default_abstract_impl::get_d1()
{
boost::mutex::scoped_lock lock(this_lock);
return rrvar_d1;
}
void baseobj_default_abstract_impl::set_d1(double value)
{
boost::mutex::scoped_lock lock(this_lock);
rrvar_d1 = value;
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > baseobj_default_abstract_impl::get_d2()
{
boost::mutex::scoped_lock lock(this_lock);
return rrvar_d2;
}
void baseobj_default_abstract_impl::set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value)
{
boost::mutex::scoped_lock lock(this_lock);
rrvar_d2 = value;
}
double baseobj_default_abstract_impl::func3(double d1, double d2)
{
throw RobotRaconteur::NotImplementedException("");
}
boost::signals2::signal<void ()>& baseobj_default_abstract_impl::get_ev1()
{
return rrvar_ev1;
}
RR_SHARED_PTR<subobj > baseobj_default_abstract_impl::get_o5()
{
throw RobotRaconteur::NotImplementedException("");
}
RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > baseobj_default_abstract_impl::get_p1()
{
throw RobotRaconteur::NotImplementedException("");
}
void baseobj_default_abstract_impl::set_p1(const RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value)
{
throw RobotRaconteur::NotImplementedException("");
}
RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > baseobj_default_abstract_impl::get_cb2()
{
boost::mutex::scoped_lock lock(this_lock);
return rrvar_cb2;
}
void baseobj_default_abstract_impl::set_cb2(const RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > >& value)
{
boost::mutex::scoped_lock lock(this_lock);
if (rrvar_cb2) throw RobotRaconteur::InvalidOperationException("Callback already set");
rrvar_cb2 = value;
}
RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > baseobj_default_abstract_impl::get_w1()
{
throw RobotRaconteur::NotImplementedException("");
}
void baseobj_default_abstract_impl::set_w1(const RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value)
{
throw RobotRaconteur::NotImplementedException("");
}
RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > baseobj_default_abstract_impl::get_m1()
{
throw RobotRaconteur::NotImplementedException("");
}
subobj_default_abstract_impl::subobj_default_abstract_impl()
{
}
double subobj_default_abstract_impl::add_val(double v)
{
throw RobotRaconteur::NotImplementedException("");
}

}
}
}
}
// NOLINTEND

