# Copyright 2011-2020 Wason Technology, LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is automatically generated. Do not edit.

from __future__ import absolute_import

from . import RobotRaconteurPython
import threading
import string


class RobotRaconteurException(Exception):
    __slots__ = ["errorcode","errorname","message","errorsubname","errorparam"]
    def __init__(self,errorcode,errorname,errormessage,errorsubname=None,errorparam=None):
        self.errorcode=errorcode
        self.errorname=errorname
        self.message=errormessage
        self.errorsubname=errorsubname
        self.errorparam=errorparam
    def __str__(self):
        return self.errorname + " " + self.message

@RR_ERRORS_DECL@

class RobotRaconteurExceptionUtil:

    @staticmethod
    def ExceptionToErrorCode(exception):
@RR_ERRORS_CATCH@
        if (isinstance(exception,RobotRaconteurException)):
            return exception.errorcode, exception.errorname, exception.message, exception.errorsubname, exception.errorparam
        else:
            return RobotRaconteurPython.MessageErrorType_RemoteError, type(exception).__name__, str(exception), None, None

    @staticmethod
    def ErrorCodeToException(code,name,errstr,subname,param_):
        param2 = None
        if (param_ is not None):
            from .RobotRaconteurPythonUtil import UnpackMessageElement
            param2 = UnpackMessageElement(param_,"varvalue")
        if subname is not None and len(subname) == 0:
            subname = None
        if (code==RobotRaconteurPython.MessageErrorType_RemoteError):
            e= GetExceptionType(name)
            return e(errstr,subname,param2)

@RR_ERRORS_CASE@
        return RobotRaconteurException(code,name,errstr,subname,param2)

    @staticmethod
    def ErrorInfoToException(error_info):
        return RobotRaconteurExceptionUtil.ErrorCodeToException(error_info.error_code, error_info.errorname, error_info.errormessage, error_info.errorsubname, error_info.param_)

    @staticmethod
    def ExceptionToErrorInfo(exp):
        error_code, errorname, message, errorsubname, errorparam = RobotRaconteurExceptionUtil.ExceptionToErrorCode(exp)
        error_info = RobotRaconteurPython.HandlerErrorInfo()
        error_info.error_code = error_code
        error_info.errorname = errorname
        if message is not None:
            error_info.errormessage = message
        if errorsubname is not None:
            error_info.errorsubname = errorsubname
        if errorparam is not None:
            from .RobotRaconteurPythonUtil import PackMessageElement
            param2 = PackMessageElement(errorparam,"varvalue")
            error_info.errorparam = param2

        return error_info

_generated_exceptions=dict()
_generated_exceptions_lock=threading.Lock()

def _ExceptionFactory(name):
    def __init__(self,message,subname=None,param_=None):
        super(self.__class__,self).__init__(name,message,subname,param_)
    return type(name, (RobotRaconteurRemoteException,), {"__init__": __init__})

def GetExceptionType(exception_name):
    if (not (isinstance(exception_name,str) or isinstance(exception_name,unicode))):
        return Exception
    ex1=exception_name.replace('.','__')
    ex2=''.join([x for x in ex1 if x in (string.ascii_letters + string.digits + "_")])
    with _generated_exceptions_lock:
        if (exception_name in _generated_exceptions):
            return _generated_exceptions[exception_name]
        else:
            newexp=_ExceptionFactory(exception_name)
            _generated_exceptions[exception_name]=newexp
            return newexp
