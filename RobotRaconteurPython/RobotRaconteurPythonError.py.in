# Copyright 2011-2018 Wason Technology, LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is automatically generated. Do not edit.

from __future__ import absolute_import

from . import RobotRaconteurPython
import threading
import string


class RobotRaconteurException(Exception):
    def __init__(self,errorcode,errorname,errormessage):
        self.errorcode=errorcode
        self.errorname=errorname
        self.message=errormessage
    def __str__(self):
        return self.errorname + " " + self.message

@RR_ERRORS_DECL@

class RobotRaconteurExceptionUtil:

    @staticmethod
    def ExceptionToErrorCode(exception, entry):
@RR_ERRORS_CATCH@
        if (isinstance(exception,RobotRaconteurException)):
            return exception.errorcode, exception.errorname, exception.message
        else:
            return RobotRaconteurPython.MessageErrorType_RemoteError, type(exception).__name__, exception.message

    @staticmethod
    def ErrorCodeToException(code,name,errstr):
        if (code==RobotRaconteurPython.MessageErrorType_RemoteError):
            e= GetExceptionType(name)
            return e(errstr)

@RR_ERRORS_CASE@        
        return RobotRaconteurException(code,name,errstr)

_generated_exceptions=dict()
_generated_exceptions_lock=threading.Lock()

def _ExceptionFactory(name):
    def __init__(self,message):
        super(self.__class__,self).__init__(name,message)
    return type(name, (RobotRaconteurRemoteException,), {"__init__": __init__})

def GetExceptionType(exception_name):
    if (not (isinstance(exception_name,str) or isinstance(exception_name,unicode))):
        return Exception
    ex1=exception_name.replace('.','__')
    ex2=''.join([x for x in ex1 if x in (string.ascii_letters + string.digits + "_")])
    with _generated_exceptions_lock:
        if (exception_name in _generated_exceptions):
            return _generated_exceptions[exception_name]
        else:
            newexp=_ExceptionFactory(exception_name)
            _generated_exceptions[exception_name]=newexp
            return newexp