/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_RobotRaconteurPython_WRAP_H_
#define SWIG_RobotRaconteurPython_WRAP_H_

#include <map>
#include <string>


class SwigDirector_AsyncRequestDirector : public RobotRaconteur::AsyncRequestDirector, public Swig::Director {

public:
    SwigDirector_AsyncRequestDirector(PyObject *self);
    virtual ~SwigDirector_AsyncRequestDirector();
    virtual void handler(boost::intrusive_ptr< RobotRaconteur::MessageElement > ret,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncRequestDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncVoidReturnDirector : public RobotRaconteur::AsyncVoidReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncVoidReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncVoidReturnDirector();
    virtual void handler(RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncVoidReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncVoidNoErrReturnDirector : public RobotRaconteur::AsyncVoidNoErrReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncVoidNoErrReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncVoidNoErrReturnDirector();
    virtual void handler();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncVoidNoErrReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncStringReturnDirector : public RobotRaconteur::AsyncStringReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncStringReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncStringReturnDirector();
    virtual void handler(std::string const &ret,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncStringReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncUInt32ReturnDirector : public RobotRaconteur::AsyncUInt32ReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncUInt32ReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncUInt32ReturnDirector();
    virtual void handler(uint32_t ret,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncUInt32ReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncTimerEventReturnDirector : public RobotRaconteur::AsyncTimerEventReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncTimerEventReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncTimerEventReturnDirector();
    virtual void handler(RobotRaconteur::TimerEvent const &ret,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncTimerEventReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedPipeEndpointDirector : public RobotRaconteur::WrappedPipeEndpointDirector, public Swig::Director {

public:
    SwigDirector_WrappedPipeEndpointDirector(PyObject *self);
    virtual ~SwigDirector_WrappedPipeEndpointDirector();
    virtual void PipeEndpointClosedCallback();
    virtual void PacketReceivedEvent();
    virtual void PacketAckReceivedEvent(uint32_t packetnum);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPipeEndpointDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_AsyncPipeEndpointReturnDirector : public RobotRaconteur::AsyncPipeEndpointReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncPipeEndpointReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncPipeEndpointReturnDirector();
    virtual void handler(boost::shared_ptr< RobotRaconteur::WrappedPipeEndpoint > const &ep,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncPipeEndpointReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedPipeServerConnectDirector : public RobotRaconteur::WrappedPipeServerConnectDirector, public Swig::Director {

public:
    SwigDirector_WrappedPipeServerConnectDirector(PyObject *self);
    virtual ~SwigDirector_WrappedPipeServerConnectDirector();
    virtual void PipeConnectCallback(boost::shared_ptr< RobotRaconteur::WrappedPipeEndpoint > const &pipeendpoint);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPipeServerConnectDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedPipeBroadcasterPredicateDirector : public RobotRaconteur::WrappedPipeBroadcasterPredicateDirector, public Swig::Director {

public:
    SwigDirector_WrappedPipeBroadcasterPredicateDirector(PyObject *self);
    virtual bool Predicate(uint32_t client_endpoint,int32_t index);
    virtual ~SwigDirector_WrappedPipeBroadcasterPredicateDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPipeBroadcasterPredicateDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedWireConnectionDirector : public RobotRaconteur::WrappedWireConnectionDirector, public Swig::Director {

public:
    SwigDirector_WrappedWireConnectionDirector(PyObject *self);
    virtual ~SwigDirector_WrappedWireConnectionDirector();
    virtual void WireValueChanged(boost::intrusive_ptr< RobotRaconteur::MessageElement > value,RobotRaconteur::TimeSpec const &time);
    virtual void WireConnectionClosedCallback();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedWireConnectionDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_AsyncWireConnectionReturnDirector : public RobotRaconteur::AsyncWireConnectionReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncWireConnectionReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncWireConnectionReturnDirector();
    virtual void handler(boost::shared_ptr< RobotRaconteur::WrappedWireConnection > const &ep,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncWireConnectionReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncWirePeekReturnDirector : public RobotRaconteur::AsyncWirePeekReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncWirePeekReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncWirePeekReturnDirector();
    virtual void handler(boost::intrusive_ptr< RobotRaconteur::MessageElement > value,RobotRaconteur::TimeSpec const &ts,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncWirePeekReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedWireServerConnectDirector : public RobotRaconteur::WrappedWireServerConnectDirector, public Swig::Director {

public:
    SwigDirector_WrappedWireServerConnectDirector(PyObject *self);
    virtual ~SwigDirector_WrappedWireServerConnectDirector();
    virtual void WireConnectCallback(boost::shared_ptr< RobotRaconteur::WrappedWireConnection > const &c);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedWireServerConnectDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedWireServerPeekValueDirector : public RobotRaconteur::WrappedWireServerPeekValueDirector, public Swig::Director {

public:
    SwigDirector_WrappedWireServerPeekValueDirector(PyObject *self);
    virtual ~SwigDirector_WrappedWireServerPeekValueDirector();
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElement > PeekValue(uint32_t const &ep);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedWireServerPeekValueDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedWireServerPokeValueDirector : public RobotRaconteur::WrappedWireServerPokeValueDirector, public Swig::Director {

public:
    SwigDirector_WrappedWireServerPokeValueDirector(PyObject *self);
    virtual ~SwigDirector_WrappedWireServerPokeValueDirector();
    virtual void PokeValue(boost::intrusive_ptr< RobotRaconteur::MessageElement > value,RobotRaconteur::TimeSpec const &ts,uint32_t const &ep);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedWireServerPokeValueDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedWireBroadcasterPredicateDirector : public RobotRaconteur::WrappedWireBroadcasterPredicateDirector, public Swig::Director {

public:
    SwigDirector_WrappedWireBroadcasterPredicateDirector(PyObject *self);
    virtual bool Predicate(uint32_t client_endpoint);
    virtual ~SwigDirector_WrappedWireBroadcasterPredicateDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedWireBroadcasterPredicateDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedPodArrayMemoryClientBuffer : public RobotRaconteur::WrappedPodArrayMemoryClientBuffer, public Swig::Director {

public:
    SwigDirector_WrappedPodArrayMemoryClientBuffer(PyObject *self);
    virtual void UnpackReadResult(boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > res,uint64_t bufferpos,uint64_t count);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > PackWriteRequest(uint64_t bufferpos,uint64_t count);
    virtual uint64_t GetBufferLength();
    virtual ~SwigDirector_WrappedPodArrayMemoryClientBuffer();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPodArrayMemoryClientBuffer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedPodMultiDimArrayMemoryClientBuffer : public RobotRaconteur::WrappedPodMultiDimArrayMemoryClientBuffer, public Swig::Director {

public:
    SwigDirector_WrappedPodMultiDimArrayMemoryClientBuffer(PyObject *self);
    virtual void UnpackReadResult(boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > res,std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > PackWriteRequest(std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);
    virtual ~SwigDirector_WrappedPodMultiDimArrayMemoryClientBuffer();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPodMultiDimArrayMemoryClientBuffer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_WrappedArrayMemoryDirector : public RobotRaconteur::WrappedArrayMemoryDirector, public Swig::Director {

public:
    SwigDirector_WrappedArrayMemoryDirector(PyObject *self);
    virtual ~SwigDirector_WrappedArrayMemoryDirector();
    virtual uint64_t Length();
    virtual void Read(uint64_t memorypos,boost::intrusive_ptr< RobotRaconteur::RRBaseArray > buffer,uint64_t bufferpos,uint64_t count);
    virtual void Write(uint64_t memorypos,boost::intrusive_ptr< RobotRaconteur::RRBaseArray > buffer,uint64_t bufferpos,uint64_t count);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedArrayMemoryDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedMultiDimArrayMemoryDirector : public RobotRaconteur::WrappedMultiDimArrayMemoryDirector, public Swig::Director {

public:
    SwigDirector_WrappedMultiDimArrayMemoryDirector(PyObject *self);
    virtual ~SwigDirector_WrappedMultiDimArrayMemoryDirector();
    virtual std::vector< uint64_t,std::allocator< uint64_t > > Dimensions();
    virtual uint64_t DimCount();
    virtual void Read(RobotRaconteur::WrappedMultiDimArrayMemoryParams *p);
    virtual void Write(RobotRaconteur::WrappedMultiDimArrayMemoryParams *p);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedMultiDimArrayMemoryDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_WrappedPodArrayMemoryDirector : public RobotRaconteur::WrappedPodArrayMemoryDirector, public Swig::Director {

public:
    SwigDirector_WrappedPodArrayMemoryDirector(PyObject *self);
    virtual ~SwigDirector_WrappedPodArrayMemoryDirector();
    virtual uint64_t Length();
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > Read(uint64_t memorypos,uint64_t bufferpos,uint64_t count);
    virtual void Write(uint64_t memorypos,boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > buffer,uint64_t bufferpos,uint64_t count);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPodArrayMemoryDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedPodMultiDimArrayMemoryDirector : public RobotRaconteur::WrappedPodMultiDimArrayMemoryDirector, public Swig::Director {

public:
    SwigDirector_WrappedPodMultiDimArrayMemoryDirector(PyObject *self);
    virtual ~SwigDirector_WrappedPodMultiDimArrayMemoryDirector();
    virtual std::vector< uint64_t,std::allocator< uint64_t > > Dimensions();
    virtual uint64_t DimCount();
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > Read(std::vector< uint64_t,std::allocator< uint64_t > > const &memorypos,std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);
    virtual void Write(std::vector< uint64_t,std::allocator< uint64_t > > const &memorypos,boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > buffer,std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPodMultiDimArrayMemoryDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_WrappedNamedArrayMemoryClientBuffer : public RobotRaconteur::WrappedNamedArrayMemoryClientBuffer, public Swig::Director {

public:
    SwigDirector_WrappedNamedArrayMemoryClientBuffer(PyObject *self);
    virtual void UnpackReadResult(boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > res,uint64_t bufferpos,uint64_t count);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > PackWriteRequest(uint64_t bufferpos,uint64_t count);
    virtual uint64_t GetBufferLength();
    virtual ~SwigDirector_WrappedNamedArrayMemoryClientBuffer();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedNamedArrayMemoryClientBuffer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedNamedMultiDimArrayMemoryClientBuffer : public RobotRaconteur::WrappedNamedMultiDimArrayMemoryClientBuffer, public Swig::Director {

public:
    SwigDirector_WrappedNamedMultiDimArrayMemoryClientBuffer(PyObject *self);
    virtual void UnpackReadResult(boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > res,std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > PackWriteRequest(std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);
    virtual ~SwigDirector_WrappedNamedMultiDimArrayMemoryClientBuffer();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedNamedMultiDimArrayMemoryClientBuffer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_WrappedNamedArrayMemoryDirector : public RobotRaconteur::WrappedNamedArrayMemoryDirector, public Swig::Director {

public:
    SwigDirector_WrappedNamedArrayMemoryDirector(PyObject *self);
    virtual ~SwigDirector_WrappedNamedArrayMemoryDirector();
    virtual uint64_t Length();
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > Read(uint64_t memorypos,uint64_t bufferpos,uint64_t count);
    virtual void Write(uint64_t memorypos,boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > buffer,uint64_t bufferpos,uint64_t count);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedNamedArrayMemoryDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedNamedMultiDimArrayMemoryDirector : public RobotRaconteur::WrappedNamedMultiDimArrayMemoryDirector, public Swig::Director {

public:
    SwigDirector_WrappedNamedMultiDimArrayMemoryDirector(PyObject *self);
    virtual ~SwigDirector_WrappedNamedMultiDimArrayMemoryDirector();
    virtual std::vector< uint64_t,std::allocator< uint64_t > > Dimensions();
    virtual uint64_t DimCount();
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > Read(std::vector< uint64_t,std::allocator< uint64_t > > const &memorypos,std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);
    virtual void Write(std::vector< uint64_t,std::allocator< uint64_t > > const &memorypos,boost::intrusive_ptr< RobotRaconteur::MessageElementNestedElementList > buffer,std::vector< uint64_t,std::allocator< uint64_t > > const &bufferpos,std::vector< uint64_t,std::allocator< uint64_t > > const &count);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedNamedMultiDimArrayMemoryDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_AsyncGeneratorClientReturnDirector : public RobotRaconteur::AsyncGeneratorClientReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncGeneratorClientReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncGeneratorClientReturnDirector();
    virtual void handler(boost::shared_ptr< RobotRaconteur::WrappedGeneratorClient > const &ret,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncGeneratorClientReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedGeneratorServerDirector : public RobotRaconteur::WrappedGeneratorServerDirector, public Swig::Director {

public:
    SwigDirector_WrappedGeneratorServerDirector(PyObject *self);
    virtual ~SwigDirector_WrappedGeneratorServerDirector();
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElement > Next(boost::intrusive_ptr< RobotRaconteur::MessageElement > m,boost::shared_ptr< RobotRaconteur::WrappedServiceSkelAsyncAdapter > const &async_adaptor);
    virtual void Abort(boost::shared_ptr< RobotRaconteur::WrappedServiceSkelAsyncAdapter > const &async_adapter);
    virtual void Close(boost::shared_ptr< RobotRaconteur::WrappedServiceSkelAsyncAdapter > const &async_adapter);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedGeneratorServerDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedServiceStubDirector : public RobotRaconteur::WrappedServiceStubDirector, public Swig::Director {

public:
    SwigDirector_WrappedServiceStubDirector(PyObject *self);
    virtual ~SwigDirector_WrappedServiceStubDirector();
    virtual void DispatchEvent(std::string const &EventName,std::vector< boost::intrusive_ptr< RobotRaconteur::MessageElement >,std::allocator< boost::intrusive_ptr< RobotRaconteur::MessageElement > > > args);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElement > CallbackCall(std::string const &CallbackName,std::vector< boost::intrusive_ptr< RobotRaconteur::MessageElement >,std::allocator< boost::intrusive_ptr< RobotRaconteur::MessageElement > > > args);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedServiceStubDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_AsyncStubReturnDirector : public RobotRaconteur::AsyncStubReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncStubReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncStubReturnDirector();
    virtual void handler(boost::shared_ptr< RobotRaconteur::WrappedServiceStub > const &stub,RobotRaconteur::HandlerErrorInfo &error);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncStubReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedServiceSkelDirector : public RobotRaconteur::WrappedServiceSkelDirector, public Swig::Director {

public:
    SwigDirector_WrappedServiceSkelDirector(PyObject *self);
    virtual ~SwigDirector_WrappedServiceSkelDirector();
    virtual void Init(boost::shared_ptr< RobotRaconteur::WrappedServiceSkel > const &skel);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElement > CallGetProperty(std::string const &name,boost::shared_ptr< RobotRaconteur::WrappedServiceSkelAsyncAdapter > const &async_adaptor);
    virtual void CallSetProperty(std::string const &name,boost::intrusive_ptr< RobotRaconteur::MessageElement > m,boost::shared_ptr< RobotRaconteur::WrappedServiceSkelAsyncAdapter > const &async_adaptor);
    virtual boost::intrusive_ptr< RobotRaconteur::MessageElement > CallFunction(std::string const &name,std::vector< boost::intrusive_ptr< RobotRaconteur::MessageElement >,std::allocator< boost::intrusive_ptr< RobotRaconteur::MessageElement > > > const &m,boost::shared_ptr< RobotRaconteur::WrappedServiceSkelAsyncAdapter > const &async_adaptor);
    virtual boost::shared_ptr< RobotRaconteur::WrappedRRObject > GetSubObj(std::string const &name,std::string const &index);
    virtual RobotRaconteur::WrappedArrayMemoryDirector *GetArrayMemory(std::string const &name);
    virtual RobotRaconteur::WrappedMultiDimArrayMemoryDirector *GetMultiDimArrayMemory(std::string const &name);
    virtual RobotRaconteur::WrappedPodArrayMemoryDirector *GetPodArrayMemory(std::string const &name);
    virtual RobotRaconteur::WrappedPodMultiDimArrayMemoryDirector *GetPodMultiDimArrayMemory(std::string const &name);
    virtual RobotRaconteur::WrappedNamedArrayMemoryDirector *GetNamedArrayMemory(std::string const &name);
    virtual RobotRaconteur::WrappedNamedMultiDimArrayMemoryDirector *GetNamedMultiDimArrayMemory(std::string const &name);
    virtual void MonitorEnter(int32_t timeout);
    virtual void MonitorExit();
    virtual void ReleaseCastObject();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedServiceSkelDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_ServerServiceListenerDirector : public ServerServiceListenerDirector, public Swig::Director {

public:
    SwigDirector_ServerServiceListenerDirector(PyObject *self);
    virtual void Callback(int32_t code,uint32_t endpoint);
    virtual ~SwigDirector_ServerServiceListenerDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ServerServiceListenerDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedUserAuthenticatorDirector : public RobotRaconteur::WrappedUserAuthenticatorDirector, public Swig::Director {

public:
    SwigDirector_WrappedUserAuthenticatorDirector(PyObject *self);
    virtual ~SwigDirector_WrappedUserAuthenticatorDirector();
    virtual boost::shared_ptr< RobotRaconteur::AuthenticatedUser > AuthenticateUser(std::string const &username,boost::intrusive_ptr< RobotRaconteur::MessageElement > credentials,boost::shared_ptr< RobotRaconteur::ServerContext > const &context);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedUserAuthenticatorDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncServiceInfo2VectorReturnDirector : public RobotRaconteur::AsyncServiceInfo2VectorReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncServiceInfo2VectorReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncServiceInfo2VectorReturnDirector();
    virtual void handler(std::vector< RobotRaconteur::ServiceInfo2Wrapped,std::allocator< RobotRaconteur::ServiceInfo2Wrapped > > const &ret);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncServiceInfo2VectorReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_AsyncNodeInfo2VectorReturnDirector : public RobotRaconteur::AsyncNodeInfo2VectorReturnDirector, public Swig::Director {

public:
    SwigDirector_AsyncNodeInfo2VectorReturnDirector(PyObject *self);
    virtual ~SwigDirector_AsyncNodeInfo2VectorReturnDirector();
    virtual void handler(std::vector< RobotRaconteur::NodeInfo2,std::allocator< RobotRaconteur::NodeInfo2 > > const &ret);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AsyncNodeInfo2VectorReturnDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedServiceSubscriptionFilterPredicateDirector : public RobotRaconteur::WrappedServiceSubscriptionFilterPredicateDirector, public Swig::Director {

public:
    SwigDirector_WrappedServiceSubscriptionFilterPredicateDirector(PyObject *self);
    virtual bool Predicate(RobotRaconteur::ServiceInfo2Wrapped const &info);
    virtual ~SwigDirector_WrappedServiceSubscriptionFilterPredicateDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedServiceSubscriptionFilterPredicateDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedServiceInfo2SubscriptionDirector : public RobotRaconteur::WrappedServiceInfo2SubscriptionDirector, public Swig::Director {

public:
    SwigDirector_WrappedServiceInfo2SubscriptionDirector(PyObject *self);
    virtual void ServiceDetected(boost::shared_ptr< RobotRaconteur::WrappedServiceInfo2Subscription > const &subscription,RobotRaconteur::ServiceSubscriptionClientID const &id,RobotRaconteur::ServiceInfo2Wrapped const &service);
    virtual void ServiceLost(boost::shared_ptr< RobotRaconteur::WrappedServiceInfo2Subscription > const &subscription,RobotRaconteur::ServiceSubscriptionClientID const &id,RobotRaconteur::ServiceInfo2Wrapped const &service);
    virtual ~SwigDirector_WrappedServiceInfo2SubscriptionDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedServiceInfo2SubscriptionDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_WrappedServiceSubscriptionDirector : public RobotRaconteur::WrappedServiceSubscriptionDirector, public Swig::Director {

public:
    SwigDirector_WrappedServiceSubscriptionDirector(PyObject *self);
    virtual void ClientConnected(boost::shared_ptr< RobotRaconteur::WrappedServiceSubscription > const &subscription,RobotRaconteur::ServiceSubscriptionClientID const &id,boost::shared_ptr< RobotRaconteur::WrappedServiceStub > const &slient);
    virtual void ClientDisconnected(boost::shared_ptr< RobotRaconteur::WrappedServiceSubscription > const &subscription,RobotRaconteur::ServiceSubscriptionClientID const &id,boost::shared_ptr< RobotRaconteur::WrappedServiceStub > const &slient);
    virtual void ClientConnectFailed(boost::shared_ptr< RobotRaconteur::WrappedServiceSubscription > const &subscription,RobotRaconteur::ServiceSubscriptionClientID const &id,std::vector< std::string,std::allocator< std::string > > const &url,RobotRaconteur::HandlerErrorInfo &error);
    virtual ~SwigDirector_WrappedServiceSubscriptionDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedServiceSubscriptionDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_WrappedWireSubscriptionDirector : public RobotRaconteur::WrappedWireSubscriptionDirector, public Swig::Director {

public:
    SwigDirector_WrappedWireSubscriptionDirector(PyObject *self);
    virtual void WireValueChanged(boost::shared_ptr< RobotRaconteur::WrappedWireSubscription > const &wire_subscription,RobotRaconteur::WrappedService_typed_packet &value,RobotRaconteur::TimeSpec const &time);
    virtual ~SwigDirector_WrappedWireSubscriptionDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedWireSubscriptionDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_WrappedPipeSubscriptionDirector : public RobotRaconteur::WrappedPipeSubscriptionDirector, public Swig::Director {

public:
    SwigDirector_WrappedPipeSubscriptionDirector(PyObject *self);
    virtual void PipePacketReceived(boost::shared_ptr< RobotRaconteur::WrappedPipeSubscription > const &pipe_subscription);
    virtual ~SwigDirector_WrappedPipeSubscriptionDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class WrappedPipeSubscriptionDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_UserLogRecordHandlerDirector : public RobotRaconteur::UserLogRecordHandlerDirector, public Swig::Director {

public:
    SwigDirector_UserLogRecordHandlerDirector(PyObject *self);
    virtual void HandleLogRecord(RobotRaconteur::RRLogRecord const &record);
    virtual ~SwigDirector_UserLogRecordHandlerDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class UserLogRecordHandlerDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_ClientServiceListenerDirector : public ClientServiceListenerDirector, public Swig::Director {

public:
    SwigDirector_ClientServiceListenerDirector(PyObject *self);
    virtual void Callback(int32_t code);
    virtual void Callback2(int32_t code,std::string const &p);
    virtual ~SwigDirector_ClientServiceListenerDirector();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ClientServiceListenerDirector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


#endif
