# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from __future__ import absolute_import
from . import classproperty



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _RobotRaconteurPython
else:
    import _RobotRaconteurPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _RobotRaconteurPython.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_SwigPyIterator

    def value(self):
        return _RobotRaconteurPython.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _RobotRaconteurPython.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _RobotRaconteurPython.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _RobotRaconteurPython.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _RobotRaconteurPython.SwigPyIterator_equal(self, x)

    def copy(self):
        return _RobotRaconteurPython.SwigPyIterator_copy(self)

    def next(self):
        return _RobotRaconteurPython.SwigPyIterator_next(self)

    def __next__(self):
        return _RobotRaconteurPython.SwigPyIterator___next__(self)

    def previous(self):
        return _RobotRaconteurPython.SwigPyIterator_previous(self)

    def advance(self, n):
        return _RobotRaconteurPython.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _RobotRaconteurPython.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _RobotRaconteurPython.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _RobotRaconteurPython.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _RobotRaconteurPython.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _RobotRaconteurPython.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _RobotRaconteurPython.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _RobotRaconteurPython:
_RobotRaconteurPython.SwigPyIterator_swigregister(SwigPyIterator)

class FilesystemPath(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, s):
        _RobotRaconteurPython.FilesystemPath_swiginit(self, _RobotRaconteurPython.new_FilesystemPath(s))

    def string(self):
        return _RobotRaconteurPython.FilesystemPath_string(self)

    def __str__(self):
        return self.string()

    __swig_destroy__ = _RobotRaconteurPython.delete_FilesystemPath

# Register FilesystemPath in _RobotRaconteurPython:
_RobotRaconteurPython.FilesystemPath_swigregister(FilesystemPath)

DataTypes_void_t = _RobotRaconteurPython.DataTypes_void_t
r"""void or null type"""
DataTypes_double_t = _RobotRaconteurPython.DataTypes_double_t
r"""IEEE-754 64-bit floating point number"""
DataTypes_single_t = _RobotRaconteurPython.DataTypes_single_t
r"""IEEE-754 32-bit floating point number"""
DataTypes_int8_t = _RobotRaconteurPython.DataTypes_int8_t
r"""8-bit signed integer"""
DataTypes_uint8_t = _RobotRaconteurPython.DataTypes_uint8_t
r"""8-bit unsigned integer"""
DataTypes_int16_t = _RobotRaconteurPython.DataTypes_int16_t
r"""16-bit signed integer"""
DataTypes_uint16_t = _RobotRaconteurPython.DataTypes_uint16_t
r"""16-bit unsigned integer"""
DataTypes_int32_t = _RobotRaconteurPython.DataTypes_int32_t
r"""32-bit signed integer"""
DataTypes_uint32_t = _RobotRaconteurPython.DataTypes_uint32_t
r"""32-bit unsigned integer"""
DataTypes_int64_t = _RobotRaconteurPython.DataTypes_int64_t
r"""64-bit signed integer"""
DataTypes_uint64_t = _RobotRaconteurPython.DataTypes_uint64_t
r"""64-bit unsigned integer"""
DataTypes_string_t = _RobotRaconteurPython.DataTypes_string_t
r"""UTF-8 string"""
DataTypes_cdouble_t = _RobotRaconteurPython.DataTypes_cdouble_t
r"""128-bit complex double (real,imag)"""
DataTypes_csingle_t = _RobotRaconteurPython.DataTypes_csingle_t
r"""64-bit complex float (real,imag)"""
DataTypes_bool_t = _RobotRaconteurPython.DataTypes_bool_t
r"""8-bit boolean"""
DataTypes_structure_t = _RobotRaconteurPython.DataTypes_structure_t
r"""structure (nested message type)"""
DataTypes_vector_t = _RobotRaconteurPython.DataTypes_vector_t
r"""map with int32 key (nested message type)"""
DataTypes_dictionary_t = _RobotRaconteurPython.DataTypes_dictionary_t
r"""map with string key (nested message type)"""
DataTypes_object_t = _RobotRaconteurPython.DataTypes_object_t
r"""object type (not serializable)"""
DataTypes_varvalue_t = _RobotRaconteurPython.DataTypes_varvalue_t
r"""varvalue type (not serializable)"""
DataTypes_varobject_t = _RobotRaconteurPython.DataTypes_varobject_t
r"""varobject type (not serializable)"""
DataTypes_list_t = _RobotRaconteurPython.DataTypes_list_t
r"""list type (nested message type)"""
DataTypes_pod_t = _RobotRaconteurPython.DataTypes_pod_t
r"""pod type (nested message type)"""
DataTypes_pod_array_t = _RobotRaconteurPython.DataTypes_pod_array_t
r"""pod array type (nested message type)"""
DataTypes_pod_multidimarray_t = _RobotRaconteurPython.DataTypes_pod_multidimarray_t
r"""pod multidimarray type (nested message type)"""
DataTypes_enum_t = _RobotRaconteurPython.DataTypes_enum_t
r"""enum type (not serializable uses int32 for messages)"""
DataTypes_namedtype_t = _RobotRaconteurPython.DataTypes_namedtype_t
r"""namedtype definition (not serializable)"""
DataTypes_namedarray_t = _RobotRaconteurPython.DataTypes_namedarray_t
r"""namedarray type (not serializable)"""
DataTypes_namedarray_array_t = _RobotRaconteurPython.DataTypes_namedarray_array_t
r"""namedarray array type (nested message type)"""
DataTypes_namedarray_multidimarray_t = _RobotRaconteurPython.DataTypes_namedarray_multidimarray_t
r"""namedarray multidimarray type (nested message type)"""
DataTypes_multidimarray_t = _RobotRaconteurPython.DataTypes_multidimarray_t
r"""multi-dimensional numeric array (nested message type)"""
DataTypes_ArrayTypes_none = _RobotRaconteurPython.DataTypes_ArrayTypes_none
r"""type is not an array"""
DataTypes_ArrayTypes_array = _RobotRaconteurPython.DataTypes_ArrayTypes_array
r"""type is a single dimensional array"""
DataTypes_ArrayTypes_multidimarray = _RobotRaconteurPython.DataTypes_ArrayTypes_multidimarray
r"""type is a multidimensional array"""
DataTypes_ContainerTypes_none = _RobotRaconteurPython.DataTypes_ContainerTypes_none
r"""type does not have a container"""
DataTypes_ContainerTypes_list = _RobotRaconteurPython.DataTypes_ContainerTypes_list
r"""type has a list container"""
DataTypes_ContainerTypes_map_int32 = _RobotRaconteurPython.DataTypes_ContainerTypes_map_int32
r"""type has a map with int32 keys container"""
DataTypes_ContainerTypes_map_string = _RobotRaconteurPython.DataTypes_ContainerTypes_map_string
r"""type has a map with string keys container"""
DataTypes_ContainerTypes_generator = _RobotRaconteurPython.DataTypes_ContainerTypes_generator
r"""type has a generator container. Only valid for use with function generator members"""
MessageEntryType_Null = _RobotRaconteurPython.MessageEntryType_Null
r"""no-op"""
MessageEntryType_StreamOp = _RobotRaconteurPython.MessageEntryType_StreamOp
r"""Stream operation request (transport only)"""
MessageEntryType_StreamOpRet = _RobotRaconteurPython.MessageEntryType_StreamOpRet
r"""Stream operation response (transport only)"""
MessageEntryType_StreamCheckCapability = _RobotRaconteurPython.MessageEntryType_StreamCheckCapability
r"""Stream check capability request (transport only)"""
MessageEntryType_StreamCheckCapabilityRet = _RobotRaconteurPython.MessageEntryType_StreamCheckCapabilityRet
r"""Stream check capability response (transport only)"""
MessageEntryType_GetServiceDesc = _RobotRaconteurPython.MessageEntryType_GetServiceDesc
r"""Get service definition request"""
MessageEntryType_GetServiceDescRet = _RobotRaconteurPython.MessageEntryType_GetServiceDescRet
r"""Get service definition response"""
MessageEntryType_ObjectTypeName = _RobotRaconteurPython.MessageEntryType_ObjectTypeName
r"""Get object qualified type name request"""
MessageEntryType_ObjectTypeNameRet = _RobotRaconteurPython.MessageEntryType_ObjectTypeNameRet
r"""Get object qualified type name response"""
MessageEntryType_ServiceClosed = _RobotRaconteurPython.MessageEntryType_ServiceClosed
r"""Service closed notification packet"""
MessageEntryType_ServiceClosedRet = _RobotRaconteurPython.MessageEntryType_ServiceClosedRet
r"""(reserved)"""
MessageEntryType_ConnectClient = _RobotRaconteurPython.MessageEntryType_ConnectClient
r"""Connect client request"""
MessageEntryType_ConnectClientRet = _RobotRaconteurPython.MessageEntryType_ConnectClientRet
r"""Connect client response"""
MessageEntryType_DisconnectClient = _RobotRaconteurPython.MessageEntryType_DisconnectClient
r"""Disconnect client request"""
MessageEntryType_DisconnectClientRet = _RobotRaconteurPython.MessageEntryType_DisconnectClientRet
r"""Disconnect client response"""
MessageEntryType_ConnectionTest = _RobotRaconteurPython.MessageEntryType_ConnectionTest
r"""Ping request"""
MessageEntryType_ConnectionTestRet = _RobotRaconteurPython.MessageEntryType_ConnectionTestRet
r"""Pong response"""
MessageEntryType_GetNodeInfo = _RobotRaconteurPython.MessageEntryType_GetNodeInfo
r"""Get node information request (NodeID and NodeName)"""
MessageEntryType_GetNodeInfoRet = _RobotRaconteurPython.MessageEntryType_GetNodeInfoRet
r"""Get node information response"""
MessageEntryType_ReconnectClient = _RobotRaconteurPython.MessageEntryType_ReconnectClient
r"""(reserved)"""
MessageEntryType_ReconnectClientRet = _RobotRaconteurPython.MessageEntryType_ReconnectClientRet
r"""(reserved)"""
MessageEntryType_NodeCheckCapability = _RobotRaconteurPython.MessageEntryType_NodeCheckCapability
r"""Get node capability request"""
MessageEntryType_NodeCheckCapabilityRet = _RobotRaconteurPython.MessageEntryType_NodeCheckCapabilityRet
r"""Get node capability response"""
MessageEntryType_GetServiceAttributes = _RobotRaconteurPython.MessageEntryType_GetServiceAttributes
r"""Get service attributes request"""
MessageEntryType_GetServiceAttributesRet = _RobotRaconteurPython.MessageEntryType_GetServiceAttributesRet
r"""Get service attributes response"""
MessageEntryType_ConnectClientCombined = _RobotRaconteurPython.MessageEntryType_ConnectClientCombined
r"""Connect client combined operation request"""
MessageEntryType_ConnectClientCombinedRet = _RobotRaconteurPython.MessageEntryType_ConnectClientCombinedRet
r"""Connect client combined operation response"""
MessageEntryType_EndpointCheckCapability = _RobotRaconteurPython.MessageEntryType_EndpointCheckCapability
r"""Get endpoint capability request"""
MessageEntryType_EndpointCheckCapabilityRet = _RobotRaconteurPython.MessageEntryType_EndpointCheckCapabilityRet
r"""Get endpoint capabalitiy response"""
MessageEntryType_ServiceCheckCapabilityReq = _RobotRaconteurPython.MessageEntryType_ServiceCheckCapabilityReq
r"""Get service capability request"""
MessageEntryType_ServiceCheckCapabilityRet = _RobotRaconteurPython.MessageEntryType_ServiceCheckCapabilityRet
r"""Get service capability response"""
MessageEntryType_ClientKeepAliveReq = _RobotRaconteurPython.MessageEntryType_ClientKeepAliveReq
r"""Client keep alive request"""
MessageEntryType_ClientKeepAliveRet = _RobotRaconteurPython.MessageEntryType_ClientKeepAliveRet
r"""Client keep alive response"""
MessageEntryType_ClientSessionOpReq = _RobotRaconteurPython.MessageEntryType_ClientSessionOpReq
r"""Client session management operation request"""
MessageEntryType_ClientSessionOpRet = _RobotRaconteurPython.MessageEntryType_ClientSessionOpRet
r"""Client session management operation response"""
MessageEntryType_ServicePathReleasedReq = _RobotRaconteurPython.MessageEntryType_ServicePathReleasedReq
r"""Service path released event notification packet"""
MessageEntryType_ServicePathReleasedRet = _RobotRaconteurPython.MessageEntryType_ServicePathReleasedRet
r"""(reserved)"""
MessageEntryType_PropertyGetReq = _RobotRaconteurPython.MessageEntryType_PropertyGetReq
r"""Property member get request"""
MessageEntryType_PropertyGetRes = _RobotRaconteurPython.MessageEntryType_PropertyGetRes
r"""Property member get response"""
MessageEntryType_PropertySetReq = _RobotRaconteurPython.MessageEntryType_PropertySetReq
r"""Property member set request"""
MessageEntryType_PropertySetRes = _RobotRaconteurPython.MessageEntryType_PropertySetRes
r"""Property member set response"""
MessageEntryType_FunctionCallReq = _RobotRaconteurPython.MessageEntryType_FunctionCallReq
r"""Function member call request"""
MessageEntryType_FunctionCallRes = _RobotRaconteurPython.MessageEntryType_FunctionCallRes
r"""Function member call response"""
MessageEntryType_GeneratorNextReq = _RobotRaconteurPython.MessageEntryType_GeneratorNextReq
r"""Generater next call request"""
MessageEntryType_GeneratorNextRes = _RobotRaconteurPython.MessageEntryType_GeneratorNextRes
r"""Generater next call response"""
MessageEntryType_EventReq = _RobotRaconteurPython.MessageEntryType_EventReq
r"""Event member notification"""
MessageEntryType_EventRes = _RobotRaconteurPython.MessageEntryType_EventRes
r"""(reserved)"""
MessageEntryType_PipePacket = _RobotRaconteurPython.MessageEntryType_PipePacket
r"""Pipe member packet"""
MessageEntryType_PipePacketRet = _RobotRaconteurPython.MessageEntryType_PipePacketRet
r"""Pipe member packet ack"""
MessageEntryType_PipeConnectReq = _RobotRaconteurPython.MessageEntryType_PipeConnectReq
r"""Pipe member connect request"""
MessageEntryType_PipeConnectRet = _RobotRaconteurPython.MessageEntryType_PipeConnectRet
r"""Pipe member connect response"""
MessageEntryType_PipeDisconnectReq = _RobotRaconteurPython.MessageEntryType_PipeDisconnectReq
r"""Pipe member close request"""
MessageEntryType_PipeDisconnectRet = _RobotRaconteurPython.MessageEntryType_PipeDisconnectRet
r"""Pipe member close response"""
MessageEntryType_PipeClosed = _RobotRaconteurPython.MessageEntryType_PipeClosed
r"""Pipe member closed event notification packet"""
MessageEntryType_PipeClosedRet = _RobotRaconteurPython.MessageEntryType_PipeClosedRet
r"""(reserved)"""
MessageEntryType_CallbackCallReq = _RobotRaconteurPython.MessageEntryType_CallbackCallReq
r"""Callback member call request"""
MessageEntryType_CallbackCallRet = _RobotRaconteurPython.MessageEntryType_CallbackCallRet
r"""Callback member call response"""
MessageEntryType_WirePacket = _RobotRaconteurPython.MessageEntryType_WirePacket
r"""Wire member value packet"""
MessageEntryType_WirePacketRet = _RobotRaconteurPython.MessageEntryType_WirePacketRet
r"""(reserved)"""
MessageEntryType_WireConnectReq = _RobotRaconteurPython.MessageEntryType_WireConnectReq
r"""Wire member connect request"""
MessageEntryType_WireConnectRet = _RobotRaconteurPython.MessageEntryType_WireConnectRet
r"""Wire member connect response"""
MessageEntryType_WireDisconnectReq = _RobotRaconteurPython.MessageEntryType_WireDisconnectReq
r"""Wire member close request"""
MessageEntryType_WireDisconnectRet = _RobotRaconteurPython.MessageEntryType_WireDisconnectRet
r"""Wire member close response"""
MessageEntryType_WireClosed = _RobotRaconteurPython.MessageEntryType_WireClosed
r"""Wire member closed event notification packet"""
MessageEntryType_WireClosedRet = _RobotRaconteurPython.MessageEntryType_WireClosedRet
r"""(reserved)"""
MessageEntryType_MemoryRead = _RobotRaconteurPython.MessageEntryType_MemoryRead
r"""Memory member read request"""
MessageEntryType_MemoryReadRet = _RobotRaconteurPython.MessageEntryType_MemoryReadRet
r"""Memory member read response"""
MessageEntryType_MemoryWrite = _RobotRaconteurPython.MessageEntryType_MemoryWrite
r"""Memory member write request"""
MessageEntryType_MemoryWriteRet = _RobotRaconteurPython.MessageEntryType_MemoryWriteRet
r"""Memory member write response"""
MessageEntryType_MemoryGetParam = _RobotRaconteurPython.MessageEntryType_MemoryGetParam
r"""Memory member get param request"""
MessageEntryType_MemoryGetParamRet = _RobotRaconteurPython.MessageEntryType_MemoryGetParamRet
r"""Memory member get param response"""
MessageEntryType_WirePeekInValueReq = _RobotRaconteurPython.MessageEntryType_WirePeekInValueReq
r"""Wire member peek InValue request"""
MessageEntryType_WirePeekInValueRet = _RobotRaconteurPython.MessageEntryType_WirePeekInValueRet
r"""Wire member peek InValue response"""
MessageEntryType_WirePeekOutValueReq = _RobotRaconteurPython.MessageEntryType_WirePeekOutValueReq
r"""Wire member peek OutValue request"""
MessageEntryType_WirePeekOutValueRet = _RobotRaconteurPython.MessageEntryType_WirePeekOutValueRet
r"""Wire member peek OutValue response"""
MessageEntryType_WirePokeOutValueReq = _RobotRaconteurPython.MessageEntryType_WirePokeOutValueReq
r"""Wire member poke OutValue request"""
MessageEntryType_WirePokeOutValueRet = _RobotRaconteurPython.MessageEntryType_WirePokeOutValueRet
r"""Wire member poke OutValue response"""
MessageEntryType_WireTransportOpReq = _RobotRaconteurPython.MessageEntryType_WireTransportOpReq
MessageEntryType_WireTransportOpRet = _RobotRaconteurPython.MessageEntryType_WireTransportOpRet
MessageEntryType_WireTransportEvent = _RobotRaconteurPython.MessageEntryType_WireTransportEvent
MessageEntryType_WireTransportEventRet = _RobotRaconteurPython.MessageEntryType_WireTransportEventRet
MessageErrorType_None = _RobotRaconteurPython.MessageErrorType_None
r"""success"""
MessageErrorType_ConnectionError = _RobotRaconteurPython.MessageErrorType_ConnectionError
r"""connection error"""
MessageErrorType_ProtocolError = _RobotRaconteurPython.MessageErrorType_ProtocolError
r"""protocol error serializing messages"""
MessageErrorType_ServiceNotFound = _RobotRaconteurPython.MessageErrorType_ServiceNotFound
r"""specified service not found"""
MessageErrorType_ObjectNotFound = _RobotRaconteurPython.MessageErrorType_ObjectNotFound
r"""specified object not found"""
MessageErrorType_InvalidEndpoint = _RobotRaconteurPython.MessageErrorType_InvalidEndpoint
r"""specified endpoint not found"""
MessageErrorType_EndpointCommunicationFatalError = _RobotRaconteurPython.MessageErrorType_EndpointCommunicationFatalError
r"""communication with specified endpoint failed"""
MessageErrorType_NodeNotFound = _RobotRaconteurPython.MessageErrorType_NodeNotFound
r"""specified node not found"""
MessageErrorType_ServiceError = _RobotRaconteurPython.MessageErrorType_ServiceError
r"""service error"""
MessageErrorType_MemberNotFound = _RobotRaconteurPython.MessageErrorType_MemberNotFound
r"""specified member not found"""
MessageErrorType_MemberFormatMismatch = _RobotRaconteurPython.MessageErrorType_MemberFormatMismatch
r"""message format incompatible with specified member"""
MessageErrorType_DataTypeMismatch = _RobotRaconteurPython.MessageErrorType_DataTypeMismatch
r"""data type did not match expected type"""
MessageErrorType_DataTypeError = _RobotRaconteurPython.MessageErrorType_DataTypeError
r"""data type failure"""
MessageErrorType_DataSerializationError = _RobotRaconteurPython.MessageErrorType_DataSerializationError
r"""failure serializing data type"""
MessageErrorType_MessageEntryNotFound = _RobotRaconteurPython.MessageErrorType_MessageEntryNotFound
r"""specified message entry not found"""
MessageErrorType_MessageElementNotFound = _RobotRaconteurPython.MessageErrorType_MessageElementNotFound
r"""specified message element not found"""
MessageErrorType_UnknownError = _RobotRaconteurPython.MessageErrorType_UnknownError
r"""unknown exception occurred check `error name`"""
MessageErrorType_InvalidOperation = _RobotRaconteurPython.MessageErrorType_InvalidOperation
r"""invalid operation attempted"""
MessageErrorType_InvalidArgument = _RobotRaconteurPython.MessageErrorType_InvalidArgument
r"""argument is invalid"""
MessageErrorType_OperationFailed = _RobotRaconteurPython.MessageErrorType_OperationFailed
r"""the requested operation failed"""
MessageErrorType_NullValue = _RobotRaconteurPython.MessageErrorType_NullValue
r"""invalid null value"""
MessageErrorType_InternalError = _RobotRaconteurPython.MessageErrorType_InternalError
r"""internal error"""
MessageErrorType_SystemResourcePermissionDenied = _RobotRaconteurPython.MessageErrorType_SystemResourcePermissionDenied
r"""permission denied to a system resource"""
MessageErrorType_OutOfSystemResource = _RobotRaconteurPython.MessageErrorType_OutOfSystemResource
r"""system resource has been exhausted"""
MessageErrorType_SystemResourceError = _RobotRaconteurPython.MessageErrorType_SystemResourceError
r"""system resource error"""
MessageErrorType_ResourceNotFound = _RobotRaconteurPython.MessageErrorType_ResourceNotFound
r"""a required resource was not found"""
MessageErrorType_IOError = _RobotRaconteurPython.MessageErrorType_IOError
r"""input/output error"""
MessageErrorType_BufferLimitViolation = _RobotRaconteurPython.MessageErrorType_BufferLimitViolation
r"""a buffer underrun/overrun has occurred"""
MessageErrorType_ServiceDefinitionError = _RobotRaconteurPython.MessageErrorType_ServiceDefinitionError
r"""service definition parse or validation error"""
MessageErrorType_OutOfRange = _RobotRaconteurPython.MessageErrorType_OutOfRange
r"""attempt to access an out of range element"""
MessageErrorType_KeyNotFound = _RobotRaconteurPython.MessageErrorType_KeyNotFound
r"""key not found"""
MessageErrorType_InvalidConfiguration = _RobotRaconteurPython.MessageErrorType_InvalidConfiguration
r"""invalid configuration specified"""
MessageErrorType_InvalidState = _RobotRaconteurPython.MessageErrorType_InvalidState
r"""invalid state"""
MessageErrorType_RemoteError = _RobotRaconteurPython.MessageErrorType_RemoteError
r"""error occurred on remote node"""
MessageErrorType_RequestTimeout = _RobotRaconteurPython.MessageErrorType_RequestTimeout
r"""request timed out"""
MessageErrorType_ReadOnlyMember = _RobotRaconteurPython.MessageErrorType_ReadOnlyMember
r"""attempt to write to a read only member"""
MessageErrorType_WriteOnlyMember = _RobotRaconteurPython.MessageErrorType_WriteOnlyMember
r"""attempt to read a write only member"""
MessageErrorType_NotImplementedError = _RobotRaconteurPython.MessageErrorType_NotImplementedError
r"""member not implemented"""
MessageErrorType_MemberBusy = _RobotRaconteurPython.MessageErrorType_MemberBusy
r"""member is busy try again"""
MessageErrorType_ValueNotSet = _RobotRaconteurPython.MessageErrorType_ValueNotSet
r"""value has not been set"""
MessageErrorType_AbortOperation = _RobotRaconteurPython.MessageErrorType_AbortOperation
r"""abort operation (generator only)"""
MessageErrorType_OperationAborted = _RobotRaconteurPython.MessageErrorType_OperationAborted
r"""the operation has been aborted"""
MessageErrorType_StopIteration = _RobotRaconteurPython.MessageErrorType_StopIteration
r"""stop generator iteration (generator only)"""
MessageErrorType_OperationTimeout = _RobotRaconteurPython.MessageErrorType_OperationTimeout
r"""the operation has timed out"""
MessageErrorType_OperationCancelled = _RobotRaconteurPython.MessageErrorType_OperationCancelled
r"""the operation has been cancelled"""
MessageErrorType_AuthenticationError = _RobotRaconteurPython.MessageErrorType_AuthenticationError
r"""authentication has failed"""
MessageErrorType_ObjectLockedError = _RobotRaconteurPython.MessageErrorType_ObjectLockedError
r"""the object is locked by another user or session"""
MessageErrorType_PermissionDenied = _RobotRaconteurPython.MessageErrorType_PermissionDenied
r"""permission to service object or resource denied"""
ClientServiceListenerEventType_ClientClosed = _RobotRaconteurPython.ClientServiceListenerEventType_ClientClosed
r"""client has been closed"""
ClientServiceListenerEventType_ClientConnectionTimeout = _RobotRaconteurPython.ClientServiceListenerEventType_ClientConnectionTimeout
r"""client connection has timed out"""
ClientServiceListenerEventType_TransportConnectionConnected = _RobotRaconteurPython.ClientServiceListenerEventType_TransportConnectionConnected
r"""client transport has been connected"""
ClientServiceListenerEventType_TransportConnectionClosed = _RobotRaconteurPython.ClientServiceListenerEventType_TransportConnectionClosed
r"""client transport connection has been closed or lost"""
ClientServiceListenerEventType_ServicePathReleased = _RobotRaconteurPython.ClientServiceListenerEventType_ServicePathReleased
r"""client has received notification that service path was released"""
ServerServiceListenerEventType_ServiceClosed = _RobotRaconteurPython.ServerServiceListenerEventType_ServiceClosed
r"""service has been closed"""
ServerServiceListenerEventType_ClientConnected = _RobotRaconteurPython.ServerServiceListenerEventType_ClientConnected
r"""client has connected"""
ServerServiceListenerEventType_ClientDisconnected = _RobotRaconteurPython.ServerServiceListenerEventType_ClientDisconnected
r"""client has disconnected"""
MemberDefinition_Direction_both = _RobotRaconteurPython.MemberDefinition_Direction_both
r"""member supports read and write"""
MemberDefinition_Direction_readonly = _RobotRaconteurPython.MemberDefinition_Direction_readonly
r"""member is readonly"""
MemberDefinition_Direction_writeonly = _RobotRaconteurPython.MemberDefinition_Direction_writeonly
r"""member is writeonly"""
MemberDefinition_NoLock_none = _RobotRaconteurPython.MemberDefinition_NoLock_none
r"""member cannot be accessed by other users/sessions when object is locked"""
MemberDefinition_NoLock_all = _RobotRaconteurPython.MemberDefinition_NoLock_all
r"""member can be accessed by other users/sessions when object is locked"""
MemberDefinition_NoLock_read = _RobotRaconteurPython.MemberDefinition_NoLock_read
r"""member can be read by other users/sessions when object is locked"""
RR_TIMEOUT_INFINITE = _RobotRaconteurPython.RR_TIMEOUT_INFINITE
r"""Disable timeout for asynchronous operations"""
RR_VALUE_LIFESPAN_INFINITE = _RobotRaconteurPython.RR_VALUE_LIFESPAN_INFINITE
r"""Set wire values to have infinite lifespan and will not expire"""
LogLevel_Trace = _RobotRaconteurPython.LogLevel_Trace
r"""`trace` log level"""
LogLevel_Debug = _RobotRaconteurPython.LogLevel_Debug
r"""`debug` log level"""
LogLevel_Info = _RobotRaconteurPython.LogLevel_Info
r"""`info` log level"""
LogLevel_Warning = _RobotRaconteurPython.LogLevel_Warning
r"""`warning` log level"""
LogLevel_Error = _RobotRaconteurPython.LogLevel_Error
r"""`error` log level"""
LogLevel_Fatal = _RobotRaconteurPython.LogLevel_Fatal
r"""`fatal` log level"""
LogLevel_Disable = _RobotRaconteurPython.LogLevel_Disable
r"""`disabled` log level"""
LogComponent_Default = _RobotRaconteurPython.LogComponent_Default
r"""default component"""
LogComponent_Node = _RobotRaconteurPython.LogComponent_Node
r"""Robot Raconteur Node component"""
LogComponent_Transport = _RobotRaconteurPython.LogComponent_Transport
r"""tranport component"""
LogComponent_Message = _RobotRaconteurPython.LogComponent_Message
r"""message or message serialization component"""
LogComponent_Client = _RobotRaconteurPython.LogComponent_Client
r"""client component"""
LogComponent_Service = _RobotRaconteurPython.LogComponent_Service
r"""service component"""
LogComponent_Member = _RobotRaconteurPython.LogComponent_Member
r"""member component"""
LogComponent_Pack = _RobotRaconteurPython.LogComponent_Pack
r"""data message packing component"""
LogComponent_Unpack = _RobotRaconteurPython.LogComponent_Unpack
r"""data message unpacknig component"""
LogComponent_ServiceDefinition = _RobotRaconteurPython.LogComponent_ServiceDefinition
r"""service definition parser component"""
LogComponent_Discovery = _RobotRaconteurPython.LogComponent_Discovery
r"""node/service discovery component"""
LogComponent_Subscription = _RobotRaconteurPython.LogComponent_Subscription
r"""subscription component"""
LogComponent_NodeSetup = _RobotRaconteurPython.LogComponent_NodeSetup
r"""node setup component"""
LogComponent_Utility = _RobotRaconteurPython.LogComponent_Utility
r"""utility component"""
LogComponent_RobDefLib = _RobotRaconteurPython.LogComponent_RobDefLib
r"""service definition standard library component (external)"""
LogComponent_User = _RobotRaconteurPython.LogComponent_User
r"""user component (external)"""
LogComponent_UserClient = _RobotRaconteurPython.LogComponent_UserClient
r"""user client component (external)"""
LogComponent_UserService = _RobotRaconteurPython.LogComponent_UserService
r"""user service component (external)"""
LogComponent_ThirdParty = _RobotRaconteurPython.LogComponent_ThirdParty
r"""third party library component (external)"""
class vectorstring(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorstring_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorstring___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorstring___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorstring___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorstring___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorstring___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorstring___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorstring___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorstring___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorstring___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorstring_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorstring_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorstring_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorstring_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorstring_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorstring_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorstring_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorstring_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorstring_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorstring_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorstring_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorstring_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorstring_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorstring_swiginit(self, _RobotRaconteurPython.new_vectorstring(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorstring_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorstring_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorstring_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorstring_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorstring_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorstring_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorstring_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorstring_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorstring

# Register vectorstring in _RobotRaconteurPython:
_RobotRaconteurPython.vectorstring_swigregister(vectorstring)
cvar = _RobotRaconteurPython.cvar
MessageFlags_ROUTING_INFO = cvar.MessageFlags_ROUTING_INFO
MessageFlags_ENDPOINT_INFO = cvar.MessageFlags_ENDPOINT_INFO
MessageFlags_PRIORITY = cvar.MessageFlags_PRIORITY
MessageFlags_UNRELIABLE = cvar.MessageFlags_UNRELIABLE
MessageFlags_META_INFO = cvar.MessageFlags_META_INFO
MessageFlags_STRING_TABLE = cvar.MessageFlags_STRING_TABLE
MessageFlags_MULTIPLE_ENTRIES = cvar.MessageFlags_MULTIPLE_ENTRIES
MessageFlags_EXTENDED = cvar.MessageFlags_EXTENDED
MessageFlags_Version2Compat = cvar.MessageFlags_Version2Compat
MessageEntryFlags_SERVICE_PATH_STR = cvar.MessageEntryFlags_SERVICE_PATH_STR
MessageEntryFlags_SERVICE_PATH_CODE = cvar.MessageEntryFlags_SERVICE_PATH_CODE
MessageEntryFlags_MEMBER_NAME_STR = cvar.MessageEntryFlags_MEMBER_NAME_STR
MessageEntryFlags_MEMBER_NAME_CODE = cvar.MessageEntryFlags_MEMBER_NAME_CODE
MessageEntryFlags_REQUEST_ID = cvar.MessageEntryFlags_REQUEST_ID
MessageEntryFlags_ERROR = cvar.MessageEntryFlags_ERROR
MessageEntryFlags_META_INFO = cvar.MessageEntryFlags_META_INFO
MessageEntryFlags_EXTENDED = cvar.MessageEntryFlags_EXTENDED
MessageEntryFlags_Version2Compat = cvar.MessageEntryFlags_Version2Compat
MessageElementFlags_ELEMENT_NAME_STR = cvar.MessageElementFlags_ELEMENT_NAME_STR
MessageElementFlags_ELEMENT_NAME_CODE = cvar.MessageElementFlags_ELEMENT_NAME_CODE
MessageElementFlags_ELEMENT_NUMBER = cvar.MessageElementFlags_ELEMENT_NUMBER
MessageElementFlags_ELEMENT_TYPE_NAME_STR = cvar.MessageElementFlags_ELEMENT_TYPE_NAME_STR
MessageElementFlags_ELEMENT_TYPE_NAME_CODE = cvar.MessageElementFlags_ELEMENT_TYPE_NAME_CODE
MessageElementFlags_META_INFO = cvar.MessageElementFlags_META_INFO
MessageElementFlags_EXTENDED = cvar.MessageElementFlags_EXTENDED
MessageElementFlags_Version2Compat = cvar.MessageElementFlags_Version2Compat
TranspartCapabilityCode_PAGE_MASK = cvar.TranspartCapabilityCode_PAGE_MASK
TransportCapabilityCode_MESSAGE2_BASIC_PAGE = cvar.TransportCapabilityCode_MESSAGE2_BASIC_PAGE
TransportCapabilityCode_MESSAGE2_BASIC_ENABLE = cvar.TransportCapabilityCode_MESSAGE2_BASIC_ENABLE
TransportCapabilityCode_MESSAGE2_BASIC_CONNECTCOMBINED = cvar.TransportCapabilityCode_MESSAGE2_BASIC_CONNECTCOMBINED
TransportCapabilityCode_MESSAGE4_BASIC_PAGE = cvar.TransportCapabilityCode_MESSAGE4_BASIC_PAGE
TransportCapabilityCode_MESSAGE4_BASIC_ENABLE = cvar.TransportCapabilityCode_MESSAGE4_BASIC_ENABLE
TransportCapabilityCode_MESSAGE4_BASIC_CONNECTCOMBINED = cvar.TransportCapabilityCode_MESSAGE4_BASIC_CONNECTCOMBINED
TransportCapabilityCode_MESSAGE4_STRINGTABLE_PAGE = cvar.TransportCapabilityCode_MESSAGE4_STRINGTABLE_PAGE
TransportCapabilityCode_MESSAGE4_STRINGTABLE_ENABLE = cvar.TransportCapabilityCode_MESSAGE4_STRINGTABLE_ENABLE
TransportCapabilityCode_MESSAGE4_STRINGTABLE_MESSAGE_LOCAL = cvar.TransportCapabilityCode_MESSAGE4_STRINGTABLE_MESSAGE_LOCAL
TransportCapabilityCode_MESSAGE4_STRINGTABLE_STANDARD_TABLE = cvar.TransportCapabilityCode_MESSAGE4_STRINGTABLE_STANDARD_TABLE

class vectorint32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorint32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorint32___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorint32___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorint32___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorint32___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorint32___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorint32___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorint32___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorint32___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorint32___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorint32_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorint32_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorint32_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorint32_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorint32_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorint32_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorint32_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorint32_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorint32_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorint32_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorint32_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorint32_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorint32_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorint32_swiginit(self, _RobotRaconteurPython.new_vectorint32(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorint32_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorint32_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorint32_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorint32_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorint32_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorint32_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorint32_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorint32_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorint32

# Register vectorint32 in _RobotRaconteurPython:
_RobotRaconteurPython.vectorint32_swigregister(vectorint32)

class vectoruint32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectoruint32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectoruint32___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectoruint32___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectoruint32___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectoruint32___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectoruint32___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectoruint32___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectoruint32___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectoruint32___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectoruint32___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectoruint32_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectoruint32_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectoruint32_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectoruint32_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectoruint32_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectoruint32_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectoruint32_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectoruint32_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectoruint32_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectoruint32_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectoruint32_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectoruint32_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectoruint32_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectoruint32_swiginit(self, _RobotRaconteurPython.new_vectoruint32(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectoruint32_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectoruint32_front(self)

    def back(self):
        return _RobotRaconteurPython.vectoruint32_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectoruint32_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectoruint32_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectoruint32_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectoruint32_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectoruint32_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectoruint32

# Register vectoruint32 in _RobotRaconteurPython:
_RobotRaconteurPython.vectoruint32_swigregister(vectoruint32)

class vector_int8_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_int8_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_int8_t___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_int8_t___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_int8_t___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_int8_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_int8_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_int8_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_int8_t___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_int8_t___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_int8_t___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_int8_t_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_int8_t_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_int8_t_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_int8_t_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_int8_t_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_int8_t_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_int8_t_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_int8_t_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_int8_t_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_int8_t_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_int8_t_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_int8_t_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_int8_t_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_int8_t_swiginit(self, _RobotRaconteurPython.new_vector_int8_t(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_int8_t_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_int8_t_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_int8_t_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_int8_t_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_int8_t_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_int8_t_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_int8_t_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_int8_t_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_int8_t

# Register vector_int8_t in _RobotRaconteurPython:
_RobotRaconteurPython.vector_int8_t_swigregister(vector_int8_t)

class vector_uint8_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_uint8_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_uint8_t___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_uint8_t___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_uint8_t___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_uint8_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_uint8_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_uint8_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_uint8_t___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_uint8_t___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_uint8_t___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_uint8_t_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_uint8_t_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_uint8_t_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_uint8_t_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_uint8_t_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_uint8_t_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_uint8_t_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_uint8_t_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_uint8_t_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_uint8_t_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_uint8_t_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_uint8_t_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_uint8_t_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_uint8_t_swiginit(self, _RobotRaconteurPython.new_vector_uint8_t(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_uint8_t_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_uint8_t_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_uint8_t_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_uint8_t_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_uint8_t_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_uint8_t_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_uint8_t_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_uint8_t_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_uint8_t

# Register vector_uint8_t in _RobotRaconteurPython:
_RobotRaconteurPython.vector_uint8_t_swigregister(vector_uint8_t)

class vector_uint64_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_uint64_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_uint64_t___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_uint64_t___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_uint64_t___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_uint64_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_uint64_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_uint64_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_uint64_t___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_uint64_t___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_uint64_t___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_uint64_t_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_uint64_t_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_uint64_t_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_uint64_t_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_uint64_t_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_uint64_t_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_uint64_t_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_uint64_t_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_uint64_t_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_uint64_t_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_uint64_t_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_uint64_t_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_uint64_t_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_uint64_t_swiginit(self, _RobotRaconteurPython.new_vector_uint64_t(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_uint64_t_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_uint64_t_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_uint64_t_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_uint64_t_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_uint64_t_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_uint64_t_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_uint64_t_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_uint64_t_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_uint64_t

# Register vector_uint64_t in _RobotRaconteurPython:
_RobotRaconteurPython.vector_uint64_t_swigregister(vector_uint64_t)

class map_strstr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.map_strstr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.map_strstr___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.map_strstr___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.map_strstr___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _RobotRaconteurPython.map_strstr___getitem__(self, key)

    def __delitem__(self, key):
        return _RobotRaconteurPython.map_strstr___delitem__(self, key)

    def has_key(self, key):
        return _RobotRaconteurPython.map_strstr_has_key(self, key)

    def keys(self):
        return _RobotRaconteurPython.map_strstr_keys(self)

    def values(self):
        return _RobotRaconteurPython.map_strstr_values(self)

    def items(self):
        return _RobotRaconteurPython.map_strstr_items(self)

    def __contains__(self, key):
        return _RobotRaconteurPython.map_strstr___contains__(self, key)

    def key_iterator(self):
        return _RobotRaconteurPython.map_strstr_key_iterator(self)

    def value_iterator(self):
        return _RobotRaconteurPython.map_strstr_value_iterator(self)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.map_strstr___setitem__(self, *args)

    def asdict(self):
        return _RobotRaconteurPython.map_strstr_asdict(self)

    def __init__(self, *args):
        _RobotRaconteurPython.map_strstr_swiginit(self, _RobotRaconteurPython.new_map_strstr(*args))

    def empty(self):
        return _RobotRaconteurPython.map_strstr_empty(self)

    def size(self):
        return _RobotRaconteurPython.map_strstr_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.map_strstr_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.map_strstr_begin(self)

    def end(self):
        return _RobotRaconteurPython.map_strstr_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.map_strstr_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.map_strstr_rend(self)

    def clear(self):
        return _RobotRaconteurPython.map_strstr_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.map_strstr_get_allocator(self)

    def count(self, x):
        return _RobotRaconteurPython.map_strstr_count(self, x)

    def erase(self, *args):
        return _RobotRaconteurPython.map_strstr_erase(self, *args)

    def find(self, x):
        return _RobotRaconteurPython.map_strstr_find(self, x)

    def lower_bound(self, x):
        return _RobotRaconteurPython.map_strstr_lower_bound(self, x)

    def upper_bound(self, x):
        return _RobotRaconteurPython.map_strstr_upper_bound(self, x)
    __swig_destroy__ = _RobotRaconteurPython.delete_map_strstr

# Register map_strstr in _RobotRaconteurPython:
_RobotRaconteurPython.map_strstr_swigregister(map_strstr)


def GetRRDataTypeString(type):
    return _RobotRaconteurPython.GetRRDataTypeString(type)

def IsTypeRRArray(type):
    return _RobotRaconteurPython.IsTypeRRArray(type)

def IsTypeNumeric(type):
    return _RobotRaconteurPython.IsTypeNumeric(type)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class RRObject(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_RRObject

# Register RRObject in _RobotRaconteurPython:
_RobotRaconteurPython.RRObject_swigregister(RRObject)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class RRValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_RRValue

# Register RRValue in _RobotRaconteurPython:
_RobotRaconteurPython.RRValue_swigregister(RRValue)

class MessageElementData(RRValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetTypeString(self):
        return _RobotRaconteurPython.MessageElementData_GetTypeString(self)

    def GetTypeID(self):
        return _RobotRaconteurPython.MessageElementData_GetTypeID(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_MessageElementData

# Register MessageElementData in _RobotRaconteurPython:
_RobotRaconteurPython.MessageElementData_swigregister(MessageElementData)

class RRBaseArray(MessageElementData):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetTypeString(self):
        return _RobotRaconteurPython.RRBaseArray_GetTypeString(self)

    def size(self):
        return _RobotRaconteurPython.RRBaseArray_size(self)

    def void_ptr(self):
        return _RobotRaconteurPython.RRBaseArray_void_ptr(self)

    def ElementSize(self):
        return _RobotRaconteurPython.RRBaseArray_ElementSize(self)

    def GetTypeID(self):
        return _RobotRaconteurPython.RRBaseArray_GetTypeID(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_RRBaseArray

# Register RRBaseArray in _RobotRaconteurPython:
_RobotRaconteurPython.RRBaseArray_swigregister(RRBaseArray)


def AllocateRRArrayByType(type, length):
    return _RobotRaconteurPython.AllocateRRArrayByType(type, length)
class RRMultiDimArrayUntyped(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Dims = property(_RobotRaconteurPython.RRMultiDimArrayUntyped_Dims_get, _RobotRaconteurPython.RRMultiDimArrayUntyped_Dims_set)
    Array = property(_RobotRaconteurPython.RRMultiDimArrayUntyped_Array_get, _RobotRaconteurPython.RRMultiDimArrayUntyped_Array_set)

    def __init__(self):
        _RobotRaconteurPython.RRMultiDimArrayUntyped_swiginit(self, _RobotRaconteurPython.new_RRMultiDimArrayUntyped())
    __swig_destroy__ = _RobotRaconteurPython.delete_RRMultiDimArrayUntyped

# Register RRMultiDimArrayUntyped in _RobotRaconteurPython:
_RobotRaconteurPython.RRMultiDimArrayUntyped_swigregister(RRMultiDimArrayUntyped)

class MultiDimArray_CalculateCopyIndicesIter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Next(self):
        return _RobotRaconteurPython.MultiDimArray_CalculateCopyIndicesIter_Next(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_MultiDimArray_CalculateCopyIndicesIter

# Register MultiDimArray_CalculateCopyIndicesIter in _RobotRaconteurPython:
_RobotRaconteurPython.MultiDimArray_CalculateCopyIndicesIter_swigregister(MultiDimArray_CalculateCopyIndicesIter)


def MultiDimArray_CalculateCopyIndicesBeginIter(mema_dims, mema_pos, memb_dims, memb_pos, count):
    return _RobotRaconteurPython.MultiDimArray_CalculateCopyIndicesBeginIter(mema_dims, mema_pos, memb_dims, memb_pos, count)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class NodeID(object):
    r"""

    NodeID(Union[None,str,numpy.ndarray])

    NodeID UUID storage and generation

    Robot Raconteur uses NodeID and NodeName to uniquely identify a node.
    NodeID is a UUID (Universally Unique ID), while NodeName is a string. The
    NodeID is expected to be unique, while the NodeName is set by the user 
    and may not be unique. The NodeID class represents the UUID NodeID.

    A UUID is a 128-bit randomly generated number that is statistically guaranteed
    to be unique to a very high probability. NodeID uses the Boost.UUID library
    to generate, manage, and store the UUID.

    The UUID can be loaded from a string, bytes, or generated randomly at runtime.
    It can be converted to a string.

    The LocalTransport and ServerNodeSetup classes will automatically assign
    a NodeID to a node when the local transport is started with a specified node name.
    The generated NodeID is stored on the local system, and is associated with the node name.
    It will be loaded when a node is started with the same NodeName.

    NodeID with all zeros is considered "any" node.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def ToString(self, *args):
        return _RobotRaconteurPython.NodeID_ToString(self, *args)

    @staticmethod
    def NewUniqueID():
        r"""

        Generate a new random NodeID UUID

        Returned UUID is statistically guaranteed to be unique

        :return: NodeID The newly generated UUID
        :rtype: RobotRaconteur.NodeID

        """
        return _RobotRaconteurPython.NodeID_NewUniqueID()

    def __eq__(self, id2):
        return _RobotRaconteurPython.NodeID___eq__(self, id2)

    def __ne__(self, id2):
        return _RobotRaconteurPython.NodeID___ne__(self, id2)

    def __lt__(self, id2):
        return _RobotRaconteurPython.NodeID___lt__(self, id2)

    def IsAnyNode(self):
        r"""

        Is the NodeID UUID all zeros

        The all zero UUID respresents "any" node, or an unset NodeID

        :return: True The NodeID UUID is all zeros, representing any node, False The NodeID UUID is not all zeros
        :rtype: bool

        """
        return _RobotRaconteurPython.NodeID_IsAnyNode(self)

    @staticmethod
    def GetAny():
        r"""

        Get the "any" NodeId

        :return: The "any" NodeID
        :rtype: RobotRaconteur.NodeID

        """
        return _RobotRaconteurPython.NodeID_GetAny()

    def __init__(self, *args):
        _RobotRaconteurPython.NodeID_swiginit(self, _RobotRaconteurPython.new_NodeID(*args))

    def ToByteArray(self):
        r"""

        Convert the NodeID UUID to bytes

        :return: The UUID as bytes
        :rtype: bytearray

        """
        val = _RobotRaconteurPython.NodeID_ToByteArray(self)

        return bytearray(val)


        return val


    @staticmethod
    def FromByteArray(bytes):
        r"""

        Returns a new NodeID from bytes

        :param bytes: The bytes
        :type bytes: bytearray
        :return: The new NodeID instance with the specified UUID
        :rtype: RobotRaconteur.NodeID

        """
        return _RobotRaconteurPython.NodeID_FromByteArray(bytes)

    def __str__(self):
    	return self.ToString()

    __swig_destroy__ = _RobotRaconteurPython.delete_NodeID

# Register NodeID in _RobotRaconteurPython:
_RobotRaconteurPython.NodeID_swigregister(NodeID)

def NodeID_NewUniqueID():
    r"""

    Generate a new random NodeID UUID

    Returned UUID is statistically guaranteed to be unique

    :return: NodeID The newly generated UUID
    :rtype: RobotRaconteur.NodeID

    """
    return _RobotRaconteurPython.NodeID_NewUniqueID()

def NodeID_GetAny():
    r"""

    Get the "any" NodeId

    :return: The "any" NodeID
    :rtype: RobotRaconteur.NodeID

    """
    return _RobotRaconteurPython.NodeID_GetAny()

def NodeID_FromByteArray(bytes):
    r"""

    Returns a new NodeID from bytes

    :param bytes: The bytes
    :type bytes: bytearray
    :return: The new NodeID instance with the specified UUID
    :rtype: RobotRaconteur.NodeID

    """
    return _RobotRaconteurPython.NodeID_FromByteArray(bytes)

class vectorptr_messageentry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_messageentry_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_messageentry___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_messageentry___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_messageentry___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_messageentry___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_messageentry___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_messageentry_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_messageentry_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_messageentry_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_messageentry_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_messageentry_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_messageentry_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_messageentry_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_messageentry_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_messageentry_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_messageentry_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_messageentry_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_messageentry_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_messageentry_swiginit(self, _RobotRaconteurPython.new_vectorptr_messageentry(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_messageentry_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_messageentry_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_messageentry_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_messageentry_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_messageentry_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_messageentry_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_messageentry_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_messageentry

# Register vectorptr_messageentry in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_messageentry_swigregister(vectorptr_messageentry)

class vectorptr_messageelement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_messageelement_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_messageelement___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_messageelement___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_messageelement___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_messageelement___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_messageelement___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_messageelement_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_messageelement_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_messageelement_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_messageelement_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_messageelement_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_messageelement_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_messageelement_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_messageelement_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_messageelement_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_messageelement_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_messageelement_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_messageelement_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_messageelement_swiginit(self, _RobotRaconteurPython.new_vectorptr_messageelement(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_messageelement_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_messageelement_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_messageelement_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_messageelement_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_messageelement_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_messageelement_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_messageelement_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_messageelement

# Register vectorptr_messageelement in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_messageelement_swigregister(vectorptr_messageelement)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class Message(RRValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    header = property(_RobotRaconteurPython.Message_header_get, _RobotRaconteurPython.Message_header_set)
    entries = property(_RobotRaconteurPython.Message_entries_get, _RobotRaconteurPython.Message_entries_set)

    def __init__(self):
        _RobotRaconteurPython.Message_swiginit(self, _RobotRaconteurPython.new_Message())

    def ComputeSize(self):
        return _RobotRaconteurPython.Message_ComputeSize(self)

    def FindEntry(self, name):
        return _RobotRaconteurPython.Message_FindEntry(self, name)

    def AddEntry(self, t, name):
        return _RobotRaconteurPython.Message_AddEntry(self, t, name)
    __swig_destroy__ = _RobotRaconteurPython.delete_Message

# Register Message in _RobotRaconteurPython:
_RobotRaconteurPython.Message_swigregister(Message)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MessageHeader(RRValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    HeaderSize = property(_RobotRaconteurPython.MessageHeader_HeaderSize_get, _RobotRaconteurPython.MessageHeader_HeaderSize_set)
    MessageFlags = property(_RobotRaconteurPython.MessageHeader_MessageFlags_get, _RobotRaconteurPython.MessageHeader_MessageFlags_set)
    SenderEndpoint = property(_RobotRaconteurPython.MessageHeader_SenderEndpoint_get, _RobotRaconteurPython.MessageHeader_SenderEndpoint_set)
    ReceiverEndpoint = property(_RobotRaconteurPython.MessageHeader_ReceiverEndpoint_get, _RobotRaconteurPython.MessageHeader_ReceiverEndpoint_set)
    SenderNodeName = property(_RobotRaconteurPython.MessageHeader_SenderNodeName_get, _RobotRaconteurPython.MessageHeader_SenderNodeName_set)
    ReceiverNodeName = property(_RobotRaconteurPython.MessageHeader_ReceiverNodeName_get, _RobotRaconteurPython.MessageHeader_ReceiverNodeName_set)
    SenderNodeID = property(_RobotRaconteurPython.MessageHeader_SenderNodeID_get, _RobotRaconteurPython.MessageHeader_SenderNodeID_set)
    ReceiverNodeID = property(_RobotRaconteurPython.MessageHeader_ReceiverNodeID_get, _RobotRaconteurPython.MessageHeader_ReceiverNodeID_set)
    MetaData = property(_RobotRaconteurPython.MessageHeader_MetaData_get, _RobotRaconteurPython.MessageHeader_MetaData_set)
    EntryCount = property(_RobotRaconteurPython.MessageHeader_EntryCount_get, _RobotRaconteurPython.MessageHeader_EntryCount_set)
    MessageID = property(_RobotRaconteurPython.MessageHeader_MessageID_get, _RobotRaconteurPython.MessageHeader_MessageID_set)
    MessageResID = property(_RobotRaconteurPython.MessageHeader_MessageResID_get, _RobotRaconteurPython.MessageHeader_MessageResID_set)
    MessageSize = property(_RobotRaconteurPython.MessageHeader_MessageSize_get, _RobotRaconteurPython.MessageHeader_MessageSize_set)
    Priority = property(_RobotRaconteurPython.MessageHeader_Priority_get, _RobotRaconteurPython.MessageHeader_Priority_set)
    Extended = property(_RobotRaconteurPython.MessageHeader_Extended_get, _RobotRaconteurPython.MessageHeader_Extended_set)

    def ComputeSize(self):
        return _RobotRaconteurPython.MessageHeader_ComputeSize(self)

    def UpdateHeader(self, message_size, entry_count):
        return _RobotRaconteurPython.MessageHeader_UpdateHeader(self, message_size, entry_count)

    def __init__(self):
        _RobotRaconteurPython.MessageHeader_swiginit(self, _RobotRaconteurPython.new_MessageHeader())
    __swig_destroy__ = _RobotRaconteurPython.delete_MessageHeader

# Register MessageHeader in _RobotRaconteurPython:
_RobotRaconteurPython.MessageHeader_swigregister(MessageHeader)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MessageEntry(RRValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    EntrySize = property(_RobotRaconteurPython.MessageEntry_EntrySize_get, _RobotRaconteurPython.MessageEntry_EntrySize_set)
    EntryFlags = property(_RobotRaconteurPython.MessageEntry_EntryFlags_get, _RobotRaconteurPython.MessageEntry_EntryFlags_set)
    EntryType = property(_RobotRaconteurPython.MessageEntry_EntryType_get, _RobotRaconteurPython.MessageEntry_EntryType_set)
    ServicePath = property(_RobotRaconteurPython.MessageEntry_ServicePath_get, _RobotRaconteurPython.MessageEntry_ServicePath_set)
    MemberName = property(_RobotRaconteurPython.MessageEntry_MemberName_get, _RobotRaconteurPython.MessageEntry_MemberName_set)
    MemberNameCode = property(_RobotRaconteurPython.MessageEntry_MemberNameCode_get, _RobotRaconteurPython.MessageEntry_MemberNameCode_set)
    RequestID = property(_RobotRaconteurPython.MessageEntry_RequestID_get, _RobotRaconteurPython.MessageEntry_RequestID_set)
    Error = property(_RobotRaconteurPython.MessageEntry_Error_get, _RobotRaconteurPython.MessageEntry_Error_set)
    MetaData = property(_RobotRaconteurPython.MessageEntry_MetaData_get, _RobotRaconteurPython.MessageEntry_MetaData_set)
    Extended = property(_RobotRaconteurPython.MessageEntry_Extended_get, _RobotRaconteurPython.MessageEntry_Extended_set)
    elements = property(_RobotRaconteurPython.MessageEntry_elements_get, _RobotRaconteurPython.MessageEntry_elements_set)

    def __init__(self, *args):
        _RobotRaconteurPython.MessageEntry_swiginit(self, _RobotRaconteurPython.new_MessageEntry(*args))

    def ComputeSize(self):
        return _RobotRaconteurPython.MessageEntry_ComputeSize(self)

    def FindElement(self, name):
        return _RobotRaconteurPython.MessageEntry_FindElement(self, name)

    def AddElement(self, m):
        return _RobotRaconteurPython.MessageEntry_AddElement(self, m)
    __swig_destroy__ = _RobotRaconteurPython.delete_MessageEntry

# Register MessageEntry in _RobotRaconteurPython:
_RobotRaconteurPython.MessageEntry_swigregister(MessageEntry)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MessageElement(RRValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    ElementSize = property(_RobotRaconteurPython.MessageElement_ElementSize_get, _RobotRaconteurPython.MessageElement_ElementSize_set)
    ElementFlags = property(_RobotRaconteurPython.MessageElement_ElementFlags_get, _RobotRaconteurPython.MessageElement_ElementFlags_set)
    ElementName = property(_RobotRaconteurPython.MessageElement_ElementName_get, _RobotRaconteurPython.MessageElement_ElementName_set)
    ElementNameCode = property(_RobotRaconteurPython.MessageElement_ElementNameCode_get, _RobotRaconteurPython.MessageElement_ElementNameCode_set)
    ElementNumber = property(_RobotRaconteurPython.MessageElement_ElementNumber_get, _RobotRaconteurPython.MessageElement_ElementNumber_set)
    ElementType = property(_RobotRaconteurPython.MessageElement_ElementType_get, _RobotRaconteurPython.MessageElement_ElementType_set)
    ElementTypeName = property(_RobotRaconteurPython.MessageElement_ElementTypeName_get, _RobotRaconteurPython.MessageElement_ElementTypeName_set)
    ElementTypeNameCode = property(_RobotRaconteurPython.MessageElement_ElementTypeNameCode_get, _RobotRaconteurPython.MessageElement_ElementTypeNameCode_set)
    MetaData = property(_RobotRaconteurPython.MessageElement_MetaData_get, _RobotRaconteurPython.MessageElement_MetaData_set)
    Extended = property(_RobotRaconteurPython.MessageElement_Extended_get, _RobotRaconteurPython.MessageElement_Extended_set)
    DataCount = property(_RobotRaconteurPython.MessageElement_DataCount_get, _RobotRaconteurPython.MessageElement_DataCount_set)

    def __init__(self):
        _RobotRaconteurPython.MessageElement_swiginit(self, _RobotRaconteurPython.new_MessageElement())

    def _GetData(self):
        val = _RobotRaconteurPython.MessageElement__GetData(self)

        a=MessageElementDataUtil.ToRRBaseArray(val)
        if (not a is None):
        	return a
        a=MessageElementDataUtil.ToMessageElementNestedElementList(val)
        if (not a is None):
        	return a



        return val


    def _SetData(self, value):
        return _RobotRaconteurPython.MessageElement__SetData(self, value)

    def ComputeSize(self):
        return _RobotRaconteurPython.MessageElement_ComputeSize(self)

    def UpdateData(self):
        return _RobotRaconteurPython.MessageElement_UpdateData(self)

    @staticmethod
    def FindElement(m, name):
        return _RobotRaconteurPython.MessageElement_FindElement(m, name)

    @staticmethod
    def ContainsElement(m, name):
        return _RobotRaconteurPython.MessageElement_ContainsElement(m, name)

    def GetData(self):
    	return self._GetData()

    def SetData(self,data):
    	return self._SetData(data)

    __swig_destroy__ = _RobotRaconteurPython.delete_MessageElement

# Register MessageElement in _RobotRaconteurPython:
_RobotRaconteurPython.MessageElement_swigregister(MessageElement)

def MessageElement_FindElement(m, name):
    return _RobotRaconteurPython.MessageElement_FindElement(m, name)

def MessageElement_ContainsElement(m, name):
    return _RobotRaconteurPython.MessageElement_ContainsElement(m, name)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MessageElementNestedElementList(MessageElementData):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    Type = property(_RobotRaconteurPython.MessageElementNestedElementList_Type_get, _RobotRaconteurPython.MessageElementNestedElementList_Type_set)
    TypeName = property(_RobotRaconteurPython.MessageElementNestedElementList_TypeName_get, _RobotRaconteurPython.MessageElementNestedElementList_TypeName_set)
    Elements = property(_RobotRaconteurPython.MessageElementNestedElementList_Elements_get, _RobotRaconteurPython.MessageElementNestedElementList_Elements_set)

    def __init__(self, type_, type_name_, elements_):
        _RobotRaconteurPython.MessageElementNestedElementList_swiginit(self, _RobotRaconteurPython.new_MessageElementNestedElementList(type_, type_name_, elements_))

    def GetTypeString(self):
        return _RobotRaconteurPython.MessageElementNestedElementList_GetTypeString(self)

    def GetTypeID(self):
        return _RobotRaconteurPython.MessageElementNestedElementList_GetTypeID(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_MessageElementNestedElementList

# Register MessageElementNestedElementList in _RobotRaconteurPython:
_RobotRaconteurPython.MessageElementNestedElementList_swigregister(MessageElementNestedElementList)

class MessageElementDataUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def ToRRBaseArray(m):
        return _RobotRaconteurPython.MessageElementDataUtil_ToRRBaseArray(m)

    @staticmethod
    def ToMessageElementNestedElementList(m):
        return _RobotRaconteurPython.MessageElementDataUtil_ToMessageElementNestedElementList(m)

    def __init__(self):
        _RobotRaconteurPython.MessageElementDataUtil_swiginit(self, _RobotRaconteurPython.new_MessageElementDataUtil())
    __swig_destroy__ = _RobotRaconteurPython.delete_MessageElementDataUtil

# Register MessageElementDataUtil in _RobotRaconteurPython:
_RobotRaconteurPython.MessageElementDataUtil_swigregister(MessageElementDataUtil)

def MessageElementDataUtil_ToRRBaseArray(m):
    return _RobotRaconteurPython.MessageElementDataUtil_ToRRBaseArray(m)

def MessageElementDataUtil_ToMessageElementNestedElementList(m):
    return _RobotRaconteurPython.MessageElementDataUtil_ToMessageElementNestedElementList(m)


def MessageFromBytes(bytes):
    return _RobotRaconteurPython.MessageFromBytes(bytes)

def MessageLengthFromBytes(bytes):
    return _RobotRaconteurPython.MessageLengthFromBytes(bytes)

def MessageToBytes(m, ver=2):
    return _RobotRaconteurPython.MessageToBytes(m, ver)

def MessageElementFromBytes(bytes):
    return _RobotRaconteurPython.MessageElementFromBytes(bytes)

def MessageElementLengthFromBytes(bytes):
    return _RobotRaconteurPython.MessageElementLengthFromBytes(bytes)

def MessageElementToBytes(m, ver=2):
    return _RobotRaconteurPython.MessageElementToBytes(m, ver)
class HandlerErrorInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    error_code = property(_RobotRaconteurPython.HandlerErrorInfo_error_code_get, _RobotRaconteurPython.HandlerErrorInfo_error_code_set)
    errorname = property(_RobotRaconteurPython.HandlerErrorInfo_errorname_get, _RobotRaconteurPython.HandlerErrorInfo_errorname_set)
    errormessage = property(_RobotRaconteurPython.HandlerErrorInfo_errormessage_get, _RobotRaconteurPython.HandlerErrorInfo_errormessage_set)
    errorsubname = property(_RobotRaconteurPython.HandlerErrorInfo_errorsubname_get, _RobotRaconteurPython.HandlerErrorInfo_errorsubname_set)
    param_ = property(_RobotRaconteurPython.HandlerErrorInfo_param__get, _RobotRaconteurPython.HandlerErrorInfo_param__set)

    def __init__(self):
        _RobotRaconteurPython.HandlerErrorInfo_swiginit(self, _RobotRaconteurPython.new_HandlerErrorInfo())
    __swig_destroy__ = _RobotRaconteurPython.delete_HandlerErrorInfo

# Register HandlerErrorInfo in _RobotRaconteurPython:
_RobotRaconteurPython.HandlerErrorInfo_swigregister(HandlerErrorInfo)

class AsyncRequestDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncRequestDirector

    def handler(self, ret, error):
        return _RobotRaconteurPython.AsyncRequestDirector_handler(self, ret, error)

    def __init__(self):
        if self.__class__ == AsyncRequestDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncRequestDirector_swiginit(self, _RobotRaconteurPython.new_AsyncRequestDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncRequestDirector(self)
        return weakref.proxy(self)

# Register AsyncRequestDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncRequestDirector_swigregister(AsyncRequestDirector)

class AsyncVoidReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncVoidReturnDirector

    def handler(self, error):
        return _RobotRaconteurPython.AsyncVoidReturnDirector_handler(self, error)

    def __init__(self):
        if self.__class__ == AsyncVoidReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncVoidReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncVoidReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncVoidReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncVoidReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncVoidReturnDirector_swigregister(AsyncVoidReturnDirector)

class AsyncVoidNoErrReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncVoidNoErrReturnDirector

    def handler(self):
        return _RobotRaconteurPython.AsyncVoidNoErrReturnDirector_handler(self)

    def __init__(self):
        if self.__class__ == AsyncVoidNoErrReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncVoidNoErrReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncVoidNoErrReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncVoidNoErrReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncVoidNoErrReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncVoidNoErrReturnDirector_swigregister(AsyncVoidNoErrReturnDirector)

class AsyncStringReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncStringReturnDirector

    def handler(self, ret, error):
        return _RobotRaconteurPython.AsyncStringReturnDirector_handler(self, ret, error)

    def __init__(self):
        if self.__class__ == AsyncStringReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncStringReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncStringReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncStringReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncStringReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncStringReturnDirector_swigregister(AsyncStringReturnDirector)

class AsyncUInt32ReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncUInt32ReturnDirector

    def handler(self, ret, error):
        return _RobotRaconteurPython.AsyncUInt32ReturnDirector_handler(self, ret, error)

    def __init__(self):
        if self.__class__ == AsyncUInt32ReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncUInt32ReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncUInt32ReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncUInt32ReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncUInt32ReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncUInt32ReturnDirector_swigregister(AsyncUInt32ReturnDirector)

class vectorptr_typedefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_typedefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_typedefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_typedefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_typedefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_typedefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_typedefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_typedefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_typedefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_typedefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_typedefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_typedefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_typedefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_typedefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_typedefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_typedefinition

# Register vectorptr_typedefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_typedefinition_swigregister(vectorptr_typedefinition)

class vectorptr_memberdefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_memberdefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_memberdefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_memberdefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_memberdefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        val = _RobotRaconteurPython.vectorptr_memberdefinition___getitem__(self, *args)

        a=MemberDefinitionUtil.ToProperty(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToFunction(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToEvent(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToObjRef(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToPipe(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToCallback(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToWire(val)
        if (not a is None):
        	return a
        a=MemberDefinitionUtil.ToMemory(val)
        if (not a is None):
        	return a
        return val



        return val


    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_memberdefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_memberdefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_memberdefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_memberdefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_memberdefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_memberdefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_memberdefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_memberdefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_memberdefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_memberdefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_memberdefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_memberdefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_memberdefinition

# Register vectorptr_memberdefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_memberdefinition_swigregister(vectorptr_memberdefinition)

class vectorptr_serviceentrydefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_serviceentrydefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_serviceentrydefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_serviceentrydefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_serviceentrydefinition

# Register vectorptr_serviceentrydefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_serviceentrydefinition_swigregister(vectorptr_serviceentrydefinition)

class vectorptr_constantdefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_constantdefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_constantdefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_constantdefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_constantdefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_constantdefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_constantdefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_constantdefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_constantdefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_constantdefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_constantdefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_constantdefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_constantdefinition

# Register vectorptr_constantdefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_constantdefinition_swigregister(vectorptr_constantdefinition)

class vectorptr_enumdefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_enumdefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_enumdefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_enumdefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_enumdefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_enumdefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_enumdefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_enumdefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_enumdefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_enumdefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_enumdefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_enumdefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_enumdefinition

# Register vectorptr_enumdefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_enumdefinition_swigregister(vectorptr_enumdefinition)

class vector_constantdefinition_structfield(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_constantdefinition_structfield_swiginit(self, _RobotRaconteurPython.new_vector_constantdefinition_structfield(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_constantdefinition_structfield_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_constantdefinition_structfield

# Register vector_constantdefinition_structfield in _RobotRaconteurPython:
_RobotRaconteurPython.vector_constantdefinition_structfield_swigregister(vector_constantdefinition_structfield)

class vector_enumdefinitionvalues(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_enumdefinitionvalues_swiginit(self, _RobotRaconteurPython.new_vector_enumdefinitionvalues(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_enumdefinitionvalues_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_enumdefinitionvalues

# Register vector_enumdefinitionvalues in _RobotRaconteurPython:
_RobotRaconteurPython.vector_enumdefinitionvalues_swigregister(vector_enumdefinitionvalues)

class vector_usingdefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_usingdefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_usingdefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_usingdefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_usingdefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_usingdefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_usingdefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_usingdefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_usingdefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_usingdefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_usingdefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_usingdefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_usingdefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_usingdefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_usingdefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_usingdefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_usingdefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_usingdefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_usingdefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_usingdefinition_swiginit(self, _RobotRaconteurPython.new_vector_usingdefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_usingdefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_usingdefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_usingdefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_usingdefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_usingdefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_usingdefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_usingdefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_usingdefinition

# Register vector_usingdefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vector_usingdefinition_swigregister(vector_usingdefinition)

class vectorptr_exceptiondefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_exceptiondefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_exceptiondefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_exceptiondefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_exceptiondefinition

# Register vectorptr_exceptiondefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_exceptiondefinition_swigregister(vectorptr_exceptiondefinition)

class vectorptr_servicedefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_servicedefinition___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_servicedefinition___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_servicedefinition_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_servicedefinition_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_servicedefinition_swiginit(self, _RobotRaconteurPython.new_vectorptr_servicedefinition(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_servicedefinition_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_servicedefinition_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_servicedefinition_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_servicedefinition_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_servicedefinition_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_servicedefinition

# Register vectorptr_servicedefinition in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_servicedefinition_swigregister(vectorptr_servicedefinition)

class ServiceDefinitionParseInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ServiceName = property(_RobotRaconteurPython.ServiceDefinitionParseInfo_ServiceName_get, _RobotRaconteurPython.ServiceDefinitionParseInfo_ServiceName_set)
    RobDefFilePath = property(_RobotRaconteurPython.ServiceDefinitionParseInfo_RobDefFilePath_get, _RobotRaconteurPython.ServiceDefinitionParseInfo_RobDefFilePath_set)
    Line = property(_RobotRaconteurPython.ServiceDefinitionParseInfo_Line_get, _RobotRaconteurPython.ServiceDefinitionParseInfo_Line_set)
    LineNumber = property(_RobotRaconteurPython.ServiceDefinitionParseInfo_LineNumber_get, _RobotRaconteurPython.ServiceDefinitionParseInfo_LineNumber_set)

    def __init__(self):
        _RobotRaconteurPython.ServiceDefinitionParseInfo_swiginit(self, _RobotRaconteurPython.new_ServiceDefinitionParseInfo())

    def Reset(self):
        return _RobotRaconteurPython.ServiceDefinitionParseInfo_Reset(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceDefinitionParseInfo

# Register ServiceDefinitionParseInfo in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceDefinitionParseInfo_swigregister(ServiceDefinitionParseInfo)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class RobotRaconteurVersion(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.RobotRaconteurVersion_swiginit(self, _RobotRaconteurPython.new_RobotRaconteurVersion(*args))

    def ToString(self):
        return _RobotRaconteurPython.RobotRaconteurVersion_ToString(self)

    def FromString(self, v, parse_info=None):
        return _RobotRaconteurPython.RobotRaconteurVersion_FromString(self, v, parse_info)

    def __nonzero__(self):
        return _RobotRaconteurPython.RobotRaconteurVersion___nonzero__(self)
    __bool__ = __nonzero__


    major = property(_RobotRaconteurPython.RobotRaconteurVersion_major_get, _RobotRaconteurPython.RobotRaconteurVersion_major_set)
    minor = property(_RobotRaconteurPython.RobotRaconteurVersion_minor_get, _RobotRaconteurPython.RobotRaconteurVersion_minor_set)
    patch = property(_RobotRaconteurPython.RobotRaconteurVersion_patch_get, _RobotRaconteurPython.RobotRaconteurVersion_patch_set)
    tweak = property(_RobotRaconteurPython.RobotRaconteurVersion_tweak_get, _RobotRaconteurPython.RobotRaconteurVersion_tweak_set)
    ParseInfo = property(_RobotRaconteurPython.RobotRaconteurVersion_ParseInfo_get, _RobotRaconteurPython.RobotRaconteurVersion_ParseInfo_set)

    def __eq__(self, other):
        return RobotRaconteurVersion_eq(self,other)

    def __ne___(self, other):
        return RobotRaconteurVersion_ne(self,other)

    def __gt__(self, other):
        return RobotRaconteurVersion_gt(self,other)

    def __ge__(self, other):
        return RobotRaconteurVersion_ge(self,other)

    def __lt__(self, other):
        return RobotRaconteurVersion_lt(self,other)

    def __le__(self, other):
        return RobotRaconteurVersion_le(self,other)

    def  __str__(self):
        return self.ToString()

    __swig_destroy__ = _RobotRaconteurPython.delete_RobotRaconteurVersion

# Register RobotRaconteurVersion in _RobotRaconteurPython:
_RobotRaconteurPython.RobotRaconteurVersion_swigregister(RobotRaconteurVersion)


def RobotRaconteurVersion_eq(v1, v2):
    return _RobotRaconteurPython.RobotRaconteurVersion_eq(v1, v2)

def RobotRaconteurVersion_ne(v1, v2):
    return _RobotRaconteurPython.RobotRaconteurVersion_ne(v1, v2)

def RobotRaconteurVersion_gt(v1, v2):
    return _RobotRaconteurPython.RobotRaconteurVersion_gt(v1, v2)

def RobotRaconteurVersion_ge(v1, v2):
    return _RobotRaconteurPython.RobotRaconteurVersion_ge(v1, v2)

def RobotRaconteurVersion_lt(v1, v2):
    return _RobotRaconteurPython.RobotRaconteurVersion_lt(v1, v2)

def RobotRaconteurVersion_le(v1, v2):
    return _RobotRaconteurPython.RobotRaconteurVersion_le(v1, v2)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ServiceDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.ServiceDefinition_Name_get, _RobotRaconteurPython.ServiceDefinition_Name_set)
    NamedArrays = property(_RobotRaconteurPython.ServiceDefinition_NamedArrays_get, _RobotRaconteurPython.ServiceDefinition_NamedArrays_set)
    Pods = property(_RobotRaconteurPython.ServiceDefinition_Pods_get, _RobotRaconteurPython.ServiceDefinition_Pods_set)
    Structures = property(_RobotRaconteurPython.ServiceDefinition_Structures_get, _RobotRaconteurPython.ServiceDefinition_Structures_set)
    Objects = property(_RobotRaconteurPython.ServiceDefinition_Objects_get, _RobotRaconteurPython.ServiceDefinition_Objects_set)
    Options = property(_RobotRaconteurPython.ServiceDefinition_Options_get, _RobotRaconteurPython.ServiceDefinition_Options_set)
    Imports = property(_RobotRaconteurPython.ServiceDefinition_Imports_get, _RobotRaconteurPython.ServiceDefinition_Imports_set)
    Exceptions = property(_RobotRaconteurPython.ServiceDefinition_Exceptions_get, _RobotRaconteurPython.ServiceDefinition_Exceptions_set)
    Using = property(_RobotRaconteurPython.ServiceDefinition_Using_get, _RobotRaconteurPython.ServiceDefinition_Using_set)
    Constants = property(_RobotRaconteurPython.ServiceDefinition_Constants_get, _RobotRaconteurPython.ServiceDefinition_Constants_set)
    Enums = property(_RobotRaconteurPython.ServiceDefinition_Enums_get, _RobotRaconteurPython.ServiceDefinition_Enums_set)
    StdVer = property(_RobotRaconteurPython.ServiceDefinition_StdVer_get, _RobotRaconteurPython.ServiceDefinition_StdVer_set)
    ParseInfo = property(_RobotRaconteurPython.ServiceDefinition_ParseInfo_get, _RobotRaconteurPython.ServiceDefinition_ParseInfo_set)
    DocString = property(_RobotRaconteurPython.ServiceDefinition_DocString_get, _RobotRaconteurPython.ServiceDefinition_DocString_set)

    def ToString(self):
        return _RobotRaconteurPython.ServiceDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.ServiceDefinition_FromString(self, s, parse_info)

    def __init__(self):
        _RobotRaconteurPython.ServiceDefinition_swiginit(self, _RobotRaconteurPython.new_ServiceDefinition())

    def Reset(self):
        return _RobotRaconteurPython.ServiceDefinition_Reset(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceDefinition

# Register ServiceDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceDefinition_swigregister(ServiceDefinition)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ServiceEntryDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.ServiceEntryDefinition_Name_get, _RobotRaconteurPython.ServiceEntryDefinition_Name_set)
    Members = property(_RobotRaconteurPython.ServiceEntryDefinition_Members_get, _RobotRaconteurPython.ServiceEntryDefinition_Members_set)
    EntryType = property(_RobotRaconteurPython.ServiceEntryDefinition_EntryType_get, _RobotRaconteurPython.ServiceEntryDefinition_EntryType_set)
    Implements = property(_RobotRaconteurPython.ServiceEntryDefinition_Implements_get, _RobotRaconteurPython.ServiceEntryDefinition_Implements_set)
    Options = property(_RobotRaconteurPython.ServiceEntryDefinition_Options_get, _RobotRaconteurPython.ServiceEntryDefinition_Options_set)
    Constants = property(_RobotRaconteurPython.ServiceEntryDefinition_Constants_get, _RobotRaconteurPython.ServiceEntryDefinition_Constants_set)
    ParseInfo = property(_RobotRaconteurPython.ServiceEntryDefinition_ParseInfo_get, _RobotRaconteurPython.ServiceEntryDefinition_ParseInfo_set)
    DocString = property(_RobotRaconteurPython.ServiceEntryDefinition_DocString_get, _RobotRaconteurPython.ServiceEntryDefinition_DocString_set)

    def __init__(self, _def):
        _RobotRaconteurPython.ServiceEntryDefinition_swiginit(self, _RobotRaconteurPython.new_ServiceEntryDefinition(_def))

    def ToString(self):
        return _RobotRaconteurPython.ServiceEntryDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.ServiceEntryDefinition_FromString(self, s, parse_info)

    def GetServiceDefinition(self):
        return _RobotRaconteurPython.ServiceEntryDefinition_GetServiceDefinition(self)

    def SetServiceDefinition(self, value):
        return _RobotRaconteurPython.ServiceEntryDefinition_SetServiceDefinition(self, value)

    def Reset(self):
        return _RobotRaconteurPython.ServiceEntryDefinition_Reset(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceEntryDefinition

# Register ServiceEntryDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceEntryDefinition_swigregister(ServiceEntryDefinition)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MemberDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.MemberDefinition_Name_get, _RobotRaconteurPython.MemberDefinition_Name_set)
    DocString = property(_RobotRaconteurPython.MemberDefinition_DocString_get, _RobotRaconteurPython.MemberDefinition_DocString_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.MemberDefinition_swiginit(self, _RobotRaconteurPython.new_MemberDefinition(ServiceEntry))

    def NoLock(self):
        return _RobotRaconteurPython.MemberDefinition_NoLock(self)

    def ToString(self):
        return _RobotRaconteurPython.MemberDefinition_ToString(self)

    def GetServiceEntry(self):
        return _RobotRaconteurPython.MemberDefinition_GetServiceEntry(self)

    def SetServiceEntry(self, value):
        return _RobotRaconteurPython.MemberDefinition_SetServiceEntry(self, value)
    Modifiers = property(_RobotRaconteurPython.MemberDefinition_Modifiers_get, _RobotRaconteurPython.MemberDefinition_Modifiers_set)
    ParseInfo = property(_RobotRaconteurPython.MemberDefinition_ParseInfo_get, _RobotRaconteurPython.MemberDefinition_ParseInfo_set)

    def Reset(self):
        return _RobotRaconteurPython.MemberDefinition_Reset(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_MemberDefinition

# Register MemberDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.MemberDefinition_swigregister(MemberDefinition)

class PropertyDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type = property(_RobotRaconteurPython.PropertyDefinition_Type_get, _RobotRaconteurPython.PropertyDefinition_Type_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.PropertyDefinition_swiginit(self, _RobotRaconteurPython.new_PropertyDefinition(ServiceEntry))

    def ToString(self, *args):
        return _RobotRaconteurPython.PropertyDefinition_ToString(self, *args)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.PropertyDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_PropertyDefinition

# Register PropertyDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.PropertyDefinition_swigregister(PropertyDefinition)

class FunctionDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ReturnType = property(_RobotRaconteurPython.FunctionDefinition_ReturnType_get, _RobotRaconteurPython.FunctionDefinition_ReturnType_set)
    Parameters = property(_RobotRaconteurPython.FunctionDefinition_Parameters_get, _RobotRaconteurPython.FunctionDefinition_Parameters_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.FunctionDefinition_swiginit(self, _RobotRaconteurPython.new_FunctionDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.FunctionDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.FunctionDefinition_FromString(self, s, parse_info)

    def IsGenerator(self):
        return _RobotRaconteurPython.FunctionDefinition_IsGenerator(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_FunctionDefinition

# Register FunctionDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.FunctionDefinition_swigregister(FunctionDefinition)

class EventDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Parameters = property(_RobotRaconteurPython.EventDefinition_Parameters_get, _RobotRaconteurPython.EventDefinition_Parameters_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.EventDefinition_swiginit(self, _RobotRaconteurPython.new_EventDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.EventDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.EventDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_EventDefinition

# Register EventDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.EventDefinition_swigregister(EventDefinition)

class ObjRefDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ObjectType = property(_RobotRaconteurPython.ObjRefDefinition_ObjectType_get, _RobotRaconteurPython.ObjRefDefinition_ObjectType_set)
    ArrayType = property(_RobotRaconteurPython.ObjRefDefinition_ArrayType_get, _RobotRaconteurPython.ObjRefDefinition_ArrayType_set)
    ContainerType = property(_RobotRaconteurPython.ObjRefDefinition_ContainerType_get, _RobotRaconteurPython.ObjRefDefinition_ContainerType_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.ObjRefDefinition_swiginit(self, _RobotRaconteurPython.new_ObjRefDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.ObjRefDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.ObjRefDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_ObjRefDefinition

# Register ObjRefDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.ObjRefDefinition_swigregister(ObjRefDefinition)

class PipeDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type = property(_RobotRaconteurPython.PipeDefinition_Type_get, _RobotRaconteurPython.PipeDefinition_Type_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.PipeDefinition_swiginit(self, _RobotRaconteurPython.new_PipeDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.PipeDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.PipeDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_PipeDefinition

# Register PipeDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.PipeDefinition_swigregister(PipeDefinition)

class CallbackDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ReturnType = property(_RobotRaconteurPython.CallbackDefinition_ReturnType_get, _RobotRaconteurPython.CallbackDefinition_ReturnType_set)
    Parameters = property(_RobotRaconteurPython.CallbackDefinition_Parameters_get, _RobotRaconteurPython.CallbackDefinition_Parameters_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.CallbackDefinition_swiginit(self, _RobotRaconteurPython.new_CallbackDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.CallbackDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.CallbackDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_CallbackDefinition

# Register CallbackDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.CallbackDefinition_swigregister(CallbackDefinition)

class WireDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type = property(_RobotRaconteurPython.WireDefinition_Type_get, _RobotRaconteurPython.WireDefinition_Type_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.WireDefinition_swiginit(self, _RobotRaconteurPython.new_WireDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.WireDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.WireDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_WireDefinition

# Register WireDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.WireDefinition_swigregister(WireDefinition)

class MemoryDefinition(MemberDefinition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type = property(_RobotRaconteurPython.MemoryDefinition_Type_get, _RobotRaconteurPython.MemoryDefinition_Type_set)

    def __init__(self, ServiceEntry):
        _RobotRaconteurPython.MemoryDefinition_swiginit(self, _RobotRaconteurPython.new_MemoryDefinition(ServiceEntry))

    def ToString(self):
        return _RobotRaconteurPython.MemoryDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.MemoryDefinition_FromString(self, s, parse_info)
    __swig_destroy__ = _RobotRaconteurPython.delete_MemoryDefinition

# Register MemoryDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.MemoryDefinition_swigregister(MemoryDefinition)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class TypeDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.TypeDefinition_Name_get, _RobotRaconteurPython.TypeDefinition_Name_set)
    Type = property(_RobotRaconteurPython.TypeDefinition_Type_get, _RobotRaconteurPython.TypeDefinition_Type_set)
    TypeString = property(_RobotRaconteurPython.TypeDefinition_TypeString_get, _RobotRaconteurPython.TypeDefinition_TypeString_set)
    ArrayType = property(_RobotRaconteurPython.TypeDefinition_ArrayType_get, _RobotRaconteurPython.TypeDefinition_ArrayType_set)
    ArrayVarLength = property(_RobotRaconteurPython.TypeDefinition_ArrayVarLength_get, _RobotRaconteurPython.TypeDefinition_ArrayVarLength_set)
    ArrayLength = property(_RobotRaconteurPython.TypeDefinition_ArrayLength_get, _RobotRaconteurPython.TypeDefinition_ArrayLength_set)
    ContainerType = property(_RobotRaconteurPython.TypeDefinition_ContainerType_get, _RobotRaconteurPython.TypeDefinition_ContainerType_set)

    def ToString(self):
        return _RobotRaconteurPython.TypeDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.TypeDefinition_FromString(self, s, parse_info)

    @staticmethod
    def DataTypeFromString(d):
        return _RobotRaconteurPython.TypeDefinition_DataTypeFromString(d)

    @staticmethod
    def StringFromDataType(d):
        return _RobotRaconteurPython.TypeDefinition_StringFromDataType(d)

    def _GetMember(self):
        return _RobotRaconteurPython.TypeDefinition__GetMember(self)

    def _SetMember(self, value):
        return _RobotRaconteurPython.TypeDefinition__SetMember(self, value)

    def CopyTo(self, _def):
        return _RobotRaconteurPython.TypeDefinition_CopyTo(self, _def)

    def Clone(self):
        return _RobotRaconteurPython.TypeDefinition_Clone(self)

    def Rename(self, name):
        return _RobotRaconteurPython.TypeDefinition_Rename(self, name)

    def RemoveContainers(self):
        return _RobotRaconteurPython.TypeDefinition_RemoveContainers(self)

    def RemoveArray(self):
        return _RobotRaconteurPython.TypeDefinition_RemoveArray(self)

    def QualifyTypeStringWithUsing(self):
        return _RobotRaconteurPython.TypeDefinition_QualifyTypeStringWithUsing(self)

    def UnqualifyTypeStringWithUsing(self):
        return _RobotRaconteurPython.TypeDefinition_UnqualifyTypeStringWithUsing(self)

    def Reset(self):
        return _RobotRaconteurPython.TypeDefinition_Reset(self)

    def __init__(self, *args):
        _RobotRaconteurPython.TypeDefinition_swiginit(self, _RobotRaconteurPython.new_TypeDefinition(*args))
    __swig_destroy__ = _RobotRaconteurPython.delete_TypeDefinition

# Register TypeDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.TypeDefinition_swigregister(TypeDefinition)

def TypeDefinition_DataTypeFromString(d):
    return _RobotRaconteurPython.TypeDefinition_DataTypeFromString(d)

def TypeDefinition_StringFromDataType(d):
    return _RobotRaconteurPython.TypeDefinition_StringFromDataType(d)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class UsingDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_UsingDefinition
    QualifiedName = property(_RobotRaconteurPython.UsingDefinition_QualifiedName_get, _RobotRaconteurPython.UsingDefinition_QualifiedName_set)
    UnqualifiedName = property(_RobotRaconteurPython.UsingDefinition_UnqualifiedName_get, _RobotRaconteurPython.UsingDefinition_UnqualifiedName_set)
    ParseInfo = property(_RobotRaconteurPython.UsingDefinition_ParseInfo_get, _RobotRaconteurPython.UsingDefinition_ParseInfo_set)

    def _GetService(self):
        return _RobotRaconteurPython.UsingDefinition__GetService(self)

    def _SetService(self, value):
        return _RobotRaconteurPython.UsingDefinition__SetService(self, value)

    def __init__(self, service):
        _RobotRaconteurPython.UsingDefinition_swiginit(self, _RobotRaconteurPython.new_UsingDefinition(service))

    def ToString(self):
        return _RobotRaconteurPython.UsingDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.UsingDefinition_FromString(self, s, parse_info)

# Register UsingDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.UsingDefinition_swigregister(UsingDefinition)

class ConstantDefinition_StructField(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.ConstantDefinition_StructField_Name_get, _RobotRaconteurPython.ConstantDefinition_StructField_Name_set)
    ConstantRefName = property(_RobotRaconteurPython.ConstantDefinition_StructField_ConstantRefName_get, _RobotRaconteurPython.ConstantDefinition_StructField_ConstantRefName_set)

    def __init__(self):
        _RobotRaconteurPython.ConstantDefinition_StructField_swiginit(self, _RobotRaconteurPython.new_ConstantDefinition_StructField())
    __swig_destroy__ = _RobotRaconteurPython.delete_ConstantDefinition_StructField

# Register ConstantDefinition_StructField in _RobotRaconteurPython:
_RobotRaconteurPython.ConstantDefinition_StructField_swigregister(ConstantDefinition_StructField)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ConstantDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_ConstantDefinition
    Name = property(_RobotRaconteurPython.ConstantDefinition_Name_get, _RobotRaconteurPython.ConstantDefinition_Name_set)
    DocString = property(_RobotRaconteurPython.ConstantDefinition_DocString_get, _RobotRaconteurPython.ConstantDefinition_DocString_set)
    Type = property(_RobotRaconteurPython.ConstantDefinition_Type_get, _RobotRaconteurPython.ConstantDefinition_Type_set)
    Value = property(_RobotRaconteurPython.ConstantDefinition_Value_get, _RobotRaconteurPython.ConstantDefinition_Value_set)
    ParseInfo = property(_RobotRaconteurPython.ConstantDefinition_ParseInfo_get, _RobotRaconteurPython.ConstantDefinition_ParseInfo_set)

    def _GetService(self):
        return _RobotRaconteurPython.ConstantDefinition__GetService(self)

    def _SetService(self, value):
        return _RobotRaconteurPython.ConstantDefinition__SetService(self, value)

    def _GetServiceEntry(self):
        return _RobotRaconteurPython.ConstantDefinition__GetServiceEntry(self)

    def _SetServiceEntry(self, value):
        return _RobotRaconteurPython.ConstantDefinition__SetServiceEntry(self, value)

    def __init__(self, *args):
        _RobotRaconteurPython.ConstantDefinition_swiginit(self, _RobotRaconteurPython.new_ConstantDefinition(*args))

    def ToString(self):
        return _RobotRaconteurPython.ConstantDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.ConstantDefinition_FromString(self, s, parse_info)

    def Reset(self):
        return _RobotRaconteurPython.ConstantDefinition_Reset(self)

    def VerifyValue(self):
        return _RobotRaconteurPython.ConstantDefinition_VerifyValue(self)

    def ValueToString(self):
        return _RobotRaconteurPython.ConstantDefinition_ValueToString(self)

    def ValueToStructFields(self):
        return _RobotRaconteurPython.ConstantDefinition_ValueToStructFields(self)

    @staticmethod
    def UnescapeString(_in):
        return _RobotRaconteurPython.ConstantDefinition_UnescapeString(_in)

    @staticmethod
    def EscapeString(_in):
        return _RobotRaconteurPython.ConstantDefinition_EscapeString(_in)

# Register ConstantDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.ConstantDefinition_swigregister(ConstantDefinition)

def ConstantDefinition_UnescapeString(_in):
    return _RobotRaconteurPython.ConstantDefinition_UnescapeString(_in)

def ConstantDefinition_EscapeString(_in):
    return _RobotRaconteurPython.ConstantDefinition_EscapeString(_in)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class EnumDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_EnumDefinition
    Name = property(_RobotRaconteurPython.EnumDefinition_Name_get, _RobotRaconteurPython.EnumDefinition_Name_set)
    DocString = property(_RobotRaconteurPython.EnumDefinition_DocString_get, _RobotRaconteurPython.EnumDefinition_DocString_set)
    Values = property(_RobotRaconteurPython.EnumDefinition_Values_get, _RobotRaconteurPython.EnumDefinition_Values_set)
    ParseInfo = property(_RobotRaconteurPython.EnumDefinition_ParseInfo_get, _RobotRaconteurPython.EnumDefinition_ParseInfo_set)

    def _GetService(self):
        return _RobotRaconteurPython.EnumDefinition__GetService(self)

    def _SetService(self, value):
        return _RobotRaconteurPython.EnumDefinition__SetService(self, value)

    def __init__(self, service):
        _RobotRaconteurPython.EnumDefinition_swiginit(self, _RobotRaconteurPython.new_EnumDefinition(service))

    def ToString(self):
        return _RobotRaconteurPython.EnumDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.EnumDefinition_FromString(self, s, parse_info)

    def VerifyValues(self):
        return _RobotRaconteurPython.EnumDefinition_VerifyValues(self)

    def Reset(self):
        return _RobotRaconteurPython.EnumDefinition_Reset(self)

# Register EnumDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.EnumDefinition_swigregister(EnumDefinition)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class EnumDefinitionValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        _RobotRaconteurPython.EnumDefinitionValue_swiginit(self, _RobotRaconteurPython.new_EnumDefinitionValue())
    Name = property(_RobotRaconteurPython.EnumDefinitionValue_Name_get, _RobotRaconteurPython.EnumDefinitionValue_Name_set)
    DocString = property(_RobotRaconteurPython.EnumDefinitionValue_DocString_get, _RobotRaconteurPython.EnumDefinitionValue_DocString_set)
    Value = property(_RobotRaconteurPython.EnumDefinitionValue_Value_get, _RobotRaconteurPython.EnumDefinitionValue_Value_set)
    ImplicitValue = property(_RobotRaconteurPython.EnumDefinitionValue_ImplicitValue_get, _RobotRaconteurPython.EnumDefinitionValue_ImplicitValue_set)
    HexValue = property(_RobotRaconteurPython.EnumDefinitionValue_HexValue_get, _RobotRaconteurPython.EnumDefinitionValue_HexValue_set)
    __swig_destroy__ = _RobotRaconteurPython.delete_EnumDefinitionValue

# Register EnumDefinitionValue in _RobotRaconteurPython:
_RobotRaconteurPython.EnumDefinitionValue_swigregister(EnumDefinitionValue)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ExceptionDefinition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_ExceptionDefinition
    Name = property(_RobotRaconteurPython.ExceptionDefinition_Name_get, _RobotRaconteurPython.ExceptionDefinition_Name_set)
    DocString = property(_RobotRaconteurPython.ExceptionDefinition_DocString_get, _RobotRaconteurPython.ExceptionDefinition_DocString_set)
    ParseInfo = property(_RobotRaconteurPython.ExceptionDefinition_ParseInfo_get, _RobotRaconteurPython.ExceptionDefinition_ParseInfo_set)

    def _GetService(self):
        return _RobotRaconteurPython.ExceptionDefinition__GetService(self)

    def _SetService(self, value):
        return _RobotRaconteurPython.ExceptionDefinition__SetService(self, value)

    def __init__(self, service):
        _RobotRaconteurPython.ExceptionDefinition_swiginit(self, _RobotRaconteurPython.new_ExceptionDefinition(service))

    def ToString(self):
        return _RobotRaconteurPython.ExceptionDefinition_ToString(self)

    def FromString(self, s, parse_info=None):
        return _RobotRaconteurPython.ExceptionDefinition_FromString(self, s, parse_info)

    def Reset(self):
        return _RobotRaconteurPython.ExceptionDefinition_Reset(self)

# Register ExceptionDefinition in _RobotRaconteurPython:
_RobotRaconteurPython.ExceptionDefinition_swigregister(ExceptionDefinition)

class MemberDefinitionUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def ToProperty(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToProperty(t)

    @staticmethod
    def ToFunction(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToFunction(t)

    @staticmethod
    def ToObjRef(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToObjRef(t)

    @staticmethod
    def ToEvent(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToEvent(t)

    @staticmethod
    def ToPipe(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToPipe(t)

    @staticmethod
    def ToCallback(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToCallback(t)

    @staticmethod
    def ToWire(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToWire(t)

    @staticmethod
    def ToMemory(t):
        return _RobotRaconteurPython.MemberDefinitionUtil_ToMemory(t)

    def __init__(self):
        _RobotRaconteurPython.MemberDefinitionUtil_swiginit(self, _RobotRaconteurPython.new_MemberDefinitionUtil())
    __swig_destroy__ = _RobotRaconteurPython.delete_MemberDefinitionUtil

# Register MemberDefinitionUtil in _RobotRaconteurPython:
_RobotRaconteurPython.MemberDefinitionUtil_swigregister(MemberDefinitionUtil)

def MemberDefinitionUtil_ToProperty(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToProperty(t)

def MemberDefinitionUtil_ToFunction(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToFunction(t)

def MemberDefinitionUtil_ToObjRef(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToObjRef(t)

def MemberDefinitionUtil_ToEvent(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToEvent(t)

def MemberDefinitionUtil_ToPipe(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToPipe(t)

def MemberDefinitionUtil_ToCallback(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToCallback(t)

def MemberDefinitionUtil_ToWire(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToWire(t)

def MemberDefinitionUtil_ToMemory(t):
    return _RobotRaconteurPython.MemberDefinitionUtil_ToMemory(t)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class Transport(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetUrlSchemeString(self):
        return _RobotRaconteurPython.Transport_GetUrlSchemeString(self)

    @staticmethod
    def GetCurrentTransportConnectionURL():
        return _RobotRaconteurPython.Transport_GetCurrentTransportConnectionURL()

    def GetServerListenUrls(self):
        return _RobotRaconteurPython.Transport_GetServerListenUrls(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_Transport

# Register Transport in _RobotRaconteurPython:
_RobotRaconteurPython.Transport_swigregister(Transport)

def Transport_GetCurrentTransportConnectionURL():
    return _RobotRaconteurPython.Transport_GetCurrentTransportConnectionURL()

IPNodeDiscoveryFlags_NODE_LOCAL = _RobotRaconteurPython.IPNodeDiscoveryFlags_NODE_LOCAL
IPNodeDiscoveryFlags_LINK_LOCAL = _RobotRaconteurPython.IPNodeDiscoveryFlags_LINK_LOCAL
IPNodeDiscoveryFlags_SITE_LOCAL = _RobotRaconteurPython.IPNodeDiscoveryFlags_SITE_LOCAL
IPNodeDiscoveryFlags_IPV4_BROADCAST = _RobotRaconteurPython.IPNodeDiscoveryFlags_IPV4_BROADCAST
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TcpTransport(Transport):
    r"""

    Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks

    It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
    be used to construct this class.

    See \ref robotraconteur_url for more information on URLs.

    The TcpTransport implements transport connections over TCP/IP networks. TCP/IP is the 
    most common protocol used for Internet and Local Area Network (LAN) communication, including
    Ethernet and WiFi connections. The Transport Control Protocol (TCP) is a reliable stream
    protocol that establishes connections between devices using IP address and port pairs.
    Each adapter has an assigned address, and applications create connections on different ports.
    TcpTransport listens to the port specified in StartServer(), and the client uses
    a URL containing the IP address and port of the listening transport. The TcpTransport
    uses the established connection to pass messages between nodes.

    The IP protocol is available in two major versions, IPv4 and IPv6. The most common
    is IPv4, and its 32 bit address is typically written as four numbers, 
    ie 172.17.12.174. IPv4 has a number of critical limitations, the greatest being 
    its 2^32 address limit (approximately 4 billion). This is a problem when there are 
    tens of billions of internet connected devices already present. IPv6 introduces a 128 
    bit address space, which allows for approximately 3.4x10^38 possible addresses. The major
    advantage for Robot Raconteur is the introduction of "link-local" addresses. These addresses
    begin with "FE80::" and finish with an "EUI-64" address, which is tied to the MAC address
    of the adaptor. IPv4 addresses need to be assigned to devices locally, and have a tendency
    to change. IPv6 addresses are permanently assigned to the adapter itself, meaning that
    network configuration for LAN communication is essentially automatic. Robot Raconteur
    will prefer IPv6 connections when possible for this reason.

    The TcpTransport is capable of using "raw" streams that implement the Robot Raconteur
    message protocols, or to use HTTP WebSockets. HTTP WebSockets allow Robot Raconteur
    to communicate seamlessly with browsers and HTTP servers without requiring
    additional plugins. WebSockets provide additional security using "origins". See
    AddWebSocketAllowedOrigin() for more information.

    The TcpTransport supports TLS encryption using certificates. See \ref tls_security for
    more information on TLS. The TcpTransport supports four modes of TLS encryption:

    ======= ============================================ ===========
    Scheme  Description                                  Direction
    ======= ============================================ ===========
    rrs+tcp "Raw" protocol with TLS                      Both
    rr+wss  Websocket over HTTPS                         Client Only
    rrs+ws  Websocket with RobotRaconteur TLS over HTTP  Both
    rrs+wss Websocket with RobotRaconteur TLS over HTTPS Client Only
    ======= ============================================ ===========

    The different combinations of TLS and HTTPS for websockets are used for different scenarios.
    Robot Raconteur Core can initiate HTTPS connections, but cannot accept them. Accepting
    HTTPS connections requires a certificate issued by an authority like GoDaddy or Digicert, 
    and is typically used with an HTTP server running RobotRaconteurWeb.

    TLS certificates for Robot Raconteur nodes are issued by Wason Technology, LLC using
    a root certificate that is "burned in" to Robot Raconteur Core. All devices running
    Robot Raconteur will support this certificate chain.

    Discovery for the TcpTransport is accomplished using User Defined Protocol (UDP) multicast
    and/or broadcast packets. Broadcast packets are sent to all connected devices, while
    multicast is sent to devices that have registered to receive them. Unlike TCP, the packets
    sent to broadcast or multicast are sent to the entire network. This allows for devices
    to find each other on the network. 

    For IPv4, the broadcast address 255.255.255.255 on port 48653
    is used for discovery. By default, IPv4 is disabled in favor of IPv6. IPv6 uses the multicast 
    following multicast addresses:

    ========== ========== ===== ========
    Address    Scope      Port  Default?
    ========== ========== ===== ========
    FF01::BA86 Node-Local 48653 Disabled
    FF02::BA86 Link-Local 48653 Enabled
    FF05::BA86 Site-Local 48653 Disabled
    ========== ========== ===== ========

    By default, discovery will only occur on the link-local IPv6 scope. This will
    find nodes on the local subnet, but will not attempt to pass through any routers.

    The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
    transports.

    The transport must be registered with the node using
    RobotRaconteurNode.RegisterTransport() after construction if node
    setup is not used.

    :param node: (optional) The node that will use the transport. Default is the singleton node
    :type node: RobotRaconteur.RobotRaconteurNode

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.TcpTransport_swiginit(self, _RobotRaconteurPython.new_TcpTransport(*args))

    def _GetDefaultReceiveTimeout(self):
        return _RobotRaconteurPython.TcpTransport__GetDefaultReceiveTimeout(self)

    def _SetDefaultReceiveTimeout(self, milliseconds):
        return _RobotRaconteurPython.TcpTransport__SetDefaultReceiveTimeout(self, milliseconds)

    def _GetDefaultConnectTimeout(self):
        return _RobotRaconteurPython.TcpTransport__GetDefaultConnectTimeout(self)

    def _SetDefaultConnectTimeout(self, milliseconds):
        return _RobotRaconteurPython.TcpTransport__SetDefaultConnectTimeout(self, milliseconds)

    def _GetDefaultHeartbeatPeriod(self):
        return _RobotRaconteurPython.TcpTransport__GetDefaultHeartbeatPeriod(self)

    def _SetDefaultHeartbeatPeriod(self, milliseconds):
        return _RobotRaconteurPython.TcpTransport__SetDefaultHeartbeatPeriod(self, milliseconds)

    def GetUrlSchemeString(self):
        return _RobotRaconteurPython.TcpTransport_GetUrlSchemeString(self)

    def GetServerListenUrls(self):
        return _RobotRaconteurPython.TcpTransport_GetServerListenUrls(self)

    def GetListenPort(self):
        return _RobotRaconteurPython.TcpTransport_GetListenPort(self)

    def StartServer(self, porte, localhost_only=False):
        return _RobotRaconteurPython.TcpTransport_StartServer(self, porte, localhost_only)

    def Close(self):
        r"""

        Close the transport. Done automatically by node shutdown.

        """
        return _RobotRaconteurPython.TcpTransport_Close(self)

    def EnableNodeDiscoveryListening(self, *args):
        r"""

        Enable node discovery listening

        By default enables listining on IPv6 link-local scope

        See IPNodeDiscoveryFlags constants

        :param flags: The flags specifying the scope
        :type flags: int

        """
        return _RobotRaconteurPython.TcpTransport_EnableNodeDiscoveryListening(self, *args)

    def DisableNodeDiscoveryListening(self):
        r"""

        Disable node discovery listening

        """
        return _RobotRaconteurPython.TcpTransport_DisableNodeDiscoveryListening(self)

    def EnableNodeAnnounce(self, *args):
        r"""

        Enable node discovery announce

        By default enables announce on IPv6 link-local scope

        See IPNodeDiscoveryFlags constants

        :param flags: The flags specifying the scope
        :type flags: int

        """
        return _RobotRaconteurPython.TcpTransport_EnableNodeAnnounce(self, *args)

    def DisableNodeAnnounce(self):
        r"""

        Disable node discovery announce

        """
        return _RobotRaconteurPython.TcpTransport_DisableNodeAnnounce(self)

    def _GetNodeAnnouncePeriod(self):
        return _RobotRaconteurPython.TcpTransport__GetNodeAnnouncePeriod(self)

    def _SetNodeAnnouncePeriod(self, millis):
        return _RobotRaconteurPython.TcpTransport__SetNodeAnnouncePeriod(self, millis)

    def _GetMaxMessageSize(self):
        return _RobotRaconteurPython.TcpTransport__GetMaxMessageSize(self)

    def _SetMaxMessageSize(self, size):
        return _RobotRaconteurPython.TcpTransport__SetMaxMessageSize(self, size)

    def _GetMaxConnectionCount(self):
        return _RobotRaconteurPython.TcpTransport__GetMaxConnectionCount(self)

    def _SetMaxConnectionCount(self, count):
        return _RobotRaconteurPython.TcpTransport__SetMaxConnectionCount(self, count)

    def _GetRequireTls(self):
        return _RobotRaconteurPython.TcpTransport__GetRequireTls(self)

    def _SetRequireTls(self, require_tls):
        return _RobotRaconteurPython.TcpTransport__SetRequireTls(self, require_tls)

    def LoadTlsNodeCertificate(self):
        return _RobotRaconteurPython.TcpTransport_LoadTlsNodeCertificate(self)

    def _IsTlsNodeCertificateLoaded(self):
        return _RobotRaconteurPython.TcpTransport__IsTlsNodeCertificateLoaded(self)

    def _IsTransportConnectionSecure(self, *args):
        return _RobotRaconteurPython.TcpTransport__IsTransportConnectionSecure(self, *args)

    def _IsSecurePeerIdentityVerified(self, *args):
        return _RobotRaconteurPython.TcpTransport__IsSecurePeerIdentityVerified(self, *args)

    def _GetSecurePeerIdentity(self, *args):
        return _RobotRaconteurPython.TcpTransport__GetSecurePeerIdentity(self, *args)

    def StartServerUsingPortSharer(self):
        return _RobotRaconteurPython.TcpTransport_StartServerUsingPortSharer(self)

    def _IsPortSharerRunning(self):
        return _RobotRaconteurPython.TcpTransport__IsPortSharerRunning(self)

    def _GetAcceptWebSockets(self):
        return _RobotRaconteurPython.TcpTransport__GetAcceptWebSockets(self)

    def _SetAcceptWebSockets(self, value):
        return _RobotRaconteurPython.TcpTransport__SetAcceptWebSockets(self, value)

    def GetWebSocketAllowedOrigins(self):
        return _RobotRaconteurPython.TcpTransport_GetWebSocketAllowedOrigins(self)

    def AddWebSocketAllowedOrigin(self, origin):
        return _RobotRaconteurPython.TcpTransport_AddWebSocketAllowedOrigin(self, origin)

    def RemoveWebSocketAllowedOrigin(self, origin):
        return _RobotRaconteurPython.TcpTransport_RemoveWebSocketAllowedOrigin(self, origin)

    def _GetDisableMessage4(self):
        return _RobotRaconteurPython.TcpTransport__GetDisableMessage4(self)

    def _SetDisableMessage4(self, d):
        return _RobotRaconteurPython.TcpTransport__SetDisableMessage4(self, d)

    def _GetDisableStringTable(self):
        return _RobotRaconteurPython.TcpTransport__GetDisableStringTable(self)

    def _SetDisableStringTable(self, d):
        return _RobotRaconteurPython.TcpTransport__SetDisableStringTable(self, d)

    def _GetDisableAsyncMessageIO(self):
        return _RobotRaconteurPython.TcpTransport__GetDisableAsyncMessageIO(self)

    def _SetDisableAsyncMessageIO(self, d):
        return _RobotRaconteurPython.TcpTransport__SetDisableAsyncMessageIO(self, d)

    @staticmethod
    def GetLocalAdapterIPAddresses():
        return _RobotRaconteurPython.TcpTransport_GetLocalAdapterIPAddresses()

    DefaultReceiveTimeout = property(lambda self: self._GetDefaultReceiveTimeout()/1000.0, lambda self, timeout: self._SetDefaultReceiveTimeout(timeout*1000),
    	doc = """
    	Set the default receive timeout in seconds

    	If no messages are received within the timeout, the connection
    	is assumed to be lost.

    	Default: 15 seconds

    	:rtype: float
    	""")
    DefaultConnectTimeout = property(lambda self: self._GetDefaultConnectTimeout()/1000.0, lambda self, timeout: self._SetDefaultConnectTimeout(timeout*1000),
    	doc = """
    	Set the default connect timeout in seconds

    	If the connection is not completed within the timeout, the connection
    	attempt will be aborted.

    	Default: 5 seconds

    	:rtype: float
    	"""
    )
    DefaultHeartbeatPeriod = property(lambda self: self._GetDefaultHeartbeatPeriod()/1000.0, lambda self, timeout: self._SetDefaultHeartbeatPeriod(timeout*1000),
    	doc = """
    	Set the default heartbeat period in seconds

    	The heartbeat is used to keep the connection alive
    	if no communication is occuring between nodes.

    	Default: 5 seconds

    	:rtype: float
    	"""
    )
    MaxMessageSize = property(lambda self: self._GetMaxMessageSize(), lambda self, size: self._SetMaxMessageSize(size),
    	doc = """
    	Set the maximum serialized message size

    	Default: 10 MB

    	:rtype: int
    	""")
    MaxConnectionCount = property(lambda self: self._GetMaxConnectionCount(), lambda self, count: self._SetMaxConnectionCount(count),
    	doc = """
    	Set the maximum number of concurrent connections

    	Default: 0 for unlimited

    	:rtype: int
    	""")
    RequireTls = property(lambda self: self._GetRequireTls(), lambda self, val: self._SetRequireTls(val),
    	doc = """
    	Set if all connections require TLS

    	If true, all connections require TLS

    	:rtype: bool
    	""")
    IsTlsNodeCertificateLoaded = property(lambda self: self._IsTlsNodeCertificateLoaded(),
    	doc = """
    Check if TLS certificate is loaded

    :rtype: bool
    """)
    AcceptWebSockets = property(lambda self: self._GetAcceptWebSockets(), lambda self, val: self._SetAcceptWebSockets(val),
    	doc = """
    	Set if the transport will accept incoming HTTP websocket connections

    	Default: true

    	:rtype: bool
    	""")
    DisableMessage4 = property(lambda self: self._GetDisableMessage4(), lambda self, val: self._SetDisableMessage4(val),
    	doc = """
    	Set disable Message Format Version 4

    	Message Format Version 2 will be used

    	Default: Message V4 is enabled

    	:rtype: bool
    	""")
    DisableStringTable = property(lambda self: self._GetDisableStringTable(), lambda self, val: self._SetDisableStringTable(val),
    	doc = """
    	Set disable string table

    	Default: false

    	RobotRaconteurNodeSetup and its subclasses
    	will disable the string table by default

    	:rtype: bool
    	""")

    DisableAsyncMessageIO = property(lambda self: self._GetDisableAsyncMessageIO(), lambda self, val: self._SetDisableAsyncMessageIO(val),
    	doc = """
    	Set if async message io is disabled

    	Async message io has better memory handling, at the
    	expense of slightly higher latency.

    	Default: Async io enabled

    	:rtype: bool
    	""")

    NodeAnnouncePeriod = property(lambda self: self._GetNodeAnnouncePeriod()/1000.0, lambda self, timeout: self._SetNodeAnnouncePeriod(timeout*1000),
    	doc = """
    	Set the period between node announce in seconds

    	Default 55 seconds

    	:rtype: float
    	"""

    )

    def IsTransportConnectionSecure(self,obj):
    	"""
    	Check if specified client or endpoint is using TLS for its transport

    	Throws ConnectionException if the client or endpoint is invalid or the connection
    	is not using TcpTransport

    	:param obj: The client or endpoint to check
    	:return: True The connection is using TLS, otherwise False
    	:rtype: bool
    	"""
    	if (hasattr(obj,'rrinnerstub')):
    		obj=obj.rrinnerstub
    	return self._IsTransportConnectionSecure(obj)

    def IsSecurePeerIdentityVerified(self,obj):
    	"""
    	Check if specified peer is using TLS and has been
    	verified using a certificate

    	Checks if the peer server node has a valid certificate, or if the peer client
    	has been verified using mutual authentication.

    	Throws ConnectionException if the endpoint is invalid or the connection
    	is not using TcpTransport

    	:param obj: The client or endpoint to check
    	:return: True The connection is using TLS, otherwise False
    	:rtype: bool
    	"""
    	if (hasattr(obj,'rrinnerstub')):
    		obj=obj.rrinnerstub
    	return self._IsSecurePeerIdentityVerified(obj)

    def GetSecurePeerIdentity(self,obj):
    	"""
    	Get the identity of the peer if secured using TLS

    	Get the identity of a peer verified using TLS certificates. Returns a NodeID in string
    	format. Will throw AuthenticationException if the peer has not been verified.

    	:param obj: The client or endpoint to check
    	:return: The verified peer NodeID as a string
    	:rtype: str
    	"""
    	if (hasattr(obj,'rrinnerstub')):
    		obj=obj.rrinnerstub
    	return self._GetSecurePeerIdentity(obj)

    __swig_destroy__ = _RobotRaconteurPython.delete_TcpTransport

# Register TcpTransport in _RobotRaconteurPython:
_RobotRaconteurPython.TcpTransport_swigregister(TcpTransport)

def TcpTransport_GetLocalAdapterIPAddresses():
    return _RobotRaconteurPython.TcpTransport_GetLocalAdapterIPAddresses()

@_swig_add_metaclass(_SwigNonDynamicMeta)
class LocalTransport(Transport):
    r"""

    Transport for communication between processes using UNIX domain sockets

    It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
    be used to construct this class.

    See \ref robotraconteur_url for more information on URLs.

    The LocalTransport implements transport connections between processes running on the
    same host operating system using UNIX domain sockets. UNIX domain sockets are similar
    to standard networking sockets, but are used when both peers are on the same machine
    instead of connected through a network. This provides faster operation and greater
    security, since the kernel simply passes data between the processes. UNIX domain
    sockets work using Information Node (inode) files, which are special files on
    the standard filesystem. Servers "listen" on a specified inode, and clients
    use the inode as the address to connect. The LocalTransport uses UNIX sockets
    in `SOCK_STREAM` mode. This provides a reliable stream transport connection similar
    to TCP, but with significantly improved performance due the lower overhead.

    UNIX domain sockets were added to Windows 10 with the 1803 update. Robot Raconteur
    switch to UNIX domain sockets for the LocalTransport on Windows in version 0.9.2.
    Previous versions used Named Pipes, but these were inferior to UNIX sockets. The
    LocalTransport will not function on versions of Windows prior to Windows 10 1803 update
    due to the lack of support for UNIX sockets. A warning will be issued to the log if 
    the transport is not available, and all connection attempts will fail. All other
    transports will continue to operate normally.

    The LocalTransport stores inode and node information files in the filesystem at various
    operator system dependent locations. See the Robot Raconteur Standards documents
    for details on where these files are stored.

    Discovery is implemented using file watchers. The file watchens must be activated
    using the node setup flags, or by calling EnableNodeDiscoveryListening().
    After being initialized the file watchers operate automatically.

    The LocalTransport can be used to dynamically assign NodeIDs to nodes based on a NodeName.
    StartServerAsNodeName() and StartClientAsNodeName() take a NodeName that will identify the
    node to clients, and manage a system-local NodeID corresponding to that NodeName. The 
    generated NodeIDs are stored on the local filesystem. If LocalTransport finds a corresponding
    NodeID on the filesystem, it will load and use that NodeID. If it does not, a new random NodeID
    is automatically generated.

    The server can be started in "public" or "private" mode. Private servers store their inode and
    information in a location only the account owner can access, while "public" servers are
    placed in a location that all users with the appropriate permissions can access. By default,
    public LocalTransport servers are assigned to the "robotraconteur" group. Clients that belong to the
    "robotraconteur" group will be able to connect to these public servers.

    The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
    transports.

    The transport must be registered with the node using
    RobotRaconteurNode.RegisterTransport() after construction if node
    setup is not used.

    :param node: (optional) The node that will use the transport. Default is the singleton node
    :type node: RobotRaconteur.RobotRaconteurNode

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.LocalTransport_swiginit(self, _RobotRaconteurPython.new_LocalTransport(*args))

    @staticmethod
    def IsLocalTransportSupported():
        r"""

        Check if the LocalTransport is supported on the current
        operating system.

        Windows versions before Windows 10 1803 do not support the LocalTransport
        due to lack of UNIX sockets. All other transports will continue to operate
        normally.

        All versions of Linux and Mac OSX support the LocalTransport

        LocalTransport on Android and iOS is not officially supported

        :return: True LocalTransport is supported, otherwise False
        :rtype: bool

        """
        return _RobotRaconteurPython.LocalTransport_IsLocalTransportSupported()

    def GetUrlSchemeString(self):
        return _RobotRaconteurPython.LocalTransport_GetUrlSchemeString(self)

    def GetServerListenUrls(self):
        return _RobotRaconteurPython.LocalTransport_GetServerListenUrls(self)

    def StartClientAsNodeName(self, name):
        r"""

        Initialize the LocalTransport by assigning a NodeID based on NodeName

        Assigns the specified name to be the NodeName of the node, and manages
        a corresponding NodeID. See LocalTransport for more information.

        Throws NodeNameAlreadyInUse if another node is using name

        :param name: The node name
        :type name: str

        """
        return _RobotRaconteurPython.LocalTransport_StartClientAsNodeName(self, name)

    def StartServerAsNodeName(self, name, public_=False):
        r"""

        StartServerAsNodeName(name, public_ = False)

        Start the server using the specified NodeName and assigns a NodeID

        The LocalTransport will listen on a UNIX domain socket for incoming clients,
        using information files and inodes on the local filesystem. Clients
        can locate the node using the NodeID and/or NodeName. The NodeName is assigned
        to the node, and the transport manages a corresponding NodeID. See
        LocalTransport for more information.

        Throws NodeNameAlreadyInUse if another node is using name

        Throws NodeIDAlreadyInUse if another node is using the managed
        NodeID

        :param name: The NodeName
        :type name: str
        :param public_: If True, other users can access the server. If False, only
          the account owner can access the server.
        :type public_: bool

        """
        return _RobotRaconteurPython.LocalTransport_StartServerAsNodeName(self, name, public_)

    def StartServerAsNodeID(self, nodeid, public_=False):
        r"""

        StartServerAsNodeId(name, public_ = False)

        The LocalTransport will listen on a UNIX domain socket for incoming clients,
        using information files and inodes on the local filesystem. This function
        leaves the NodeName blank, so clients must use NodeID to identify the node.

        Throws NodeIDAlreadyInUse if another node is using nodeid

        :param nodeid: The NodeID
        :type nodeid: RobotRaconteur.NodeID
        :param public_: If True, other users can access the server. If False, only 
         the account owner can access the server.
        :type public_: bool

        """
        return _RobotRaconteurPython.LocalTransport_StartServerAsNodeID(self, nodeid, public_)

    def Close(self):
        r"""

        Close the transport. Done automatically by node shutdown.

        """
        return _RobotRaconteurPython.LocalTransport_Close(self)

    def _GetMaxMessageSize(self):
        return _RobotRaconteurPython.LocalTransport__GetMaxMessageSize(self)

    def _SetMaxMessageSize(self, size):
        return _RobotRaconteurPython.LocalTransport__SetMaxMessageSize(self, size)

    def _GetDisableMessage4(self):
        return _RobotRaconteurPython.LocalTransport__GetDisableMessage4(self)

    def _SetDisableMessage4(self, d):
        return _RobotRaconteurPython.LocalTransport__SetDisableMessage4(self, d)

    def _GetDisableStringTable(self):
        return _RobotRaconteurPython.LocalTransport__GetDisableStringTable(self)

    def _SetDisableStringTable(self, d):
        return _RobotRaconteurPython.LocalTransport__SetDisableStringTable(self, d)

    def _GetDisableAsyncMessageIO(self):
        return _RobotRaconteurPython.LocalTransport__GetDisableAsyncMessageIO(self)

    def _SetDisableAsyncMessageIO(self, d):
        return _RobotRaconteurPython.LocalTransport__SetDisableAsyncMessageIO(self, d)

    def EnableNodeDiscoveryListening(self):
        return _RobotRaconteurPython.LocalTransport_EnableNodeDiscoveryListening(self)

    def DisableNodeDiscoveryListening(self):
        return _RobotRaconteurPython.LocalTransport_DisableNodeDiscoveryListening(self)

    MaxMessageSize = property(lambda self: self._GetMaxMessageSize(), lambda self, size: self._SetMaxMessageSize(size),
    	doc = """
    	Set the maximum serialized message size

    	Default: 10 MB

    	:rtype: int
    	""")
    DisableMessage4 = property(lambda self: self._GetDisableMessage4(), lambda self, val: self._SetDisableMessage4(val),
    	doc = """
    		Set disable Message Format Version 4

    		Message Format Version 2 will be used

    		Default: Message V4 is enabled

    		:rtype: bool
    		""")
    DisableStringTable = property(lambda self: self._GetDisableStringTable(), lambda self, val: self._SetDisableStringTable(val),
    	doc = """
    		Set disable string table

    		Default: false

    		RobotRaconteurNodeSetup and its subclasses
    		will disable the string table by default

    		:rtype: bool
    		""")
    DisableAsyncMessageIO = property(lambda self: self._GetDisableAsyncMessageIO(), lambda self, val: self._SetDisableAsyncMessageIO(val),
    	doc = """
    		Set if async message io is disabled

    		Async message io has better memory handling, at the
    		expense of slightly higher latency.

    		Default: Async io enabled

    		:rtype: bool
    		""")

    __swig_destroy__ = _RobotRaconteurPython.delete_LocalTransport

# Register LocalTransport in _RobotRaconteurPython:
_RobotRaconteurPython.LocalTransport_swigregister(LocalTransport)

def LocalTransport_IsLocalTransportSupported():
    r"""

    Check if the LocalTransport is supported on the current
    operating system.

    Windows versions before Windows 10 1803 do not support the LocalTransport
    due to lack of UNIX sockets. All other transports will continue to operate
    normally.

    All versions of Linux and Mac OSX support the LocalTransport

    LocalTransport on Android and iOS is not officially supported

    :return: True LocalTransport is supported, otherwise False
    :rtype: bool

    """
    return _RobotRaconteurPython.LocalTransport_IsLocalTransportSupported()

@_swig_add_metaclass(_SwigNonDynamicMeta)
class HardwareTransport(Transport):
    r"""

    Transport for USB, Bluetooth, and PCIe hardware devices

    **WARNING: THE HARDWARE TRANSPORT IS EXPERIMENTAL!**

    The HardwareTransport is disabled by default by the node setup classes.
    Use ``--robotraconteur-hardware-enable=true`` option to enable.

    It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
    be used to construct this class.

    See \ref robotraconteur_url for more information on URLs.

    Contact Wason Technology, LLC for more information on the hardware
    transport.

    The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
    transports.

    The transport must be registered with the node using
    RobotRaconteurNode.RegisterTransport() after construction if node
    setup is not used.

    :param node: (optional) The node that will use the transport. Default is the singleton node
    :type node: RobotRaconteur.RobotRaconteurNode

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.HardwareTransport_swiginit(self, _RobotRaconteurPython.new_HardwareTransport(*args))

    def GetUrlSchemeString(self):
        return _RobotRaconteurPython.HardwareTransport_GetUrlSchemeString(self)

    def GetServerListenUrls(self):
        return _RobotRaconteurPython.HardwareTransport_GetServerListenUrls(self)

    def Close(self):
        r"""

        Close the transport. Done automatically by node shutdown.

        """
        return _RobotRaconteurPython.HardwareTransport_Close(self)

    def _GetMaxMessageSize(self):
        return _RobotRaconteurPython.HardwareTransport__GetMaxMessageSize(self)

    def _SetMaxMessageSize(self, size):
        return _RobotRaconteurPython.HardwareTransport__SetMaxMessageSize(self, size)

    def _GetDisableMessage4(self):
        return _RobotRaconteurPython.HardwareTransport__GetDisableMessage4(self)

    def _SetDisableMessage4(self, d):
        return _RobotRaconteurPython.HardwareTransport__SetDisableMessage4(self, d)

    def _GetDisableStringTable(self):
        return _RobotRaconteurPython.HardwareTransport__GetDisableStringTable(self)

    def _SetDisableStringTable(self, d):
        return _RobotRaconteurPython.HardwareTransport__SetDisableStringTable(self, d)

    def _GetDisableAsyncMessageIO(self):
        return _RobotRaconteurPython.HardwareTransport__GetDisableAsyncMessageIO(self)

    def _SetDisableAsyncMessageIO(self, d):
        return _RobotRaconteurPython.HardwareTransport__SetDisableAsyncMessageIO(self, d)

    MaxMessageSize = property(lambda self: self._GetMaxMessageSize(), lambda self, size: self._SetMaxMessageSize(size),
    	doc = """
    	Set the maximum serialized message size

    	Default: 10 MB

    	:rtype: int
    	""")
    DisableMessage4 = property(lambda self: self._GetDisableMessage4(), lambda self, val: self._SetDisableMessage4(val),
        doc = """
    		Set disable Message Format Version 4

    		Message Format Version 2 will be used

    		Default: Message V4 is enabled

    		:rtype: bool
    		""")

    DisableStringTable = property(lambda self: self._GetDisableStringTable(), lambda self, val: self._SetDisableStringTable(val),
    	doc = """
    		Set disable string table

    		Default: false

    		RobotRaconteurNodeSetup and its subclasses
    		will disable the string table by default

    		:rtype: bool
    		""")
    DisableAsyncMessageIO = property(lambda self: self._GetDisableAsyncMessageIO(), lambda self, val: self._SetDisableAsyncMessageIO(val),
    	doc = """
    		Set if async message io is disabled

    		Async message io has better memory handling, at the
    		expense of slightly higher latency.

    		Default: Async io enabled

    		:rtype: bool
    		""")

    __swig_destroy__ = _RobotRaconteurPython.delete_HardwareTransport

# Register HardwareTransport in _RobotRaconteurPython:
_RobotRaconteurPython.HardwareTransport_swigregister(HardwareTransport)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class IntraTransport(Transport):
    r"""

    Transport for intra-process communication

    It is recommended that ClientNodeSetup, ServerNodeSetup, or SecureServerNodeSetup
    be used to construct this class.

    See \ref robotraconteur_url for more information on URLs.

    The IntraTransport implements transport connections between nodes running
    within the same process. This is often true for simulation environments, where
    there may be multiple simulated devices running within the simulation. The
    IntraTransport uses a singleton to keep track of the different nodes running
    in the same process, and to form connections. The singleton also implements
    discovery updates.

    The use of RobotRaconteurNodeSetup and subclasses is recommended to construct
    transports.

    The transport must be registered with the node using
    RobotRaconteurNode.RegisterTransport() after construction if node
    setup is not used.

    :param node: (optional) The node that will use the transport. Default is the singleton node
    :type node: RobotRaconteur.RobotRaconteurNode

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.IntraTransport_swiginit(self, _RobotRaconteurPython.new_IntraTransport(*args))

    def GetUrlSchemeString(self):
        return _RobotRaconteurPython.IntraTransport_GetUrlSchemeString(self)

    def GetServerListenUrls(self):
        return _RobotRaconteurPython.IntraTransport_GetServerListenUrls(self)

    def Close(self):
        r"""

        Close the transport. Done automatically by node shutdown.

        """
        return _RobotRaconteurPython.IntraTransport_Close(self)

    def StartClient(self):
        r"""Start the transport as a client"""
        return _RobotRaconteurPython.IntraTransport_StartClient(self)

    def StartServer(self):
        r"""Start the server to listen for incoming client connections"""
        return _RobotRaconteurPython.IntraTransport_StartServer(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_IntraTransport

# Register IntraTransport in _RobotRaconteurPython:
_RobotRaconteurPython.IntraTransport_swigregister(IntraTransport)

class TimerEvent(object):
    r"""

    Timer event structure

    Contains information about the state of the timer. Passed to the
    callback on invocation.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    stopped = property(_RobotRaconteurPython.TimerEvent_stopped_get, doc=r"""

    True if timer has been stopped

    :rtype: bool

    """)
    last_expected = property(_RobotRaconteurPython.TimerEvent_last_expected_get, doc=r"""

    The last expected callback invocation time

    :rtype: datetime.datetime

    """)
    last_real = property(_RobotRaconteurPython.TimerEvent_last_real_get, doc=r"""

    The real last callback invocation time

    :rtype: datetime.datetime

    """)
    current_expected = property(_RobotRaconteurPython.TimerEvent_current_expected_get, doc=r"""

    The current expected invocation time

    :rtype: datetime.datetime

    """)
    current_real = property(_RobotRaconteurPython.TimerEvent_current_real_get, doc=r"""

    The current invocation time

    :rtype: datetime.datetime

    """)

    def __init__(self):
        _RobotRaconteurPython.TimerEvent_swiginit(self, _RobotRaconteurPython.new_TimerEvent())
    __swig_destroy__ = _RobotRaconteurPython.delete_TimerEvent

# Register TimerEvent in _RobotRaconteurPython:
_RobotRaconteurPython.TimerEvent_swigregister(TimerEvent)

class AsyncTimerEventReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncTimerEventReturnDirector

    def handler(self, ret, error):
        return _RobotRaconteurPython.AsyncTimerEventReturnDirector_handler(self, ret, error)

    def __init__(self):
        if self.__class__ == AsyncTimerEventReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncTimerEventReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncTimerEventReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncTimerEventReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncTimerEventReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncTimerEventReturnDirector_swigregister(AsyncTimerEventReturnDirector)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class Timer(object):
    r"""


    A timer to invoke a callback

    Timers invoke a callback at a specified rate. The timer
    can either be one-short, or repeating.

    Use RobotRaconteurNode.CreateTimer() to create timers.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Start(self):
        r"""

        Start the timer

        Must be called after RobotRaconteurNode.CreateTimer()

        """
        return _RobotRaconteurPython.Timer_Start(self)

    def Stop(self):
        r"""

        Stop the timer

        """
        return _RobotRaconteurPython.Timer_Stop(self)

    def GetPeriod(self):
        r"""

        Get the period of the timer in seconds

        :rtype: float

        """
        return _RobotRaconteurPython.Timer_GetPeriod(self)

    def SetPeriod(self, period):
        r"""

        Set the period of the timer in seconds

        :param period: Period in seconds
        :type period: float

        """
        return _RobotRaconteurPython.Timer_SetPeriod(self, period)

    def IsRunning(self):
        r"""

        Get if the timer is running

        :rtype: bool

        """
        return _RobotRaconteurPython.Timer_IsRunning(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_Timer

# Register Timer in _RobotRaconteurPython:
_RobotRaconteurPython.Timer_swigregister(Timer)

class WallTimer(Timer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Start(self):
        r"""

        Start the timer

        Must be called after RobotRaconteurNode.CreateTimer()

        """
        return _RobotRaconteurPython.WallTimer_Start(self)

    def Stop(self):
        r"""

        Stop the timer

        """
        return _RobotRaconteurPython.WallTimer_Stop(self)

    def GetPeriod(self):
        r"""

        Get the period of the timer in seconds

        :rtype: float

        """
        return _RobotRaconteurPython.WallTimer_GetPeriod(self)

    def SetPeriod(self, period):
        r"""

        Set the period of the timer in seconds

        :param period: Period in seconds
        :type period: float

        """
        return _RobotRaconteurPython.WallTimer_SetPeriod(self, period)

    def IsRunning(self):
        r"""

        Get if the timer is running

        :rtype: bool

        """
        return _RobotRaconteurPython.WallTimer_IsRunning(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WallTimer

    def __init__(self,*args):
    #This is a shadowed function

    	from .RobotRaconteurPythonUtil import AsyncTimerEventReturnDirectorImpl

    	if (not hasattr(args[1], '__call__')): raise Exception("Handler must be callable")
    	director=AsyncTimerEventReturnDirectorImpl(args[1])

    	oneshot=False

    	if (len(args) > 2):
    		oneshot=args[2]

    	if (len(args) > 3):
    		node=args[3]
    	else:
    		node=RobotRaconteurNode.s

    	this = _RobotRaconteurPython.new_WallTimer(args[0],oneshot,node,director,0)
    	director.__disown__()
    	try: self.this.append(this)
    	except: self.this = this



# Register WallTimer in _RobotRaconteurPython:
_RobotRaconteurPython.WallTimer_swigregister(WallTimer)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class Rate(object):
    r"""

    Rate to stabilize a loop

    Rate is used to stabilize the period of a loop. Use
    RobotRaconteur.CreateRate() to create rates.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Sleep(self):
        r"""

        Sleep the calling thread until the current loop period expires

        """
        return _RobotRaconteurPython.Rate_Sleep(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_Rate

# Register Rate in _RobotRaconteurPython:
_RobotRaconteurPython.Rate_swigregister(Rate)

class WallRate(Rate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.WallRate_swiginit(self, _RobotRaconteurPython.new_WallRate(*args))

    def Sleep(self):
        r"""

        Sleep the calling thread until the current loop period expires

        """
        return _RobotRaconteurPython.WallRate_Sleep(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WallRate

# Register WallRate in _RobotRaconteurPython:
_RobotRaconteurPython.WallRate_swigregister(WallRate)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class AutoResetEvent(object):
    r"""

    Synchronization event for thread synchronization. Resets automatically after
    being triggered

    Construct using RobotRaconteurNode.CreateAutoResetEvent()

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        _RobotRaconteurPython.AutoResetEvent_swiginit(self, _RobotRaconteurPython.new_AutoResetEvent())
    __swig_destroy__ = _RobotRaconteurPython.delete_AutoResetEvent

    def Set(self):
        r"""

        Set the event, releasing waiting threads

        """
        return _RobotRaconteurPython.AutoResetEvent_Set(self)

    def Reset(self):
        r"""

        Reset the event

        """
        return _RobotRaconteurPython.AutoResetEvent_Reset(self)

    def WaitOne(self, *args):
        r"""

        WaitOne(timeout=0)

        Block the current thread until Set() is called, or timeout
        expires

        Timeout is based on the RobotRaconteurNode time provider

        :param timeout: The timeout in seconds
        :type timeout: float
        :return: True if event was set, False if not
        :rtype: bool

        """
        return _RobotRaconteurPython.AutoResetEvent_WaitOne(self, *args)

# Register AutoResetEvent in _RobotRaconteurPython:
_RobotRaconteurPython.AutoResetEvent_swigregister(AutoResetEvent)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class TimeSpec(object):
    r"""

    TimeSpec(seconds=0,nanoseconds=0)

    Represents. a point in time. Used by "wire" members to 
    timestamp packets

    Time is always in UTC

    Time is relative to the UNIX epoch "1970-01-01T00:00:00Z"

    :param seconds: seconds from epoch
    :type seconds: int
    :param nanoseconds: nanoseconds from epoch
    :type nanoseconds: int

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __str__(self):
    	return str(self.seconds + (self.nanoseconds * 1.0e-9))

    seconds = property(_RobotRaconteurPython.TimeSpec_seconds_get, _RobotRaconteurPython.TimeSpec_seconds_set, doc=r"""

    Seconds since epoch

    """)
    nanoseconds = property(_RobotRaconteurPython.TimeSpec_nanoseconds_get, _RobotRaconteurPython.TimeSpec_nanoseconds_set, doc=r"""

    Nanoseconds from epoch. Normalized to be between 0 and 1e9-1

    """)

    def __init__(self, *args):
        _RobotRaconteurPython.TimeSpec_swiginit(self, _RobotRaconteurPython.new_TimeSpec(*args))

    def __eq__(self, t2):
        r"""equality comparison"""
        return _RobotRaconteurPython.TimeSpec___eq__(self, t2)

    def __ne__(self, t2):
        r"""inequality comparison"""
        return _RobotRaconteurPython.TimeSpec___ne__(self, t2)

    def __sub__(self, t2):
        r"""subtraction operator"""
        return _RobotRaconteurPython.TimeSpec___sub__(self, t2)

    def __add__(self, t2):
        r"""addition operator"""
        return _RobotRaconteurPython.TimeSpec___add__(self, t2)

    def __gt__(self, t2):
        r"""greater-than comparison"""
        return _RobotRaconteurPython.TimeSpec___gt__(self, t2)

    def __ge__(self, t2):
        r"""greater-than-or-equal comparison"""
        return _RobotRaconteurPython.TimeSpec___ge__(self, t2)

    def __lt__(self, t2):
        r"""less-then comparison"""
        return _RobotRaconteurPython.TimeSpec___lt__(self, t2)

    def __le__(self, t2):
        r"""less-than-or-equal comparison"""
        return _RobotRaconteurPython.TimeSpec___le__(self, t2)

    def cleanup_nanosecs(self):
        r"""normalize nanoseconds to be within 0 and 1e9-1"""
        return _RobotRaconteurPython.TimeSpec_cleanup_nanosecs(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_TimeSpec

# Register TimeSpec in _RobotRaconteurPython:
_RobotRaconteurPython.TimeSpec_swigregister(TimeSpec)

class WrappedService_typed_packet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    packet = property(_RobotRaconteurPython.WrappedService_typed_packet_packet_get, _RobotRaconteurPython.WrappedService_typed_packet_packet_set)
    type = property(_RobotRaconteurPython.WrappedService_typed_packet_type_get, _RobotRaconteurPython.WrappedService_typed_packet_type_set)
    stub = property(_RobotRaconteurPython.WrappedService_typed_packet_stub_get, _RobotRaconteurPython.WrappedService_typed_packet_stub_set)
    client = property(_RobotRaconteurPython.WrappedService_typed_packet_client_get, _RobotRaconteurPython.WrappedService_typed_packet_client_set)

    def __init__(self):
        _RobotRaconteurPython.WrappedService_typed_packet_swiginit(self, _RobotRaconteurPython.new_WrappedService_typed_packet())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedService_typed_packet

# Register WrappedService_typed_packet in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedService_typed_packet_swigregister(WrappedService_typed_packet)

class WrappedPipeEndpointDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeEndpointDirector

    def PipeEndpointClosedCallback(self):
        return _RobotRaconteurPython.WrappedPipeEndpointDirector_PipeEndpointClosedCallback(self)

    def PacketReceivedEvent(self):
        return _RobotRaconteurPython.WrappedPipeEndpointDirector_PacketReceivedEvent(self)

    def PacketAckReceivedEvent(self, packetnum):
        return _RobotRaconteurPython.WrappedPipeEndpointDirector_PacketAckReceivedEvent(self, packetnum)

    def __init__(self):
        if self.__class__ == WrappedPipeEndpointDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPipeEndpointDirector_swiginit(self, _RobotRaconteurPython.new_WrappedPipeEndpointDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPipeEndpointDirector(self)
        return weakref.proxy(self)

# Register WrappedPipeEndpointDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeEndpointDirector_swigregister(WrappedPipeEndpointDirector)

class AsyncPipeEndpointReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncPipeEndpointReturnDirector

    def handler(self, ep, error):
        return _RobotRaconteurPython.AsyncPipeEndpointReturnDirector_handler(self, ep, error)

    def __init__(self):
        if self.__class__ == AsyncPipeEndpointReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncPipeEndpointReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncPipeEndpointReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncPipeEndpointReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncPipeEndpointReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncPipeEndpointReturnDirector_swigregister(AsyncPipeEndpointReturnDirector)

class WrappedTryReceivePacketWaitResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    res = property(_RobotRaconteurPython.WrappedTryReceivePacketWaitResult_res_get, _RobotRaconteurPython.WrappedTryReceivePacketWaitResult_res_set)
    packet = property(_RobotRaconteurPython.WrappedTryReceivePacketWaitResult_packet_get, _RobotRaconteurPython.WrappedTryReceivePacketWaitResult_packet_set)

    def __init__(self):
        _RobotRaconteurPython.WrappedTryReceivePacketWaitResult_swiginit(self, _RobotRaconteurPython.new_WrappedTryReceivePacketWaitResult())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedTryReceivePacketWaitResult

# Register WrappedTryReceivePacketWaitResult in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedTryReceivePacketWaitResult_swigregister(WrappedTryReceivePacketWaitResult)

class WrappedPipeEndpoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SendPacket(self, packet):
        return _RobotRaconteurPython.WrappedPipeEndpoint_SendPacket(self, packet)

    def ReceivePacket(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_ReceivePacket(self)

    def PeekNextPacket(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_PeekNextPacket(self)

    def ReceivePacketWait(self, *args):
        return _RobotRaconteurPython.WrappedPipeEndpoint_ReceivePacketWait(self, *args)

    def PeekNextPacketWait(self, *args):
        return _RobotRaconteurPython.WrappedPipeEndpoint_PeekNextPacketWait(self, *args)

    def TryReceivePacketWait(self, *args):
        return _RobotRaconteurPython.WrappedPipeEndpoint_TryReceivePacketWait(self, *args)

    def Close(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_Close(self)

    def GetIndex(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_GetIndex(self)

    def GetEndpoint(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_GetEndpoint(self)

    def Available(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_Available(self)

    def GetRequestPacketAck(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_GetRequestPacketAck(self)

    def SetRequestPacketAck(self, v):
        return _RobotRaconteurPython.WrappedPipeEndpoint_SetRequestPacketAck(self, v)
    Type = property(_RobotRaconteurPython.WrappedPipeEndpoint_Type_get, _RobotRaconteurPython.WrappedPipeEndpoint_Type_set)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedPipeEndpoint_SetRRDirector(self, director, id)

    def IsUnreliable(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_IsUnreliable(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_Direction(self)

    def AsyncSendPacket(self, packet, handler, id):
        return _RobotRaconteurPython.WrappedPipeEndpoint_AsyncSendPacket(self, packet, handler, id)

    def AsyncClose(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedPipeEndpoint_AsyncClose(self, timeout, handler, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_GetNode(self)

    def GetIgnoreReceived(self):
        return _RobotRaconteurPython.WrappedPipeEndpoint_GetIgnoreReceived(self)

    def SetIgnoreReceived(self, ignore):
        return _RobotRaconteurPython.WrappedPipeEndpoint_SetIgnoreReceived(self, ignore)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeEndpoint

# Register WrappedPipeEndpoint in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeEndpoint_swigregister(WrappedPipeEndpoint)

class WrappedPipeClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Connect(self, index):
        return _RobotRaconteurPython.WrappedPipeClient_Connect(self, index)

    def AsyncConnect(self, index, timeout, handler, id):
        return _RobotRaconteurPython.WrappedPipeClient_AsyncConnect(self, index, timeout, handler, id)

    def GetMemberName(self):
        return _RobotRaconteurPython.WrappedPipeClient_GetMemberName(self)
    Type = property(_RobotRaconteurPython.WrappedPipeClient_Type_get, _RobotRaconteurPython.WrappedPipeClient_Type_set)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedPipeClient_GetNode(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedPipeClient_Direction(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeClient

# Register WrappedPipeClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeClient_swigregister(WrappedPipeClient)

class WrappedPipeServerConnectDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeServerConnectDirector

    def PipeConnectCallback(self, pipeendpoint):
        return _RobotRaconteurPython.WrappedPipeServerConnectDirector_PipeConnectCallback(self, pipeendpoint)

    def __init__(self):
        if self.__class__ == WrappedPipeServerConnectDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPipeServerConnectDirector_swiginit(self, _RobotRaconteurPython.new_WrappedPipeServerConnectDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPipeServerConnectDirector(self)
        return weakref.proxy(self)

# Register WrappedPipeServerConnectDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeServerConnectDirector_swigregister(WrappedPipeServerConnectDirector)

class WrappedPipeServer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetMemberName(self):
        return _RobotRaconteurPython.WrappedPipeServer_GetMemberName(self)
    Type = property(_RobotRaconteurPython.WrappedPipeServer_Type_get, _RobotRaconteurPython.WrappedPipeServer_Type_set)

    def SetWrappedPipeConnectCallback(self, director, id):
        return _RobotRaconteurPython.WrappedPipeServer_SetWrappedPipeConnectCallback(self, director, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedPipeServer_GetNode(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedPipeServer_Direction(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeServer

# Register WrappedPipeServer in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeServer_swigregister(WrappedPipeServer)

class WrappedPipeBroadcasterPredicateDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Predicate(self, client_endpoint, index):
        return _RobotRaconteurPython.WrappedPipeBroadcasterPredicateDirector_Predicate(self, client_endpoint, index)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeBroadcasterPredicateDirector

    def __init__(self):
        if self.__class__ == WrappedPipeBroadcasterPredicateDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPipeBroadcasterPredicateDirector_swiginit(self, _RobotRaconteurPython.new_WrappedPipeBroadcasterPredicateDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPipeBroadcasterPredicateDirector(self)
        return weakref.proxy(self)

# Register WrappedPipeBroadcasterPredicateDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeBroadcasterPredicateDirector_swigregister(WrappedPipeBroadcasterPredicateDirector)

class WrappedPipeBroadcaster(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Init(self, pipe, maximum_backlog=-1):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_Init(self, pipe, maximum_backlog)

    def SendPacket(self, packet):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_SendPacket(self, packet)

    def AsyncSendPacket(self, packet, handler, id):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_AsyncSendPacket(self, packet, handler, id)

    def GetActivePipeEndpointCount(self):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_GetActivePipeEndpointCount(self)

    def SetPredicateDirector(self, f, id):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_SetPredicateDirector(self, f, id)

    def GetMaxBacklog(self):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_GetMaxBacklog(self)

    def SetMaxBacklog(self, maximum_backlog):
        return _RobotRaconteurPython.WrappedPipeBroadcaster_SetMaxBacklog(self, maximum_backlog)

    def __init__(self):
        _RobotRaconteurPython.WrappedPipeBroadcaster_swiginit(self, _RobotRaconteurPython.new_WrappedPipeBroadcaster())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeBroadcaster

# Register WrappedPipeBroadcaster in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeBroadcaster_swigregister(WrappedPipeBroadcaster)

class WrappedWireConnectionDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireConnectionDirector

    def WireValueChanged(self, value, time):
        return _RobotRaconteurPython.WrappedWireConnectionDirector_WireValueChanged(self, value, time)

    def WireConnectionClosedCallback(self):
        return _RobotRaconteurPython.WrappedWireConnectionDirector_WireConnectionClosedCallback(self)

    def __init__(self):
        if self.__class__ == WrappedWireConnectionDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedWireConnectionDirector_swiginit(self, _RobotRaconteurPython.new_WrappedWireConnectionDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedWireConnectionDirector(self)
        return weakref.proxy(self)

# Register WrappedWireConnectionDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireConnectionDirector_swigregister(WrappedWireConnectionDirector)

class AsyncWireConnectionReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncWireConnectionReturnDirector

    def handler(self, ep, error):
        return _RobotRaconteurPython.AsyncWireConnectionReturnDirector_handler(self, ep, error)

    def __init__(self):
        if self.__class__ == AsyncWireConnectionReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncWireConnectionReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncWireConnectionReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncWireConnectionReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncWireConnectionReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncWireConnectionReturnDirector_swigregister(AsyncWireConnectionReturnDirector)

class AsyncWirePeekReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncWirePeekReturnDirector

    def handler(self, value, ts, error):
        return _RobotRaconteurPython.AsyncWirePeekReturnDirector_handler(self, value, ts, error)

    def __init__(self):
        if self.__class__ == AsyncWirePeekReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncWirePeekReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncWirePeekReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncWirePeekReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncWirePeekReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncWirePeekReturnDirector_swigregister(AsyncWirePeekReturnDirector)

class TryGetValueResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    res = property(_RobotRaconteurPython.TryGetValueResult_res_get, _RobotRaconteurPython.TryGetValueResult_res_set)
    value = property(_RobotRaconteurPython.TryGetValueResult_value_get, _RobotRaconteurPython.TryGetValueResult_value_set)
    ts = property(_RobotRaconteurPython.TryGetValueResult_ts_get, _RobotRaconteurPython.TryGetValueResult_ts_set)

    def __init__(self):
        _RobotRaconteurPython.TryGetValueResult_swiginit(self, _RobotRaconteurPython.new_TryGetValueResult())
    __swig_destroy__ = _RobotRaconteurPython.delete_TryGetValueResult

# Register TryGetValueResult in _RobotRaconteurPython:
_RobotRaconteurPython.TryGetValueResult_swigregister(TryGetValueResult)

class WrappedWireConnection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetInValue(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetInValue(self)

    def GetOutValue(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetOutValue(self)

    def SetOutValue(self, value):
        return _RobotRaconteurPython.WrappedWireConnection_SetOutValue(self, value)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedWireConnection_SetRRDirector(self, director, id)
    Type = property(_RobotRaconteurPython.WrappedWireConnection_Type_get, _RobotRaconteurPython.WrappedWireConnection_Type_set)

    def Close(self):
        return _RobotRaconteurPython.WrappedWireConnection_Close(self)

    def GetEndpoint(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetEndpoint(self)

    def GetLastValueReceivedTime(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetLastValueReceivedTime(self)

    def GetLastValueSentTime(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetLastValueSentTime(self)

    def GetInValueValid(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetInValueValid(self)

    def GetOutValueValid(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetOutValueValid(self)

    def TryGetInValue(self):
        return _RobotRaconteurPython.WrappedWireConnection_TryGetInValue(self)

    def TryGetOutValue(self):
        return _RobotRaconteurPython.WrappedWireConnection_TryGetOutValue(self)

    def AsyncClose(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedWireConnection_AsyncClose(self, timeout, handler, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetNode(self)

    def GetIgnoreInValue(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetIgnoreInValue(self)

    def SetIgnoreInValue(self, ignore):
        return _RobotRaconteurPython.WrappedWireConnection_SetIgnoreInValue(self, ignore)

    def GetInValueLifespan(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetInValueLifespan(self)

    def SetInValueLifespan(self, millis):
        return _RobotRaconteurPython.WrappedWireConnection_SetInValueLifespan(self, millis)

    def GetOutValueLifespan(self):
        return _RobotRaconteurPython.WrappedWireConnection_GetOutValueLifespan(self)

    def SetOutValueLifespan(self, millis):
        return _RobotRaconteurPython.WrappedWireConnection_SetOutValueLifespan(self, millis)

    def WaitInValueValid(self, *args):
        return _RobotRaconteurPython.WrappedWireConnection_WaitInValueValid(self, *args)

    def WaitOutValueValid(self, *args):
        return _RobotRaconteurPython.WrappedWireConnection_WaitOutValueValid(self, *args)

    def Direction(self):
        return _RobotRaconteurPython.WrappedWireConnection_Direction(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireConnection

# Register WrappedWireConnection in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireConnection_swigregister(WrappedWireConnection)

class WrappedWireClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Connect(self):
        return _RobotRaconteurPython.WrappedWireClient_Connect(self)

    def AsyncConnect(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedWireClient_AsyncConnect(self, timeout, handler, id)

    def GetMemberName(self):
        return _RobotRaconteurPython.WrappedWireClient_GetMemberName(self)

    def PeekInValue(self, ts):
        return _RobotRaconteurPython.WrappedWireClient_PeekInValue(self, ts)

    def PeekOutValue(self, ts):
        return _RobotRaconteurPython.WrappedWireClient_PeekOutValue(self, ts)

    def PokeOutValue(self, value):
        return _RobotRaconteurPython.WrappedWireClient_PokeOutValue(self, value)

    def AsyncPeekInValue(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedWireClient_AsyncPeekInValue(self, timeout, handler, id)

    def AsyncPeekOutValue(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedWireClient_AsyncPeekOutValue(self, timeout, handler, id)

    def AsyncPokeOutValue(self, value, timeout, handler, id):
        return _RobotRaconteurPython.WrappedWireClient_AsyncPokeOutValue(self, value, timeout, handler, id)
    Type = property(_RobotRaconteurPython.WrappedWireClient_Type_get, _RobotRaconteurPython.WrappedWireClient_Type_set)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedWireClient_GetNode(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedWireClient_Direction(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireClient

# Register WrappedWireClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireClient_swigregister(WrappedWireClient)

class WrappedWireServerConnectDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireServerConnectDirector

    def WireConnectCallback(self, c):
        return _RobotRaconteurPython.WrappedWireServerConnectDirector_WireConnectCallback(self, c)

    def __init__(self):
        if self.__class__ == WrappedWireServerConnectDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedWireServerConnectDirector_swiginit(self, _RobotRaconteurPython.new_WrappedWireServerConnectDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedWireServerConnectDirector(self)
        return weakref.proxy(self)

# Register WrappedWireServerConnectDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireServerConnectDirector_swigregister(WrappedWireServerConnectDirector)

class WrappedWireServerPeekValueDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireServerPeekValueDirector

    def PeekValue(self, ep):
        return _RobotRaconteurPython.WrappedWireServerPeekValueDirector_PeekValue(self, ep)

    def __init__(self):
        if self.__class__ == WrappedWireServerPeekValueDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedWireServerPeekValueDirector_swiginit(self, _RobotRaconteurPython.new_WrappedWireServerPeekValueDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedWireServerPeekValueDirector(self)
        return weakref.proxy(self)

# Register WrappedWireServerPeekValueDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireServerPeekValueDirector_swigregister(WrappedWireServerPeekValueDirector)

class WrappedWireServerPokeValueDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireServerPokeValueDirector

    def PokeValue(self, value, ts, ep):
        return _RobotRaconteurPython.WrappedWireServerPokeValueDirector_PokeValue(self, value, ts, ep)

    def __init__(self):
        if self.__class__ == WrappedWireServerPokeValueDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedWireServerPokeValueDirector_swiginit(self, _RobotRaconteurPython.new_WrappedWireServerPokeValueDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedWireServerPokeValueDirector(self)
        return weakref.proxy(self)

# Register WrappedWireServerPokeValueDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireServerPokeValueDirector_swigregister(WrappedWireServerPokeValueDirector)

class WrappedWireServer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetMemberName(self):
        return _RobotRaconteurPython.WrappedWireServer_GetMemberName(self)
    Type = property(_RobotRaconteurPython.WrappedWireServer_Type_get, _RobotRaconteurPython.WrappedWireServer_Type_set)

    def SetWrappedWireConnectCallback(self, director, id):
        return _RobotRaconteurPython.WrappedWireServer_SetWrappedWireConnectCallback(self, director, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedWireServer_GetNode(self)

    def SetPeekInValueCallback(self, director, id):
        return _RobotRaconteurPython.WrappedWireServer_SetPeekInValueCallback(self, director, id)

    def SetPeekOutValueCallback(self, director, id):
        return _RobotRaconteurPython.WrappedWireServer_SetPeekOutValueCallback(self, director, id)

    def SetPokeOutValueCallback(self, director, id):
        return _RobotRaconteurPython.WrappedWireServer_SetPokeOutValueCallback(self, director, id)

    def Direction(self):
        return _RobotRaconteurPython.WrappedWireServer_Direction(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireServer

# Register WrappedWireServer in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireServer_swigregister(WrappedWireServer)

class WrappedWireBroadcasterPredicateDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Predicate(self, client_endpoint):
        return _RobotRaconteurPython.WrappedWireBroadcasterPredicateDirector_Predicate(self, client_endpoint)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireBroadcasterPredicateDirector

    def __init__(self):
        if self.__class__ == WrappedWireBroadcasterPredicateDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedWireBroadcasterPredicateDirector_swiginit(self, _RobotRaconteurPython.new_WrappedWireBroadcasterPredicateDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedWireBroadcasterPredicateDirector(self)
        return weakref.proxy(self)

# Register WrappedWireBroadcasterPredicateDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireBroadcasterPredicateDirector_swigregister(WrappedWireBroadcasterPredicateDirector)

class WrappedWireBroadcaster(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Init(self, wire):
        return _RobotRaconteurPython.WrappedWireBroadcaster_Init(self, wire)

    def SetOutValue(self, value):
        return _RobotRaconteurPython.WrappedWireBroadcaster_SetOutValue(self, value)

    def GetActiveWireConnectionCount(self):
        return _RobotRaconteurPython.WrappedWireBroadcaster_GetActiveWireConnectionCount(self)

    def SetPredicateDirector(self, f, id):
        return _RobotRaconteurPython.WrappedWireBroadcaster_SetPredicateDirector(self, f, id)

    def GetOutValueLifespan(self):
        return _RobotRaconteurPython.WrappedWireBroadcaster_GetOutValueLifespan(self)

    def SetOutValueLifespan(self, millis):
        return _RobotRaconteurPython.WrappedWireBroadcaster_SetOutValueLifespan(self, millis)

    def SetPeekInValueCallback(self, director, id):
        return _RobotRaconteurPython.WrappedWireBroadcaster_SetPeekInValueCallback(self, director, id)

    def __init__(self):
        _RobotRaconteurPython.WrappedWireBroadcaster_swiginit(self, _RobotRaconteurPython.new_WrappedWireBroadcaster())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireBroadcaster

# Register WrappedWireBroadcaster in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireBroadcaster_swigregister(WrappedWireBroadcaster)

class WrappedWireUnicastReceiver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Init(self, wire):
        return _RobotRaconteurPython.WrappedWireUnicastReceiver_Init(self, wire)

    def GetInValue(self, ts):
        return _RobotRaconteurPython.WrappedWireUnicastReceiver_GetInValue(self, ts)

    def AddInValueChangedListener(self, director, id):
        return _RobotRaconteurPython.WrappedWireUnicastReceiver_AddInValueChangedListener(self, director, id)

    def GetInValueLifespan(self):
        return _RobotRaconteurPython.WrappedWireUnicastReceiver_GetInValueLifespan(self)

    def SetInValueLifespan(self, millis):
        return _RobotRaconteurPython.WrappedWireUnicastReceiver_SetInValueLifespan(self, millis)

    def TryGetInValue(self, val, time):
        return _RobotRaconteurPython.WrappedWireUnicastReceiver_TryGetInValue(self, val, time)

    def __init__(self):
        _RobotRaconteurPython.WrappedWireUnicastReceiver_swiginit(self, _RobotRaconteurPython.new_WrappedWireUnicastReceiver())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireUnicastReceiver

# Register WrappedWireUnicastReceiver in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireUnicastReceiver_swigregister(WrappedWireUnicastReceiver)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ArrayMemoryBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Length(self):
        return _RobotRaconteurPython.ArrayMemoryBase_Length(self)

    def ElementTypeID(self):
        return _RobotRaconteurPython.ArrayMemoryBase_ElementTypeID(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_ArrayMemoryBase

# Register ArrayMemoryBase in _RobotRaconteurPython:
_RobotRaconteurPython.ArrayMemoryBase_swigregister(ArrayMemoryBase)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class MultiDimArrayMemoryBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Dimensions(self):
        return _RobotRaconteurPython.MultiDimArrayMemoryBase_Dimensions(self)

    def DimCount(self):
        return _RobotRaconteurPython.MultiDimArrayMemoryBase_DimCount(self)

    def ElementTypeID(self):
        return _RobotRaconteurPython.MultiDimArrayMemoryBase_ElementTypeID(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_MultiDimArrayMemoryBase

# Register MultiDimArrayMemoryBase in _RobotRaconteurPython:
_RobotRaconteurPython.MultiDimArrayMemoryBase_swigregister(MultiDimArrayMemoryBase)

class WrappedArrayMemoryClientUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Read(mem, memorypos, count):
        return _RobotRaconteurPython.WrappedArrayMemoryClientUtil_Read(mem, memorypos, count)

    @staticmethod
    def Write(mem, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedArrayMemoryClientUtil_Write(mem, memorypos, buffer, bufferpos, count)

    @staticmethod
    def Direction(mem):
        return _RobotRaconteurPython.WrappedArrayMemoryClientUtil_Direction(mem)

    def __init__(self):
        _RobotRaconteurPython.WrappedArrayMemoryClientUtil_swiginit(self, _RobotRaconteurPython.new_WrappedArrayMemoryClientUtil())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedArrayMemoryClientUtil

# Register WrappedArrayMemoryClientUtil in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedArrayMemoryClientUtil_swigregister(WrappedArrayMemoryClientUtil)

def WrappedArrayMemoryClientUtil_Read(mem, memorypos, count):
    return _RobotRaconteurPython.WrappedArrayMemoryClientUtil_Read(mem, memorypos, count)

def WrappedArrayMemoryClientUtil_Write(mem, memorypos, buffer, bufferpos, count):
    return _RobotRaconteurPython.WrappedArrayMemoryClientUtil_Write(mem, memorypos, buffer, bufferpos, count)

def WrappedArrayMemoryClientUtil_Direction(mem):
    return _RobotRaconteurPython.WrappedArrayMemoryClientUtil_Direction(mem)

class WrappedMultiDimArrayMemoryClientUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Read(mem, memorypos, count):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_Read(mem, memorypos, count)

    @staticmethod
    def Write(mem, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_Write(mem, memorypos, buffer, bufferpos, count)

    @staticmethod
    def Direction(mem):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_Direction(mem)

    def __init__(self):
        _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_swiginit(self, _RobotRaconteurPython.new_WrappedMultiDimArrayMemoryClientUtil())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedMultiDimArrayMemoryClientUtil

# Register WrappedMultiDimArrayMemoryClientUtil in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_swigregister(WrappedMultiDimArrayMemoryClientUtil)

def WrappedMultiDimArrayMemoryClientUtil_Read(mem, memorypos, count):
    return _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_Read(mem, memorypos, count)

def WrappedMultiDimArrayMemoryClientUtil_Write(mem, memorypos, buffer, bufferpos, count):
    return _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_Write(mem, memorypos, buffer, bufferpos, count)

def WrappedMultiDimArrayMemoryClientUtil_Direction(mem):
    return _RobotRaconteurPython.WrappedMultiDimArrayMemoryClientUtil_Direction(mem)

class WrappedPodArrayMemoryClientBuffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def UnpackReadResult(self, res, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClientBuffer_UnpackReadResult(self, res, bufferpos, count)

    def PackWriteRequest(self, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClientBuffer_PackWriteRequest(self, bufferpos, count)

    def GetBufferLength(self):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClientBuffer_GetBufferLength(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPodArrayMemoryClientBuffer

    def __init__(self):
        if self.__class__ == WrappedPodArrayMemoryClientBuffer:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPodArrayMemoryClientBuffer_swiginit(self, _RobotRaconteurPython.new_WrappedPodArrayMemoryClientBuffer(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPodArrayMemoryClientBuffer(self)
        return weakref.proxy(self)

# Register WrappedPodArrayMemoryClientBuffer in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPodArrayMemoryClientBuffer_swigregister(WrappedPodArrayMemoryClientBuffer)

class WrappedPodArrayMemoryClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Length(self):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClient_Length(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClient_Direction(self)

    def Read(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClient_Read(self, memorypos, buffer, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodArrayMemoryClient_Write(self, memorypos, buffer, bufferpos, count)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPodArrayMemoryClient

# Register WrappedPodArrayMemoryClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPodArrayMemoryClient_swigregister(WrappedPodArrayMemoryClient)

class WrappedPodMultiDimArrayMemoryClientBuffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def UnpackReadResult(self, res, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClientBuffer_UnpackReadResult(self, res, bufferpos, count)

    def PackWriteRequest(self, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClientBuffer_PackWriteRequest(self, bufferpos, count)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPodMultiDimArrayMemoryClientBuffer

    def __init__(self):
        if self.__class__ == WrappedPodMultiDimArrayMemoryClientBuffer:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClientBuffer_swiginit(self, _RobotRaconteurPython.new_WrappedPodMultiDimArrayMemoryClientBuffer(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPodMultiDimArrayMemoryClientBuffer(self)
        return weakref.proxy(self)

# Register WrappedPodMultiDimArrayMemoryClientBuffer in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClientBuffer_swigregister(WrappedPodMultiDimArrayMemoryClientBuffer)

class WrappedPodMultiDimArrayMemoryClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Dimensions(self):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClient_Dimensions(self)

    def DimCount(self):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClient_DimCount(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClient_Direction(self)

    def Read(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClient_Read(self, memorypos, buffer, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClient_Write(self, memorypos, buffer, bufferpos, count)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPodMultiDimArrayMemoryClient

# Register WrappedPodMultiDimArrayMemoryClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPodMultiDimArrayMemoryClient_swigregister(WrappedPodMultiDimArrayMemoryClient)

class WrappedArrayMemoryDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedArrayMemoryDirector

    def Length(self):
        return _RobotRaconteurPython.WrappedArrayMemoryDirector_Length(self)

    def Read(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedArrayMemoryDirector_Read(self, memorypos, buffer, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedArrayMemoryDirector_Write(self, memorypos, buffer, bufferpos, count)
    objectheapid = property(_RobotRaconteurPython.WrappedArrayMemoryDirector_objectheapid_get, _RobotRaconteurPython.WrappedArrayMemoryDirector_objectheapid_set)

    def __init__(self):
        if self.__class__ == WrappedArrayMemoryDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedArrayMemoryDirector_swiginit(self, _RobotRaconteurPython.new_WrappedArrayMemoryDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedArrayMemoryDirector(self)
        return weakref.proxy(self)

# Register WrappedArrayMemoryDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedArrayMemoryDirector_swigregister(WrappedArrayMemoryDirector)

class WrappedMultiDimArrayMemoryParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    memorypos = property(_RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_memorypos_get, _RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_memorypos_set)
    buffer = property(_RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_buffer_get, _RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_buffer_set)
    bufferpos = property(_RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_bufferpos_get, _RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_bufferpos_set)
    count = property(_RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_count_get, _RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_count_set)

    def __init__(self):
        _RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_swiginit(self, _RobotRaconteurPython.new_WrappedMultiDimArrayMemoryParams())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedMultiDimArrayMemoryParams

# Register WrappedMultiDimArrayMemoryParams in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedMultiDimArrayMemoryParams_swigregister(WrappedMultiDimArrayMemoryParams)

class WrappedMultiDimArrayMemoryDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedMultiDimArrayMemoryDirector

    def Dimensions(self):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_Dimensions(self)

    def DimCount(self):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_DimCount(self)

    def Read(self, p):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_Read(self, p)

    def Write(self, p):
        return _RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_Write(self, p)
    objectheapid = property(_RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_objectheapid_get, _RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_objectheapid_set)

    def __init__(self):
        if self.__class__ == WrappedMultiDimArrayMemoryDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_swiginit(self, _RobotRaconteurPython.new_WrappedMultiDimArrayMemoryDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedMultiDimArrayMemoryDirector(self)
        return weakref.proxy(self)

# Register WrappedMultiDimArrayMemoryDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedMultiDimArrayMemoryDirector_swigregister(WrappedMultiDimArrayMemoryDirector)

class WrappedPodArrayMemoryDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == WrappedPodArrayMemoryDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPodArrayMemoryDirector_swiginit(self, _RobotRaconteurPython.new_WrappedPodArrayMemoryDirector(_self, ))
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPodArrayMemoryDirector

    def Length(self):
        return _RobotRaconteurPython.WrappedPodArrayMemoryDirector_Length(self)

    def Read(self, memorypos, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodArrayMemoryDirector_Read(self, memorypos, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodArrayMemoryDirector_Write(self, memorypos, buffer, bufferpos, count)
    objectheapid = property(_RobotRaconteurPython.WrappedPodArrayMemoryDirector_objectheapid_get, _RobotRaconteurPython.WrappedPodArrayMemoryDirector_objectheapid_set)
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPodArrayMemoryDirector(self)
        return weakref.proxy(self)

# Register WrappedPodArrayMemoryDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPodArrayMemoryDirector_swigregister(WrappedPodArrayMemoryDirector)

class WrappedPodMultiDimArrayMemoryDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPodMultiDimArrayMemoryDirector

    def Dimensions(self):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_Dimensions(self)

    def DimCount(self):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_DimCount(self)

    def Read(self, memorypos, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_Read(self, memorypos, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_Write(self, memorypos, buffer, bufferpos, count)
    objectheapid = property(_RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_objectheapid_get, _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_objectheapid_set)

    def __init__(self):
        if self.__class__ == WrappedPodMultiDimArrayMemoryDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_swiginit(self, _RobotRaconteurPython.new_WrappedPodMultiDimArrayMemoryDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPodMultiDimArrayMemoryDirector(self)
        return weakref.proxy(self)

# Register WrappedPodMultiDimArrayMemoryDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPodMultiDimArrayMemoryDirector_swigregister(WrappedPodMultiDimArrayMemoryDirector)

class WrappedNamedArrayMemoryClientBuffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def UnpackReadResult(self, res, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClientBuffer_UnpackReadResult(self, res, bufferpos, count)

    def PackWriteRequest(self, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClientBuffer_PackWriteRequest(self, bufferpos, count)

    def GetBufferLength(self):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClientBuffer_GetBufferLength(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedNamedArrayMemoryClientBuffer

    def __init__(self):
        if self.__class__ == WrappedNamedArrayMemoryClientBuffer:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedNamedArrayMemoryClientBuffer_swiginit(self, _RobotRaconteurPython.new_WrappedNamedArrayMemoryClientBuffer(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedNamedArrayMemoryClientBuffer(self)
        return weakref.proxy(self)

# Register WrappedNamedArrayMemoryClientBuffer in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedNamedArrayMemoryClientBuffer_swigregister(WrappedNamedArrayMemoryClientBuffer)

class WrappedNamedArrayMemoryClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Length(self):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClient_Length(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClient_Direction(self)

    def Read(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClient_Read(self, memorypos, buffer, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryClient_Write(self, memorypos, buffer, bufferpos, count)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedNamedArrayMemoryClient

# Register WrappedNamedArrayMemoryClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedNamedArrayMemoryClient_swigregister(WrappedNamedArrayMemoryClient)

class WrappedNamedMultiDimArrayMemoryClientBuffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def UnpackReadResult(self, res, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClientBuffer_UnpackReadResult(self, res, bufferpos, count)

    def PackWriteRequest(self, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClientBuffer_PackWriteRequest(self, bufferpos, count)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedNamedMultiDimArrayMemoryClientBuffer

    def __init__(self):
        if self.__class__ == WrappedNamedMultiDimArrayMemoryClientBuffer:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClientBuffer_swiginit(self, _RobotRaconteurPython.new_WrappedNamedMultiDimArrayMemoryClientBuffer(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedNamedMultiDimArrayMemoryClientBuffer(self)
        return weakref.proxy(self)

# Register WrappedNamedMultiDimArrayMemoryClientBuffer in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClientBuffer_swigregister(WrappedNamedMultiDimArrayMemoryClientBuffer)

class WrappedNamedMultiDimArrayMemoryClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Dimensions(self):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClient_Dimensions(self)

    def DimCount(self):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClient_DimCount(self)

    def Direction(self):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClient_Direction(self)

    def Read(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClient_Read(self, memorypos, buffer, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClient_Write(self, memorypos, buffer, bufferpos, count)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedNamedMultiDimArrayMemoryClient

# Register WrappedNamedMultiDimArrayMemoryClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryClient_swigregister(WrappedNamedMultiDimArrayMemoryClient)

class WrappedNamedArrayMemoryDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == WrappedNamedArrayMemoryDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedNamedArrayMemoryDirector_swiginit(self, _RobotRaconteurPython.new_WrappedNamedArrayMemoryDirector(_self, ))
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedNamedArrayMemoryDirector

    def Length(self):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryDirector_Length(self)

    def Read(self, memorypos, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryDirector_Read(self, memorypos, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedArrayMemoryDirector_Write(self, memorypos, buffer, bufferpos, count)
    objectheapid = property(_RobotRaconteurPython.WrappedNamedArrayMemoryDirector_objectheapid_get, _RobotRaconteurPython.WrappedNamedArrayMemoryDirector_objectheapid_set)
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedNamedArrayMemoryDirector(self)
        return weakref.proxy(self)

# Register WrappedNamedArrayMemoryDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedNamedArrayMemoryDirector_swigregister(WrappedNamedArrayMemoryDirector)

class WrappedNamedMultiDimArrayMemoryDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedNamedMultiDimArrayMemoryDirector

    def Dimensions(self):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_Dimensions(self)

    def DimCount(self):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_DimCount(self)

    def Read(self, memorypos, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_Read(self, memorypos, bufferpos, count)

    def Write(self, memorypos, buffer, bufferpos, count):
        return _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_Write(self, memorypos, buffer, bufferpos, count)
    objectheapid = property(_RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_objectheapid_get, _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_objectheapid_set)

    def __init__(self):
        if self.__class__ == WrappedNamedMultiDimArrayMemoryDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_swiginit(self, _RobotRaconteurPython.new_WrappedNamedMultiDimArrayMemoryDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedNamedMultiDimArrayMemoryDirector(self)
        return weakref.proxy(self)

# Register WrappedNamedMultiDimArrayMemoryDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedNamedMultiDimArrayMemoryDirector_swigregister(WrappedNamedMultiDimArrayMemoryDirector)

class WrappedGeneratorClient_TryGetNextResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    value = property(_RobotRaconteurPython.WrappedGeneratorClient_TryGetNextResult_value_get, _RobotRaconteurPython.WrappedGeneratorClient_TryGetNextResult_value_set)
    res = property(_RobotRaconteurPython.WrappedGeneratorClient_TryGetNextResult_res_get, _RobotRaconteurPython.WrappedGeneratorClient_TryGetNextResult_res_set)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedGeneratorClient_TryGetNextResult

# Register WrappedGeneratorClient_TryGetNextResult in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedGeneratorClient_TryGetNextResult_swigregister(WrappedGeneratorClient_TryGetNextResult)

class WrappedGeneratorClient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Next(self, v):
        return _RobotRaconteurPython.WrappedGeneratorClient_Next(self, v)

    def TryNext(self, v):
        return _RobotRaconteurPython.WrappedGeneratorClient_TryNext(self, v)

    def AsyncNext(self, v, timeout, handler, id):
        return _RobotRaconteurPython.WrappedGeneratorClient_AsyncNext(self, v, timeout, handler, id)

    def Abort(self):
        return _RobotRaconteurPython.WrappedGeneratorClient_Abort(self)

    def AsyncAbort(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedGeneratorClient_AsyncAbort(self, timeout, handler, id)

    def Close(self):
        return _RobotRaconteurPython.WrappedGeneratorClient_Close(self)

    def AsyncClose(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedGeneratorClient_AsyncClose(self, timeout, handler, id)

    def NextAll(self):
        return _RobotRaconteurPython.WrappedGeneratorClient_NextAll(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedGeneratorClient

# Register WrappedGeneratorClient in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedGeneratorClient_swigregister(WrappedGeneratorClient)

class AsyncGeneratorClientReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncGeneratorClientReturnDirector

    def handler(self, ret, error):
        return _RobotRaconteurPython.AsyncGeneratorClientReturnDirector_handler(self, ret, error)

    def __init__(self):
        if self.__class__ == AsyncGeneratorClientReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncGeneratorClientReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncGeneratorClientReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncGeneratorClientReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncGeneratorClientReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncGeneratorClientReturnDirector_swigregister(AsyncGeneratorClientReturnDirector)

class WrappedGeneratorServerDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == WrappedGeneratorServerDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedGeneratorServerDirector_swiginit(self, _RobotRaconteurPython.new_WrappedGeneratorServerDirector(_self, ))
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedGeneratorServerDirector

    def Next(self, m, async_adaptor):
        return _RobotRaconteurPython.WrappedGeneratorServerDirector_Next(self, m, async_adaptor)

    def Abort(self, async_adapter):
        return _RobotRaconteurPython.WrappedGeneratorServerDirector_Abort(self, async_adapter)

    def Close(self, async_adapter):
        return _RobotRaconteurPython.WrappedGeneratorServerDirector_Close(self, async_adapter)
    objectheapid = property(_RobotRaconteurPython.WrappedGeneratorServerDirector_objectheapid_get, _RobotRaconteurPython.WrappedGeneratorServerDirector_objectheapid_set)
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedGeneratorServerDirector(self)
        return weakref.proxy(self)

# Register WrappedGeneratorServerDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedGeneratorServerDirector_swigregister(WrappedGeneratorServerDirector)

class WrappedServiceStubDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceStubDirector

    def DispatchEvent(self, EventName, args):
        return _RobotRaconteurPython.WrappedServiceStubDirector_DispatchEvent(self, EventName, args)

    def CallbackCall(self, CallbackName, args):
        return _RobotRaconteurPython.WrappedServiceStubDirector_CallbackCall(self, CallbackName, args)

    def __init__(self):
        if self.__class__ == WrappedServiceStubDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedServiceStubDirector_swiginit(self, _RobotRaconteurPython.new_WrappedServiceStubDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedServiceStubDirector(self)
        return weakref.proxy(self)

# Register WrappedServiceStubDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceStubDirector_swigregister(WrappedServiceStubDirector)

class AsyncStubReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncStubReturnDirector

    def handler(self, stub, error):
        return _RobotRaconteurPython.AsyncStubReturnDirector_handler(self, stub, error)

    def __init__(self):
        if self.__class__ == AsyncStubReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncStubReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncStubReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncStubReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncStubReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncStubReturnDirector_swigregister(AsyncStubReturnDirector)

class WrappedServiceStub(RRObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PropertyGet(self, PropertyName):
        return _RobotRaconteurPython.WrappedServiceStub_PropertyGet(self, PropertyName)

    def PropertySet(self, PropertyName, value):
        return _RobotRaconteurPython.WrappedServiceStub_PropertySet(self, PropertyName, value)

    def FunctionCall(self, FunctionName, args):
        return _RobotRaconteurPython.WrappedServiceStub_FunctionCall(self, FunctionName, args)

    def GeneratorFunctionCall(self, FunctionName, args):
        return _RobotRaconteurPython.WrappedServiceStub_GeneratorFunctionCall(self, FunctionName, args)

    def async_PropertyGet(self, PropertyName, timeout, handler, id):
        return _RobotRaconteurPython.WrappedServiceStub_async_PropertyGet(self, PropertyName, timeout, handler, id)

    def async_PropertySet(self, PropertyName, value, timeout, handler, id):
        return _RobotRaconteurPython.WrappedServiceStub_async_PropertySet(self, PropertyName, value, timeout, handler, id)

    def async_FunctionCall(self, FunctionName, args, timeout, handler, id):
        return _RobotRaconteurPython.WrappedServiceStub_async_FunctionCall(self, FunctionName, args, timeout, handler, id)

    def async_GeneratorFunctionCall(self, FunctionName, args, timeout, handler, id):
        return _RobotRaconteurPython.WrappedServiceStub_async_GeneratorFunctionCall(self, FunctionName, args, timeout, handler, id)

    def async_FindObjRef(self, *args):
        return _RobotRaconteurPython.WrappedServiceStub_async_FindObjRef(self, *args)

    def async_FindObjRefTyped(self, *args):
        return _RobotRaconteurPython.WrappedServiceStub_async_FindObjRefTyped(self, *args)

    def GetPipe(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetPipe(self, membername)

    def GetWire(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetWire(self, membername)

    def GetObjectHeapID(self):
        return _RobotRaconteurPython.WrappedServiceStub_GetObjectHeapID(self)

    def _FindObjRef(self, *args):
        return _RobotRaconteurPython.WrappedServiceStub__FindObjRef(self, *args)

    def _FindObjRefTyped(self, *args):
        return _RobotRaconteurPython.WrappedServiceStub__FindObjRefTyped(self, *args)

    def GetArrayMemory(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetArrayMemory(self, membername)

    def GetMultiDimArrayMemory(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetMultiDimArrayMemory(self, membername)

    def GetPodArrayMemory(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetPodArrayMemory(self, membername)

    def GetPodMultiDimArrayMemory(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetPodMultiDimArrayMemory(self, membername)

    def GetNamedArrayMemory(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetNamedArrayMemory(self, membername)

    def GetNamedMultiDimArrayMemory(self, membername):
        return _RobotRaconteurPython.WrappedServiceStub_GetNamedMultiDimArrayMemory(self, membername)

    def RRClose(self):
        return _RobotRaconteurPython.WrappedServiceStub_RRClose(self)
    RR_objecttype = property(_RobotRaconteurPython.WrappedServiceStub_RR_objecttype_get, _RobotRaconteurPython.WrappedServiceStub_RR_objecttype_set)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedServiceStub_SetRRDirector(self, director, id)

    def RRGetNode(self):
        return _RobotRaconteurPython.WrappedServiceStub_RRGetNode(self)

    def GetPyStub(self):
        return _RobotRaconteurPython.WrappedServiceStub_GetPyStub(self)

    def SetPyStub(self, stub):
        return _RobotRaconteurPython.WrappedServiceStub_SetPyStub(self, stub)

    def FindObjRef(self, name, index=None):
    	if (index is None):
    		stub=self._FindObjRef(name)
    	else:
    		stub=self._FindObjRef(name,str(index))

    	return stub

    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceStub

# Register WrappedServiceStub in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceStub_swigregister(WrappedServiceStub)

class WrappedServiceSkelDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSkelDirector

    def Init(self, skel):
        return _RobotRaconteurPython.WrappedServiceSkelDirector_Init(self, skel)

    def _CallGetProperty(self, name, async_adaptor):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__CallGetProperty(self, name, async_adaptor)

    def _CallSetProperty(self, name, m, async_adaptor):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__CallSetProperty(self, name, m, async_adaptor)

    def _CallFunction(self, name, m, async_adaptor):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__CallFunction(self, name, m, async_adaptor)

    def _GetSubObj(self, name, index):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetSubObj(self, name, index)

    def _GetArrayMemory(self, name):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetArrayMemory(self, name)

    def _GetMultiDimArrayMemory(self, name):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetMultiDimArrayMemory(self, name)

    def _GetPodArrayMemory(self, name):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetPodArrayMemory(self, name)

    def _GetPodMultiDimArrayMemory(self, name):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetPodMultiDimArrayMemory(self, name)

    def _GetNamedArrayMemory(self, name):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetNamedArrayMemory(self, name)

    def _GetNamedMultiDimArrayMemory(self, name):
        return _RobotRaconteurPython.WrappedServiceSkelDirector__GetNamedMultiDimArrayMemory(self, name)

    def MonitorEnter(self, timeout):
        return _RobotRaconteurPython.WrappedServiceSkelDirector_MonitorEnter(self, timeout)

    def MonitorExit(self):
        return _RobotRaconteurPython.WrappedServiceSkelDirector_MonitorExit(self)

    def ReleaseCastObject(self):
        return _RobotRaconteurPython.WrappedServiceSkelDirector_ReleaseCastObject(self)

    def __init__(self):
        if self.__class__ == WrappedServiceSkelDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedServiceSkelDirector_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSkelDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedServiceSkelDirector(self)
        return weakref.proxy(self)

# Register WrappedServiceSkelDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSkelDirector_swigregister(WrappedServiceSkelDirector)

class WrappedRRObject(RRObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, type, RR_Director, id):
        _RobotRaconteurPython.WrappedRRObject_swiginit(self, _RobotRaconteurPython.new_WrappedRRObject(type, RR_Director, id))
    Type = property(_RobotRaconteurPython.WrappedRRObject_Type_get, _RobotRaconteurPython.WrappedRRObject_Type_set)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedRRObject

# Register WrappedRRObject in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedRRObject_swigregister(WrappedRRObject)

class WrappedServiceSkel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type = property(_RobotRaconteurPython.WrappedServiceSkel_Type_get, _RobotRaconteurPython.WrappedServiceSkel_Type_set)
    castobj = property(_RobotRaconteurPython.WrappedServiceSkel_castobj_get, _RobotRaconteurPython.WrappedServiceSkel_castobj_set)

    def GetPipe(self, membername):
        return _RobotRaconteurPython.WrappedServiceSkel_GetPipe(self, membername)

    def GetWire(self, membername):
        return _RobotRaconteurPython.WrappedServiceSkel_GetWire(self, membername)

    def WrappedDispatchEvent(self, name, m):
        return _RobotRaconteurPython.WrappedServiceSkel_WrappedDispatchEvent(self, name, m)

    def WrappedCallbackCall(self, name, endpoint, m):
        return _RobotRaconteurPython.WrappedServiceSkel_WrappedCallbackCall(self, name, endpoint, m)

    def RRGetNode(self):
        return _RobotRaconteurPython.WrappedServiceSkel_RRGetNode(self)

    def RegisterGeneratorServer(self, function_name, gen):
        return _RobotRaconteurPython.WrappedServiceSkel_RegisterGeneratorServer(self, function_name, gen)

    def GetServicePath(self):
        return _RobotRaconteurPython.WrappedServiceSkel_GetServicePath(self)

    def GetContext(self):
        return _RobotRaconteurPython.WrappedServiceSkel_GetContext(self)

    def __init__(self):
        _RobotRaconteurPython.WrappedServiceSkel_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSkel())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSkel

# Register WrappedServiceSkel in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSkel_swigregister(WrappedServiceSkel)

class ServerServiceListenerDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    objectheapid = property(_RobotRaconteurPython.ServerServiceListenerDirector_objectheapid_get, _RobotRaconteurPython.ServerServiceListenerDirector_objectheapid_set)

    def __init__(self):
        if self.__class__ == ServerServiceListenerDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.ServerServiceListenerDirector_swiginit(self, _RobotRaconteurPython.new_ServerServiceListenerDirector(_self, ))

    def Callback(self, code, endpoint):
        return _RobotRaconteurPython.ServerServiceListenerDirector_Callback(self, code, endpoint)
    __swig_destroy__ = _RobotRaconteurPython.delete_ServerServiceListenerDirector
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_ServerServiceListenerDirector(self)
        return weakref.proxy(self)

# Register ServerServiceListenerDirector in _RobotRaconteurPython:
_RobotRaconteurPython.ServerServiceListenerDirector_swigregister(ServerServiceListenerDirector)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ServerContext(object):
    r"""

    ServerContext()

    Context for services registered in a node for use by clients

    Services are registered using the RobotRaconteurNode.RegisterService() family of functions.
    The ServerContext manages the services, and dispatches requests and packets to the appropriate
    service object members. Services may expose more than one object. The root object is specified
    when the service is registered. Other objects are specified through ObjRef members. A name
    for the service is also specified when the service is registered. This name forms the root 
    of the service path namespace. Other objects in the service have a unique service path
    based on the ObjRef used to access the object.

    Services may handle multiple connected clients concurrently. Each client is assigned
    a ServerEndpoint. The ServerEndpoint is unique to the client connection,
    and interacts with ServerContext to complete requests and dispatch packets. When
    the service needs to address a specific client, the ServerEndpoint or the
    ServerEndpoint.GetCurrentEndpoint() is used. (ServerEndpoint.GetCurrentEndpoint() returns the
    int local client ID.)

    Service attributes are a varvalue{string} types dictionary that is made available to
    clients during service discovery. These attributes are used to help clients determine
    which service should be selected for use. Because the attributes are passed to the clients
    as part of the discovery process, they should be as concise as possible, and should
    not use user defined types. Use ServerContext.SetAttributes() to set the service attributes
    after registering the service. 

    Security for the service is specified using a ServiceSecurityPolicy instance. This policy
    is specified by passing as a parameter to RobotRaconteurNode.RegisterService(), or passing
    the policy to the constructor.

    ServerContext implements authentication and object locking. 
    Server side functions are exposed by ServerContext for authentication, object locking,
    and client management.

    Clients using dynamic typing such as Python and MATLAB will only pull service types
    explicitly imported by the root object and objref objects that have been requested. Clients
    will not pull service types of user-defined named types if that service type is not explicitly
    imported. This can be problematic if new `struct`, `pod`, and/or `namedarray` types are introduced
    that do not have corresponding objects. Extra imports is used to specify extra service definitions
    the client should pull. Use ServerContext.AddExtraImport(), ServerContext.RemoveExtraImport(),
    and ServerContext.GetExtraImports() to manage the extra imports passed to the client.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def GetCurrentServicePath():
        r"""

        Get the current object service path

        Returns the service path of the current object during a request or
        packet event.
        This is a thread-specific value and only
        valid during the initial request or packet event invocation.

        :return: The current object service path
        :rtype: str

        """
        return _RobotRaconteurPython.ServerContext_GetCurrentServicePath()

    def _ReleaseServicePath(self, *args):
        return _RobotRaconteurPython.ServerContext__ReleaseServicePath(self, *args)

    @staticmethod
    def GetCurrentServerContext():
        r"""

        Get the current ServerContext

        Returns the current server context during a request or packet event.
        This is a thread-specific value and only
        valid during the initial request or packet event invocation.

        :return: The current server context
        :rtype: RobotRaconteur.ServerContext

        """
        return _RobotRaconteurPython.ServerContext_GetCurrentServerContext()

    def KickUser(self, username):
        r"""

        Kicks a user with the specified username

        User must be authenticated.

        :param username: The username to kick
        :type username: str

        """
        return _RobotRaconteurPython.ServerContext_KickUser(self, username)

    def _AddServerServiceListener(self, listener):
        return _RobotRaconteurPython.ServerContext__AddServerServiceListener(self, listener)

    def _SetServiceAttributes(self, attributes):
        return _RobotRaconteurPython.ServerContext__SetServiceAttributes(self, attributes)

    def RequestObjectLock(self, servicepath, username):
        r"""

        Request an object lock on servicepath for user username

        This function handles incoming client requests, but may also be used
        by the service directly

        :param servicepath: The service path to lock
        :type servicepath: str
        :param username: The name of the user owning the lock
        :type username: str

        """
        return _RobotRaconteurPython.ServerContext_RequestObjectLock(self, servicepath, username)

    def RequestClientObjectLock(self, servicepath, username, endpoint):
        r"""

        Request a client lock on servicepath for a specific client connection

        This function handles incoming client requests, but may also be used
        by the service directly. Client object locks lock for a specific client connection,
        while client locks lock for a specific user. The specific client connection is 
        specified using endpoint.

        :param servicepath: The service path to lock
        :type servicepath: str
        :param username: The name of the user owning the lock
        :type username: str
        :param endpoint: The client endpoint ID of the client owning the lock
        :type int:

        """
        return _RobotRaconteurPython.ServerContext_RequestClientObjectLock(self, servicepath, username, endpoint)

    def ReleaseObjectLock(self, servicepath, username, override_):
        r"""

        Release a client lock on servicepath

        This function handles incoming client requests, but may also be used
        by the service directly. Client locks can be released by the user that
        created them if override_ is false, or by any user if override_ is true. 

        The override_ parameter is set to true for client requests if the client has
        the "objectlockoverride" permission.

        :param servicepath: The service path to release lock
        :type str:
        :param username: The username requsting the lock release
        :type username:
        :param override_: If False, only the creating username can release the lock. If True, 
         any username can release the lock
        :type override_: bool

        """
        return _RobotRaconteurPython.ServerContext_ReleaseObjectLock(self, servicepath, username, override_)

    def GetObjectLockUsername(self, servicepath):
        r"""

        Get the name of the user that has locked the specified service path

        :param servicepath: The service path
        :type servicepath: str
        :return: The user owning the lock, or empty servicepath is not locked
        :rtype: str

        """
        return _RobotRaconteurPython.ServerContext_GetObjectLockUsername(self, servicepath)

    def GetNode(self):
        r"""

        Get the Node

        :rtype: RobotRaconteur.RobotRaconteurNode

        """
        return _RobotRaconteurPython.ServerContext_GetNode(self)

    def GetExtraImports(self):
        r"""

        Get the current list of extra service definition imports

        :return: The list of extra imports
        :rtype: List[str]

        """
        return _RobotRaconteurPython.ServerContext_GetExtraImports(self)

    def AddExtraImport(self, import_):
        r"""

        Add an extra service definition import

        Clients using dynamic typing will not automatically pull service definitions unless
        imported by the root object or an objref. If new "struct", "po", or "namedarray" types
        are introduced in a new service definition type without a corresponding object, an error will
        occur. Use AddExtraImport() to add the name of the new service definition to add it to the 
        list of service definitions the client will pull.

        Service definition must have been registered using RobotRaconteurNode::RegisterServiceType()

        :param import_: The name of the service definition
        :type import_: str

        """
        return _RobotRaconteurPython.ServerContext_AddExtraImport(self, import_)

    def RemoveExtraImport(self, import_):
        r"""

        Removes an extra import service definition registered with AddExtraImport()

        See AddExtraImport()

        :param import_: The name of the service definition
        :type import_: str
        :return: True The service definition was removed, False The service definition was not found in the extra imports vector
        :rtype: bool 

        """
        return _RobotRaconteurPython.ServerContext_RemoveExtraImport(self, import_)

    def AddServerServiceListener(self,listener):
    	"""
    	Add a service listener

    	:param listener: Callable listener function
    	:type listener: Callable[[RobotRaconteur.ServerContext,int,object]]
    	"""
    	from .RobotRaconteurPythonUtil import WrappedServerServiceListenerDirector
    	s=WrappedServerServiceListenerDirector(listener,self)
    	s.__disown__()
    	self._AddServerServiceListener(s)

    def SetServiceAttributes(self,attributes):
    	"""
    	Set the service attributes

    	Sets the service attributes. Attributes are made available to clients during
    	service discovery. Attributes should be concise and not use any user defined
    	types.

    	:param attr: The service attributes
    	:type attr: Dict[str,Any]
    	"""
    	from .RobotRaconteurPythonUtil import PackMessageElement
    	self._SetServiceAttributes(PackMessageElement(attributes,"varvalue{string} value",self))

    def ReleaseServicePath(self, path, endpoints=None):
    	"""
    	Release the specified service path and all sub objects

    	Services take ownership of objects returned by objrefs, and will only request the object
    	once. Subsequent requests will return the cached object. If the objref has changed,
    	the service must call ReleaseServicePath() to tell the service to request the object again.

    	Release service path will release the object specified by the service path
    	and all sub objects.

    	This overload will notify the specified that the objref has been released. If the service
    	path contains a session key, this overload should be used so the session key is not leaked.

    	:param path: The service path to release
    	:type path: str
    	:param endpoints: (Optional) The client endpoint IDs to notify of the released service path, 
    	 or None to notify all endpoints
    	:type endpoints: List[int]
    	"""
    	if (endpoints is None):
    		self._ReleaseServicePath(path)
    	else:
    		v=vectoruint32()
    		for e in endpoints:
    			v.append(e)
    		self._ReleaseServicePath(path,v)

    __swig_destroy__ = _RobotRaconteurPython.delete_ServerContext

# Register ServerContext in _RobotRaconteurPython:
_RobotRaconteurPython.ServerContext_swigregister(ServerContext)

def ServerContext_GetCurrentServicePath():
    r"""

    Get the current object service path

    Returns the service path of the current object during a request or
    packet event.
    This is a thread-specific value and only
    valid during the initial request or packet event invocation.

    :return: The current object service path
    :rtype: str

    """
    return _RobotRaconteurPython.ServerContext_GetCurrentServicePath()

def ServerContext_GetCurrentServerContext():
    r"""

    Get the current ServerContext

    Returns the current server context during a request or packet event.
    This is a thread-specific value and only
    valid during the initial request or packet event invocation.

    :return: The current server context
    :rtype: RobotRaconteur.ServerContext

    """
    return _RobotRaconteurPython.ServerContext_GetCurrentServerContext()

@_swig_add_metaclass(_SwigNonDynamicMeta)
class AuthenticatedUser(object):
    r"""

    AuthenticatedUser()

    Class representing an authenticated user

    Use ServerEndpoint.GetCurrentAuthenticatedUser() to retrieve the
    authenticated user making a request

    See \ref security for more information.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _GetUsername(self):
        return _RobotRaconteurPython.AuthenticatedUser__GetUsername(self)

    def _GetPrivileges(self):
        return _RobotRaconteurPython.AuthenticatedUser__GetPrivileges(self)

    def _GetProperties(self):
        return _RobotRaconteurPython.AuthenticatedUser__GetProperties(self)

    def _GetLoginTime(self):
        return _RobotRaconteurPython.AuthenticatedUser__GetLoginTime(self)

    def _GetLastAccessTime(self):
        return _RobotRaconteurPython.AuthenticatedUser__GetLastAccessTime(self)

    Username = property(lambda self: self._GetUsername(), doc = "The authenticated username")
    Privileges = property(lambda self: list(self._GetPrivileges()), doc = "The user privileges")
    Properties = property(lambda self: list(self._GetProperties()), doc = "The user properties")
    LoginTime = property(lambda self: self._GetLoginTime(), doc = "The user login time")
    LastAccessTime = property(lambda self: self._GetLastAccessTime(), doc = "The user last access time")

    __swig_destroy__ = _RobotRaconteurPython.delete_AuthenticatedUser

# Register AuthenticatedUser in _RobotRaconteurPython:
_RobotRaconteurPython.AuthenticatedUser_swigregister(AuthenticatedUser)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ServerEndpoint(object):
    r"""

    ServerEndpoint()

    Server endpoint representing a client connection

    Robot Raconteur creates endpoint pairs between a client and service. For clients, this endpoint
    is a ClientContext. For services, the endpoint becomes a ServerEndpoint. ServerEndpoints are used
    to address a specific client connected to a service, since services may have multiple clients
    connected concurrently. ServerEndpoints also provide client authentication information.

    Use ServerEndpoint.GetCurrentEndpoint() to retrieve the int32
    current endpoint ID. Use ServerEndpoint.GetCurrentAuthenticatedUser() to retrieve
    the current user authentication information.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def GetCurrentEndpoint():
        r"""

        Returns the current server endpoint

        Returns the current server endpoint during a request or packet event.
        This is a thread-specific value and only valid during the initial
        request or packet event invocation.

        Throws InvalidOperationException if not during a request or packet event

        :return: The current server endpoint id
        :rtype: int

        """
        return _RobotRaconteurPython.ServerEndpoint_GetCurrentEndpoint()

    @staticmethod
    def GetCurrentAuthenticatedUser():
        r"""

        Returns the current authenticated user

        Users that have been authenticated have a corresponding
        AuthenticatedUser object associated with the ServerEndpoint.
        GetCurrentAuthenticatedUser() returns the AuthenticatedUser
        associated with the current ServerEndpoint during a request
        or packet event. This is a thread-specific value and only valid during 
        the initial request or packet event invocation.

        Throws PermissionDeniedException or AuthenticationException
        if there is no AuthenticatedUser set in the current thread. 

        :return: The AuthenticatedUser
        :rtype: RobotRaconteur.AuthenticatedUser

        """
        return _RobotRaconteurPython.ServerEndpoint_GetCurrentAuthenticatedUser()
    __swig_destroy__ = _RobotRaconteurPython.delete_ServerEndpoint

# Register ServerEndpoint in _RobotRaconteurPython:
_RobotRaconteurPython.ServerEndpoint_swigregister(ServerEndpoint)

def ServerEndpoint_GetCurrentEndpoint():
    r"""

    Returns the current server endpoint

    Returns the current server endpoint during a request or packet event.
    This is a thread-specific value and only valid during the initial
    request or packet event invocation.

    Throws InvalidOperationException if not during a request or packet event

    :return: The current server endpoint id
    :rtype: int

    """
    return _RobotRaconteurPython.ServerEndpoint_GetCurrentEndpoint()

def ServerEndpoint_GetCurrentAuthenticatedUser():
    r"""

    Returns the current authenticated user

    Users that have been authenticated have a corresponding
    AuthenticatedUser object associated with the ServerEndpoint.
    GetCurrentAuthenticatedUser() returns the AuthenticatedUser
    associated with the current ServerEndpoint during a request
    or packet event. This is a thread-specific value and only valid during 
    the initial request or packet event invocation.

    Throws PermissionDeniedException or AuthenticationException
    if there is no AuthenticatedUser set in the current thread. 

    :return: The AuthenticatedUser
    :rtype: RobotRaconteur.AuthenticatedUser

    """
    return _RobotRaconteurPython.ServerEndpoint_GetCurrentAuthenticatedUser()

class WrappedServiceSkelAsyncAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MakeAsync(self):
        return _RobotRaconteurPython.WrappedServiceSkelAsyncAdapter_MakeAsync(self)

    def IsAsync(self):
        return _RobotRaconteurPython.WrappedServiceSkelAsyncAdapter_IsAsync(self)

    def End(self, *args):
        return _RobotRaconteurPython.WrappedServiceSkelAsyncAdapter_End(self, *args)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSkelAsyncAdapter

# Register WrappedServiceSkelAsyncAdapter in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSkelAsyncAdapter_swigregister(WrappedServiceSkelAsyncAdapter)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class NativeUserAuthenticator(object):
    r"""

    NativeUserAuthenticator()

    Base class for user authenticators

    Used with ServiceSecurityPolicy to secure services

    Override AuthenticateUser to implement different types
    of user authenticators.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _AuthenticateUser(self, username, credentials, context):
        return _RobotRaconteurPython.NativeUserAuthenticator__AuthenticateUser(self, username, credentials, context)

    def AuthenticateUser(self, username, credentials, context):
    	"""
    	Authenticate a user using username and credentials

    	The service will call AuthenticateUser when clients attempt to authenticate. The
    	username and credentials are passed to RobotRaconteurNode.ConnectService() or
    	RobotRaconteurNode.AsyncConnectService(). The authenticator must analyze these
    	values to decide how to authenticate the user.

    	On successful authentication, return a populated AuthenticatedUser object. On
    	failure, throw an exception.

    	See \\ref security for more information.

    	:param username: The username provided by the client
    	:type username: str
    	:param credentials: The credentials provided by the client
    	:type credentials: Dict[str,Any]
    	:param context: The context of the service requesting authentication
    	:type context: RobotRaconteur.ServerContext
    	:return: An authenticated user object
    	:rtype: RobotRaconteur.AuthenticatedUser
    	"""
    	from .RobotRaconteurPythonUtil import _UserAuthenticator_PackCredentials
    	m=_UserAuthenticator_PackCredentials(credentials)
    	return self._AuthenticateUser(username,m,context);

    __swig_destroy__ = _RobotRaconteurPython.delete_NativeUserAuthenticator

# Register NativeUserAuthenticator in _RobotRaconteurPython:
_RobotRaconteurPython.NativeUserAuthenticator_swigregister(NativeUserAuthenticator)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ServiceSecurityPolicy(object):
    r"""

    Security policy for Robot Raconteur service

    The security policy sets an authenticator, and a set of policies. PasswordFileUserAuthenticator is
    an example of an authenticator. The valid options for Policies are as follows:

    +------------------+-----------------+-----------------+-----------------+
    | Policy name      | Possible Values | Default         | Description     |
    +==================+=================+=================+=================+
    | requirevaliduser | true,false      | false           | Set to "true"   |
    |                  |                 |                 | to require a    |
    |                  |                 |                 | user be         |
    |                  |                 |                 | authenticated   |
    |                  |                 |                 | before          |
    |                  |                 |                 | accessing       |
    |                  |                 |                 | service         |
    +------------------+-----------------+-----------------+-----------------+
    | allowobjectlock  | true,false      | false           | If "true" allow |
    |                  |                 |                 | users to        |
    |                  |                 |                 | request object  |
    |                  |                 |                 | locks.          |
    |                  |                 |                 | r               |
    |                  |                 |                 | equirevaliduser |
    |                  |                 |                 | most also be    |
    |                  |                 |                 | "true"          |
    +------------------+-----------------+-----------------+-----------------+

    The security policy is passed as a parameter to RobotRaconteurNode.RegisterService().

    See \ref security for more information.

    :param Authenticator: The user authenticator
    :type Authenticator: RobotRaconteur.Authenticator
    :param Policies: The security policies
    :type Policies: Dict[str,str]

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, Authenticator, Policies):
        _RobotRaconteurPython.ServiceSecurityPolicy_swiginit(self, _RobotRaconteurPython.new_ServiceSecurityPolicy(Authenticator, Policies))
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceSecurityPolicy

# Register ServiceSecurityPolicy in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceSecurityPolicy_swigregister(ServiceSecurityPolicy)

class PasswordFileUserAuthenticator(NativeUserAuthenticator):
    r"""

    Simple authenticator using a list of username, password hash, and privileges stored in a file or string

    The password user authenticator expects a string containing a list of users,
    one per line. Each line contains the username, password as md5 hash, and privileges, separated by white spaces.
    An example of authentication string contents:

    .. code-block:: 

       user1 79e262a81dd19d40ae008f74eb59edce objectlock
       user2 309825a0951b3cf1f25e27b61cee8243 objectlock
       superuser1 11e5dfc68422e697563a4253ba360615 objectlock,objectlockoverride


    The password is md5 hashed. This hash can be generated using the ``--md5passwordhash`` command in the "RobotRaconteurGen" utility. 
    The privileges are comma separated. Valid privileges are as follows:

    ================== =====================================================
    Privilege Name     Description
    ================== =====================================================
    objectlock         Allow user to lock objects
    objectlockoverride Allow user to unlock object locks made by other users
    ================== =====================================================

    :param data: The file text
    :type data: str

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data, require_verified_client=False):
        _RobotRaconteurPython.PasswordFileUserAuthenticator_swiginit(self, _RobotRaconteurPython.new_PasswordFileUserAuthenticator(data, require_verified_client))
    __swig_destroy__ = _RobotRaconteurPython.delete_PasswordFileUserAuthenticator

# Register PasswordFileUserAuthenticator in _RobotRaconteurPython:
_RobotRaconteurPython.PasswordFileUserAuthenticator_swigregister(PasswordFileUserAuthenticator)

class WrappedUserAuthenticatorDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedUserAuthenticatorDirector

    def AuthenticateUser(self, username, credentials, context):
        return _RobotRaconteurPython.WrappedUserAuthenticatorDirector_AuthenticateUser(self, username, credentials, context)

    def __init__(self):
        if self.__class__ == WrappedUserAuthenticatorDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedUserAuthenticatorDirector_swiginit(self, _RobotRaconteurPython.new_WrappedUserAuthenticatorDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedUserAuthenticatorDirector(self)
        return weakref.proxy(self)

# Register WrappedUserAuthenticatorDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedUserAuthenticatorDirector_swigregister(WrappedUserAuthenticatorDirector)

class WrappedUserAuthenticator(NativeUserAuthenticator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedUserAuthenticator_SetRRDirector(self, director, id)

    def __init__(self):
        _RobotRaconteurPython.WrappedUserAuthenticator_swiginit(self, _RobotRaconteurPython.new_WrappedUserAuthenticator())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedUserAuthenticator

# Register WrappedUserAuthenticator in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedUserAuthenticator_swigregister(WrappedUserAuthenticator)

class AsyncServiceInfo2VectorReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncServiceInfo2VectorReturnDirector

    def handler(self, ret):
        return _RobotRaconteurPython.AsyncServiceInfo2VectorReturnDirector_handler(self, ret)

    def __init__(self):
        if self.__class__ == AsyncServiceInfo2VectorReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncServiceInfo2VectorReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncServiceInfo2VectorReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncServiceInfo2VectorReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncServiceInfo2VectorReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncServiceInfo2VectorReturnDirector_swigregister(AsyncServiceInfo2VectorReturnDirector)

class AsyncNodeInfo2VectorReturnDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_AsyncNodeInfo2VectorReturnDirector

    def handler(self, ret):
        return _RobotRaconteurPython.AsyncNodeInfo2VectorReturnDirector_handler(self, ret)

    def __init__(self):
        if self.__class__ == AsyncNodeInfo2VectorReturnDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.AsyncNodeInfo2VectorReturnDirector_swiginit(self, _RobotRaconteurPython.new_AsyncNodeInfo2VectorReturnDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_AsyncNodeInfo2VectorReturnDirector(self)
        return weakref.proxy(self)

# Register AsyncNodeInfo2VectorReturnDirector in _RobotRaconteurPython:
_RobotRaconteurPython.AsyncNodeInfo2VectorReturnDirector_swigregister(AsyncNodeInfo2VectorReturnDirector)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ServiceInfo2Wrapped(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.ServiceInfo2Wrapped_Name_get, _RobotRaconteurPython.ServiceInfo2Wrapped_Name_set)
    RootObjectType = property(_RobotRaconteurPython.ServiceInfo2Wrapped_RootObjectType_get, _RobotRaconteurPython.ServiceInfo2Wrapped_RootObjectType_set)
    RootObjectImplements = property(_RobotRaconteurPython.ServiceInfo2Wrapped_RootObjectImplements_get, _RobotRaconteurPython.ServiceInfo2Wrapped_RootObjectImplements_set)
    ConnectionURL = property(_RobotRaconteurPython.ServiceInfo2Wrapped_ConnectionURL_get, _RobotRaconteurPython.ServiceInfo2Wrapped_ConnectionURL_set)
    Attributes = property(_RobotRaconteurPython.ServiceInfo2Wrapped_Attributes_get, _RobotRaconteurPython.ServiceInfo2Wrapped_Attributes_set)
    NodeID = property(_RobotRaconteurPython.ServiceInfo2Wrapped_NodeID_get, _RobotRaconteurPython.ServiceInfo2Wrapped_NodeID_set)
    NodeName = property(_RobotRaconteurPython.ServiceInfo2Wrapped_NodeName_get, _RobotRaconteurPython.ServiceInfo2Wrapped_NodeName_set)

    def __init__(self):
        _RobotRaconteurPython.ServiceInfo2Wrapped_swiginit(self, _RobotRaconteurPython.new_ServiceInfo2Wrapped())
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceInfo2Wrapped

# Register ServiceInfo2Wrapped in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceInfo2Wrapped_swigregister(ServiceInfo2Wrapped)


def WrappedFindServiceByType(node, servicetype, transportschemes):
    return _RobotRaconteurPython.WrappedFindServiceByType(node, servicetype, transportschemes)

def AsyncWrappedFindServiceByType(node, servicetype, transportschemes, timeout, handler, id):
    return _RobotRaconteurPython.AsyncWrappedFindServiceByType(node, servicetype, transportschemes, timeout, handler, id)
class vectorserviceinfo2wrapped(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorserviceinfo2wrapped_swiginit(self, _RobotRaconteurPython.new_vectorserviceinfo2wrapped(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorserviceinfo2wrapped_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorserviceinfo2wrapped

# Register vectorserviceinfo2wrapped in _RobotRaconteurPython:
_RobotRaconteurPython.vectorserviceinfo2wrapped_swigregister(vectorserviceinfo2wrapped)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class NodeInfo2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    NodeID = property(_RobotRaconteurPython.NodeInfo2_NodeID_get, _RobotRaconteurPython.NodeInfo2_NodeID_set)
    NodeName = property(_RobotRaconteurPython.NodeInfo2_NodeName_get, _RobotRaconteurPython.NodeInfo2_NodeName_set)
    ConnectionURL = property(_RobotRaconteurPython.NodeInfo2_ConnectionURL_get, _RobotRaconteurPython.NodeInfo2_ConnectionURL_set)

    def __init__(self):
        _RobotRaconteurPython.NodeInfo2_swiginit(self, _RobotRaconteurPython.new_NodeInfo2())
    __swig_destroy__ = _RobotRaconteurPython.delete_NodeInfo2

# Register NodeInfo2 in _RobotRaconteurPython:
_RobotRaconteurPython.NodeInfo2_swigregister(NodeInfo2)


def WrappedFindNodeByID(node, id, transportschemes):
    return _RobotRaconteurPython.WrappedFindNodeByID(node, id, transportschemes)

def WrappedFindNodeByName(node, name, transportschemes):
    return _RobotRaconteurPython.WrappedFindNodeByName(node, name, transportschemes)

def AsyncWrappedFindNodeByID(node, id, transportschemes, timeout, handler, id1):
    return _RobotRaconteurPython.AsyncWrappedFindNodeByID(node, id, transportschemes, timeout, handler, id1)

def AsyncWrappedFindNodeByName(node, name, transportschemes, timeout, handler, id):
    return _RobotRaconteurPython.AsyncWrappedFindNodeByName(node, name, transportschemes, timeout, handler, id)

def WrappedUpdateDetectedNodes(node, schemes):
    return _RobotRaconteurPython.WrappedUpdateDetectedNodes(node, schemes)

def AsyncWrappedUpdateDetectedNodes(node, schemes, timeout, handler, id1):
    return _RobotRaconteurPython.AsyncWrappedUpdateDetectedNodes(node, schemes, timeout, handler, id1)

def WrappedGetDetectedNodes(node):
    return _RobotRaconteurPython.WrappedGetDetectedNodes(node)

def WrappedGetDetectedNodeCacheInfo(node, nodeid):
    return _RobotRaconteurPython.WrappedGetDetectedNodeCacheInfo(node, nodeid)

def WrappedTryGetDetectedNodeCacheInfo(node, nodeid, nodeinfo2):
    return _RobotRaconteurPython.WrappedTryGetDetectedNodeCacheInfo(node, nodeid, nodeinfo2)
class vectornodeinfo2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectornodeinfo2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectornodeinfo2___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectornodeinfo2___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectornodeinfo2___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectornodeinfo2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectornodeinfo2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectornodeinfo2_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectornodeinfo2_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectornodeinfo2_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectornodeinfo2_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectornodeinfo2_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectornodeinfo2_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectornodeinfo2_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectornodeinfo2_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectornodeinfo2_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectornodeinfo2_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectornodeinfo2_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectornodeinfo2_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectornodeinfo2_swiginit(self, _RobotRaconteurPython.new_vectornodeinfo2(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectornodeinfo2_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectornodeinfo2_front(self)

    def back(self):
        return _RobotRaconteurPython.vectornodeinfo2_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectornodeinfo2_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectornodeinfo2_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectornodeinfo2_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectornodeinfo2_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectornodeinfo2

# Register vectornodeinfo2 in _RobotRaconteurPython:
_RobotRaconteurPython.vectornodeinfo2_swigregister(vectornodeinfo2)

class map_subscriptionserviceinfo2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___getitem__(self, key)

    def __delitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___delitem__(self, key)

    def has_key(self, key):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_has_key(self, key)

    def keys(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_keys(self)

    def values(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_values(self)

    def items(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_items(self)

    def __contains__(self, key):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___contains__(self, key)

    def key_iterator(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_key_iterator(self)

    def value_iterator(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_value_iterator(self)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2___setitem__(self, *args)

    def asdict(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_asdict(self)

    def __init__(self, *args):
        _RobotRaconteurPython.map_subscriptionserviceinfo2_swiginit(self, _RobotRaconteurPython.new_map_subscriptionserviceinfo2(*args))

    def empty(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_empty(self)

    def size(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_begin(self)

    def end(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_rend(self)

    def clear(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_get_allocator(self)

    def count(self, x):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_count(self, x)

    def erase(self, *args):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_erase(self, *args)

    def find(self, x):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_find(self, x)

    def lower_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_lower_bound(self, x)

    def upper_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionserviceinfo2_upper_bound(self, x)
    __swig_destroy__ = _RobotRaconteurPython.delete_map_subscriptionserviceinfo2

# Register map_subscriptionserviceinfo2 in _RobotRaconteurPython:
_RobotRaconteurPython.map_subscriptionserviceinfo2_swigregister(map_subscriptionserviceinfo2)

class map_subscriptionclients(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.map_subscriptionclients_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.map_subscriptionclients___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.map_subscriptionclients___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.map_subscriptionclients___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionclients___getitem__(self, key)

    def __delitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionclients___delitem__(self, key)

    def has_key(self, key):
        return _RobotRaconteurPython.map_subscriptionclients_has_key(self, key)

    def keys(self):
        return _RobotRaconteurPython.map_subscriptionclients_keys(self)

    def values(self):
        return _RobotRaconteurPython.map_subscriptionclients_values(self)

    def items(self):
        return _RobotRaconteurPython.map_subscriptionclients_items(self)

    def __contains__(self, key):
        return _RobotRaconteurPython.map_subscriptionclients___contains__(self, key)

    def key_iterator(self):
        return _RobotRaconteurPython.map_subscriptionclients_key_iterator(self)

    def value_iterator(self):
        return _RobotRaconteurPython.map_subscriptionclients_value_iterator(self)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.map_subscriptionclients___setitem__(self, *args)

    def asdict(self):
        return _RobotRaconteurPython.map_subscriptionclients_asdict(self)

    def __init__(self, *args):
        _RobotRaconteurPython.map_subscriptionclients_swiginit(self, _RobotRaconteurPython.new_map_subscriptionclients(*args))

    def empty(self):
        return _RobotRaconteurPython.map_subscriptionclients_empty(self)

    def size(self):
        return _RobotRaconteurPython.map_subscriptionclients_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.map_subscriptionclients_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.map_subscriptionclients_begin(self)

    def end(self):
        return _RobotRaconteurPython.map_subscriptionclients_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.map_subscriptionclients_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.map_subscriptionclients_rend(self)

    def clear(self):
        return _RobotRaconteurPython.map_subscriptionclients_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.map_subscriptionclients_get_allocator(self)

    def count(self, x):
        return _RobotRaconteurPython.map_subscriptionclients_count(self, x)

    def erase(self, *args):
        return _RobotRaconteurPython.map_subscriptionclients_erase(self, *args)

    def find(self, x):
        return _RobotRaconteurPython.map_subscriptionclients_find(self, x)

    def lower_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionclients_lower_bound(self, x)

    def upper_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionclients_upper_bound(self, x)
    __swig_destroy__ = _RobotRaconteurPython.delete_map_subscriptionclients

# Register map_subscriptionclients in _RobotRaconteurPython:
_RobotRaconteurPython.map_subscriptionclients_swigregister(map_subscriptionclients)

class vectorptr_wrappedservicesubscriptionnode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_swiginit(self, _RobotRaconteurPython.new_vectorptr_wrappedservicesubscriptionnode(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_wrappedservicesubscriptionnode

# Register vectorptr_wrappedservicesubscriptionnode in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_wrappedservicesubscriptionnode_swigregister(vectorptr_wrappedservicesubscriptionnode)

class vectorptr_subscriptionclientid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_empty(self)

    def size(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_begin(self)

    def end(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vectorptr_subscriptionclientid_swiginit(self, _RobotRaconteurPython.new_vectorptr_subscriptionclientid(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_front(self)

    def back(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vectorptr_subscriptionclientid_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vectorptr_subscriptionclientid

# Register vectorptr_subscriptionclientid in _RobotRaconteurPython:
_RobotRaconteurPython.vectorptr_subscriptionclientid_swigregister(vectorptr_subscriptionclientid)

class ServiceSubscriptionFilterAttribute(object):
    r"""

    ServiceSubscriptionFilterAttribute()

    Subscription filter attribute for use with ServiceSubscriptionFilter

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Name = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttribute_Name_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttribute_Name_set, doc=r"""(str) The attribute name. Empty for no name""")
    Value = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttribute_Value_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttribute_Value_set, doc=r"""(str) The string value for the attribute""")
    UseRegex = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttribute_UseRegex_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttribute_UseRegex_set)

    def __init__(self, *args):
        _RobotRaconteurPython.ServiceSubscriptionFilterAttribute_swiginit(self, _RobotRaconteurPython.new_ServiceSubscriptionFilterAttribute(*args))

    def IsMatch(self, *args):
        return _RobotRaconteurPython.ServiceSubscriptionFilterAttribute_IsMatch(self, *args)
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceSubscriptionFilterAttribute

# Register ServiceSubscriptionFilterAttribute in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceSubscriptionFilterAttribute_swigregister(ServiceSubscriptionFilterAttribute)


def CreateServiceSubscriptionFilterAttributeRegex(*args):
    return _RobotRaconteurPython.CreateServiceSubscriptionFilterAttributeRegex(*args)
class vector_subscriptionattribute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.vector_subscriptionattribute___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.vector_subscriptionattribute___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.vector_subscriptionattribute___len__(self)

    def __getslice__(self, i, j):
        return _RobotRaconteurPython.vector_subscriptionattribute___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _RobotRaconteurPython.vector_subscriptionattribute___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute___delitem__(self, *args)

    def __getitem__(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute___getitem__(self, *args)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute___setitem__(self, *args)

    def pop(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_pop(self)

    def append(self, x):
        return _RobotRaconteurPython.vector_subscriptionattribute_append(self, x)

    def empty(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_empty(self)

    def size(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.vector_subscriptionattribute_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_begin(self)

    def end(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_rend(self)

    def clear(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_get_allocator(self)

    def pop_back(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_pop_back(self)

    def erase(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute_erase(self, *args)

    def __init__(self, *args):
        _RobotRaconteurPython.vector_subscriptionattribute_swiginit(self, _RobotRaconteurPython.new_vector_subscriptionattribute(*args))

    def push_back(self, x):
        return _RobotRaconteurPython.vector_subscriptionattribute_push_back(self, x)

    def front(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_front(self)

    def back(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_back(self)

    def assign(self, n, x):
        return _RobotRaconteurPython.vector_subscriptionattribute_assign(self, n, x)

    def resize(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute_resize(self, *args)

    def insert(self, *args):
        return _RobotRaconteurPython.vector_subscriptionattribute_insert(self, *args)

    def reserve(self, n):
        return _RobotRaconteurPython.vector_subscriptionattribute_reserve(self, n)

    def capacity(self):
        return _RobotRaconteurPython.vector_subscriptionattribute_capacity(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_vector_subscriptionattribute

# Register vector_subscriptionattribute in _RobotRaconteurPython:
_RobotRaconteurPython.vector_subscriptionattribute_swigregister(vector_subscriptionattribute)

class map_subscriptionattribute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.map_subscriptionattribute_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.map_subscriptionattribute___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.map_subscriptionattribute___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.map_subscriptionattribute___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionattribute___getitem__(self, key)

    def __delitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionattribute___delitem__(self, key)

    def has_key(self, key):
        return _RobotRaconteurPython.map_subscriptionattribute_has_key(self, key)

    def keys(self):
        return _RobotRaconteurPython.map_subscriptionattribute_keys(self)

    def values(self):
        return _RobotRaconteurPython.map_subscriptionattribute_values(self)

    def items(self):
        return _RobotRaconteurPython.map_subscriptionattribute_items(self)

    def __contains__(self, key):
        return _RobotRaconteurPython.map_subscriptionattribute___contains__(self, key)

    def key_iterator(self):
        return _RobotRaconteurPython.map_subscriptionattribute_key_iterator(self)

    def value_iterator(self):
        return _RobotRaconteurPython.map_subscriptionattribute_value_iterator(self)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.map_subscriptionattribute___setitem__(self, *args)

    def asdict(self):
        return _RobotRaconteurPython.map_subscriptionattribute_asdict(self)

    def __init__(self, *args):
        _RobotRaconteurPython.map_subscriptionattribute_swiginit(self, _RobotRaconteurPython.new_map_subscriptionattribute(*args))

    def empty(self):
        return _RobotRaconteurPython.map_subscriptionattribute_empty(self)

    def size(self):
        return _RobotRaconteurPython.map_subscriptionattribute_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.map_subscriptionattribute_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.map_subscriptionattribute_begin(self)

    def end(self):
        return _RobotRaconteurPython.map_subscriptionattribute_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.map_subscriptionattribute_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.map_subscriptionattribute_rend(self)

    def clear(self):
        return _RobotRaconteurPython.map_subscriptionattribute_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.map_subscriptionattribute_get_allocator(self)

    def count(self, x):
        return _RobotRaconteurPython.map_subscriptionattribute_count(self, x)

    def erase(self, *args):
        return _RobotRaconteurPython.map_subscriptionattribute_erase(self, *args)

    def find(self, x):
        return _RobotRaconteurPython.map_subscriptionattribute_find(self, x)

    def lower_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionattribute_lower_bound(self, x)

    def upper_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionattribute_upper_bound(self, x)
    __swig_destroy__ = _RobotRaconteurPython.delete_map_subscriptionattribute

# Register map_subscriptionattribute in _RobotRaconteurPython:
_RobotRaconteurPython.map_subscriptionattribute_swigregister(map_subscriptionattribute)

ServiceSubscriptionFilterAttributeGroupOperation_OR = _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroupOperation_OR
r"""OR operation"""
ServiceSubscriptionFilterAttributeGroupOperation_AND = _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroupOperation_AND
r"""AND operation"""
ServiceSubscriptionFilterAttributeGroupOperation_NOR = _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroupOperation_NOR
r"""NOR operation. Also used for NOT"""
ServiceSubscriptionFilterAttributeGroupOperation_NAND = _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroupOperation_NAND
r"""NAND operation"""
class ServiceSubscriptionFilterAttributeGroup(object):
    r"""

    ServiceSubscriptionFilterAttributeGroup()

    Subscription filter attribute group for use with ServiceSubscriptionFilter

    Used to combine multiple ServiceSubscriptionFilterAttribute objects for comparison using
    AND, OR, NOR, or NAND logic. Other groups can be nested, to allow for complex comparisons.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Attributes = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_Attributes_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_Attributes_set, doc=r"""(list) The list of attributes in the group""")
    Groups = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_Groups_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_Groups_set, doc=r"""(list) The nested groups in the group""")
    Operation = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_Operation_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_Operation_set, doc=r"""(RobotRaconteur.ServiceSubscriptionFilterAttributeGroupOperation) The operation to use to combine the attributes""")
    SplitStringAttribute = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_SplitStringAttribute_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_SplitStringAttribute_set, doc=r"""(bool) True if string attributes will be split into a list with delimiter (default ',')""")
    SplitStringDelimiter = property(_RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_SplitStringDelimiter_get, _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_SplitStringDelimiter_set, doc=r"""(str) The delimiter to use for splitting string attributes (default ',')""")

    def __init__(self, *args):
        _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_swiginit(self, _RobotRaconteurPython.new_ServiceSubscriptionFilterAttributeGroup(*args))

    def IsMatch(self, *args):
        return _RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_IsMatch(self, *args)
    __swig_destroy__ = _RobotRaconteurPython.delete_ServiceSubscriptionFilterAttributeGroup

# Register ServiceSubscriptionFilterAttributeGroup in _RobotRaconteurPython:
_RobotRaconteurPython.ServiceSubscriptionFilterAttributeGroup_swigregister(ServiceSubscriptionFilterAttributeGroup)

class map_subscriptionattributegroup(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup___nonzero__(self)

    def __bool__(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup___bool__(self)

    def __len__(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionattributegroup___getitem__(self, key)

    def __delitem__(self, key):
        return _RobotRaconteurPython.map_subscriptionattributegroup___delitem__(self, key)

    def has_key(self, key):
        return _RobotRaconteurPython.map_subscriptionattributegroup_has_key(self, key)

    def keys(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_keys(self)

    def values(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_values(self)

    def items(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_items(self)

    def __contains__(self, key):
        return _RobotRaconteurPython.map_subscriptionattributegroup___contains__(self, key)

    def key_iterator(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_key_iterator(self)

    def value_iterator(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_value_iterator(self)

    def __setitem__(self, *args):
        return _RobotRaconteurPython.map_subscriptionattributegroup___setitem__(self, *args)

    def asdict(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_asdict(self)

    def __init__(self, *args):
        _RobotRaconteurPython.map_subscriptionattributegroup_swiginit(self, _RobotRaconteurPython.new_map_subscriptionattributegroup(*args))

    def empty(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_empty(self)

    def size(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_size(self)

    def swap(self, v):
        return _RobotRaconteurPython.map_subscriptionattributegroup_swap(self, v)

    def begin(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_begin(self)

    def end(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_end(self)

    def rbegin(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_rbegin(self)

    def rend(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_rend(self)

    def clear(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_clear(self)

    def get_allocator(self):
        return _RobotRaconteurPython.map_subscriptionattributegroup_get_allocator(self)

    def count(self, x):
        return _RobotRaconteurPython.map_subscriptionattributegroup_count(self, x)

    def erase(self, *args):
        return _RobotRaconteurPython.map_subscriptionattributegroup_erase(self, *args)

    def find(self, x):
        return _RobotRaconteurPython.map_subscriptionattributegroup_find(self, x)

    def lower_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionattributegroup_lower_bound(self, x)

    def upper_bound(self, x):
        return _RobotRaconteurPython.map_subscriptionattributegroup_upper_bound(self, x)
    __swig_destroy__ = _RobotRaconteurPython.delete_map_subscriptionattributegroup

# Register map_subscriptionattributegroup in _RobotRaconteurPython:
_RobotRaconteurPython.map_subscriptionattributegroup_swigregister(map_subscriptionattributegroup)

class WrappedServiceSubscriptionFilterPredicateDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Predicate(self, info):
        return _RobotRaconteurPython.WrappedServiceSubscriptionFilterPredicateDirector_Predicate(self, info)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscriptionFilterPredicateDirector

    def __init__(self):
        if self.__class__ == WrappedServiceSubscriptionFilterPredicateDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedServiceSubscriptionFilterPredicateDirector_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSubscriptionFilterPredicateDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedServiceSubscriptionFilterPredicateDirector(self)
        return weakref.proxy(self)

# Register WrappedServiceSubscriptionFilterPredicateDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscriptionFilterPredicateDirector_swigregister(WrappedServiceSubscriptionFilterPredicateDirector)

class WrappedServiceSubscriptionFilterNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NodeID = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_NodeID_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_NodeID_set)
    NodeName = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_NodeName_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_NodeName_set)
    Username = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_Username_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_Username_set)
    Credentials = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_Credentials_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_Credentials_set)

    def __init__(self):
        _RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSubscriptionFilterNode())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscriptionFilterNode

# Register WrappedServiceSubscriptionFilterNode in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscriptionFilterNode_swigregister(WrappedServiceSubscriptionFilterNode)

class WrappedServiceSubscriptionFilter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Nodes = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilter_Nodes_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilter_Nodes_set)
    ServiceNames = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilter_ServiceNames_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilter_ServiceNames_set)
    TransportSchemes = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilter_TransportSchemes_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilter_TransportSchemes_set)
    Attributes = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilter_Attributes_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilter_Attributes_set)
    AttributesMatchOperation = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilter_AttributesMatchOperation_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilter_AttributesMatchOperation_set)

    def SetRRPredicateDirector(self, director, id):
        return _RobotRaconteurPython.WrappedServiceSubscriptionFilter_SetRRPredicateDirector(self, director, id)
    MaxConnections = property(_RobotRaconteurPython.WrappedServiceSubscriptionFilter_MaxConnections_get, _RobotRaconteurPython.WrappedServiceSubscriptionFilter_MaxConnections_set)

    def __init__(self):
        _RobotRaconteurPython.WrappedServiceSubscriptionFilter_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSubscriptionFilter())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscriptionFilter

# Register WrappedServiceSubscriptionFilter in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscriptionFilter_swigregister(WrappedServiceSubscriptionFilter)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class WrappedServiceSubscriptionClientID(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeID = property(_RobotRaconteurPython.WrappedServiceSubscriptionClientID_NodeID_get, _RobotRaconteurPython.WrappedServiceSubscriptionClientID_NodeID_set)
    ServiceName = property(_RobotRaconteurPython.WrappedServiceSubscriptionClientID_ServiceName_get, _RobotRaconteurPython.WrappedServiceSubscriptionClientID_ServiceName_set)

    def eq(self, id2):
        return _RobotRaconteurPython.WrappedServiceSubscriptionClientID_eq(self, id2)

    def ne(self, id2):
        return _RobotRaconteurPython.WrappedServiceSubscriptionClientID_ne(self, id2)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscriptionClientID

# Register WrappedServiceSubscriptionClientID in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscriptionClientID_swigregister(WrappedServiceSubscriptionClientID)

class WrappedServiceInfo2SubscriptionDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def ServiceDetected(self, subscription, id, service):
        return _RobotRaconteurPython.WrappedServiceInfo2SubscriptionDirector_ServiceDetected(self, subscription, id, service)

    def ServiceLost(self, subscription, id, service):
        return _RobotRaconteurPython.WrappedServiceInfo2SubscriptionDirector_ServiceLost(self, subscription, id, service)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceInfo2SubscriptionDirector

    def __init__(self):
        if self.__class__ == WrappedServiceInfo2SubscriptionDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedServiceInfo2SubscriptionDirector_swiginit(self, _RobotRaconteurPython.new_WrappedServiceInfo2SubscriptionDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedServiceInfo2SubscriptionDirector(self)
        return weakref.proxy(self)

# Register WrappedServiceInfo2SubscriptionDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceInfo2SubscriptionDirector_swigregister(WrappedServiceInfo2SubscriptionDirector)

class WrappedServiceInfo2Subscription(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetDetectedServiceInfo2(self):
        return _RobotRaconteurPython.WrappedServiceInfo2Subscription_GetDetectedServiceInfo2(self)

    def Close(self):
        return _RobotRaconteurPython.WrappedServiceInfo2Subscription_Close(self)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedServiceInfo2Subscription_SetRRDirector(self, director, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedServiceInfo2Subscription_GetNode(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceInfo2Subscription

# Register WrappedServiceInfo2Subscription in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceInfo2Subscription_swigregister(WrappedServiceInfo2Subscription)

class WrappedServiceSubscriptionDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def ClientConnected(self, subscription, id, slient):
        return _RobotRaconteurPython.WrappedServiceSubscriptionDirector_ClientConnected(self, subscription, id, slient)

    def ClientDisconnected(self, subscription, id, slient):
        return _RobotRaconteurPython.WrappedServiceSubscriptionDirector_ClientDisconnected(self, subscription, id, slient)

    def ClientConnectFailed(self, subscription, id, url, error):
        return _RobotRaconteurPython.WrappedServiceSubscriptionDirector_ClientConnectFailed(self, subscription, id, url, error)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscriptionDirector

    def __init__(self):
        if self.__class__ == WrappedServiceSubscriptionDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedServiceSubscriptionDirector_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSubscriptionDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedServiceSubscriptionDirector(self)
        return weakref.proxy(self)

# Register WrappedServiceSubscriptionDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscriptionDirector_swigregister(WrappedServiceSubscriptionDirector)

class WrappedServiceSubscription_TryDefaultClientRes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    res = property(_RobotRaconteurPython.WrappedServiceSubscription_TryDefaultClientRes_res_get, _RobotRaconteurPython.WrappedServiceSubscription_TryDefaultClientRes_res_set)
    client = property(_RobotRaconteurPython.WrappedServiceSubscription_TryDefaultClientRes_client_get, _RobotRaconteurPython.WrappedServiceSubscription_TryDefaultClientRes_client_set)

    def __init__(self):
        _RobotRaconteurPython.WrappedServiceSubscription_TryDefaultClientRes_swiginit(self, _RobotRaconteurPython.new_WrappedServiceSubscription_TryDefaultClientRes())
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscription_TryDefaultClientRes

# Register WrappedServiceSubscription_TryDefaultClientRes in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscription_TryDefaultClientRes_swigregister(WrappedServiceSubscription_TryDefaultClientRes)

class WrappedServiceSubscription(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetConnectedClients(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_GetConnectedClients(self)

    def Close(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_Close(self)

    def ClaimClient(self, client):
        return _RobotRaconteurPython.WrappedServiceSubscription_ClaimClient(self, client)

    def ReleaseClient(self, client):
        return _RobotRaconteurPython.WrappedServiceSubscription_ReleaseClient(self, client)

    def GetConnectRetryDelay(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_GetConnectRetryDelay(self)

    def SetConnectRetryDelay(self, delay_milliseconds):
        return _RobotRaconteurPython.WrappedServiceSubscription_SetConnectRetryDelay(self, delay_milliseconds)

    def SubscribeWire(self, membername, servicepath):
        return _RobotRaconteurPython.WrappedServiceSubscription_SubscribeWire(self, membername, servicepath)

    def SubscribePipe(self, membername, servicepath, max_recv_packets=-1):
        return _RobotRaconteurPython.WrappedServiceSubscription_SubscribePipe(self, membername, servicepath, max_recv_packets)

    def GetDefaultClient(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_GetDefaultClient(self)

    def TryGetDefaultClient(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_TryGetDefaultClient(self)

    def GetDefaultClientWait(self, timeout=-1):
        return _RobotRaconteurPython.WrappedServiceSubscription_GetDefaultClientWait(self, timeout)

    def TryGetDefaultClientWait(self, timeout=-1):
        return _RobotRaconteurPython.WrappedServiceSubscription_TryGetDefaultClientWait(self, timeout)

    def AsyncGetDefaultClient(self, timeout, handler, id):
        return _RobotRaconteurPython.WrappedServiceSubscription_AsyncGetDefaultClient(self, timeout, handler, id)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedServiceSubscription_SetRRDirector(self, director, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_GetNode(self)

    def GetServiceURL(self):
        return _RobotRaconteurPython.WrappedServiceSubscription_GetServiceURL(self)

    def UpdateServiceURL(self, *args):
        return _RobotRaconteurPython.WrappedServiceSubscription_UpdateServiceURL(self, *args)

    def UpdateServiceByType(self, *args):
        return _RobotRaconteurPython.WrappedServiceSubscription_UpdateServiceByType(self, *args)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedServiceSubscription

# Register WrappedServiceSubscription in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedServiceSubscription_swigregister(WrappedServiceSubscription)

class WrappedWireSubscriptionDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def WireValueChanged(self, wire_subscription, value, time):
        return _RobotRaconteurPython.WrappedWireSubscriptionDirector_WireValueChanged(self, wire_subscription, value, time)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireSubscriptionDirector

    def __init__(self):
        if self.__class__ == WrappedWireSubscriptionDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedWireSubscriptionDirector_swiginit(self, _RobotRaconteurPython.new_WrappedWireSubscriptionDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedWireSubscriptionDirector(self)
        return weakref.proxy(self)

# Register WrappedWireSubscriptionDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireSubscriptionDirector_swigregister(WrappedWireSubscriptionDirector)

class WrappedWireSubscription(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetInValue(self, time=None):
        return _RobotRaconteurPython.WrappedWireSubscription_GetInValue(self, time)

    def TryGetInValue(self, val, time=None):
        return _RobotRaconteurPython.WrappedWireSubscription_TryGetInValue(self, val, time)

    def WaitInValueValid(self, *args):
        return _RobotRaconteurPython.WrappedWireSubscription_WaitInValueValid(self, *args)

    def GetIgnoreInValue(self):
        return _RobotRaconteurPython.WrappedWireSubscription_GetIgnoreInValue(self)

    def SetIgnoreInValue(self, ignore):
        return _RobotRaconteurPython.WrappedWireSubscription_SetIgnoreInValue(self, ignore)

    def GetInValueLifespan(self):
        return _RobotRaconteurPython.WrappedWireSubscription_GetInValueLifespan(self)

    def SetInValueLifespan(self, millis):
        return _RobotRaconteurPython.WrappedWireSubscription_SetInValueLifespan(self, millis)

    def GetActiveWireConnectionCount(self):
        return _RobotRaconteurPython.WrappedWireSubscription_GetActiveWireConnectionCount(self)

    def Close(self):
        return _RobotRaconteurPython.WrappedWireSubscription_Close(self)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedWireSubscription_SetRRDirector(self, director, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedWireSubscription_GetNode(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireSubscription

# Register WrappedWireSubscription in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireSubscription_swigregister(WrappedWireSubscription)

class WrappedWireSubscription_send_iterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sub):
        _RobotRaconteurPython.WrappedWireSubscription_send_iterator_swiginit(self, _RobotRaconteurPython.new_WrappedWireSubscription_send_iterator(sub))

    def Next(self):
        return _RobotRaconteurPython.WrappedWireSubscription_send_iterator_Next(self)

    def SetOutValue(self, value):
        return _RobotRaconteurPython.WrappedWireSubscription_send_iterator_SetOutValue(self, value)

    def GetType(self):
        return _RobotRaconteurPython.WrappedWireSubscription_send_iterator_GetType(self)

    def GetStub(self):
        return _RobotRaconteurPython.WrappedWireSubscription_send_iterator_GetStub(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedWireSubscription_send_iterator

# Register WrappedWireSubscription_send_iterator in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedWireSubscription_send_iterator_swigregister(WrappedWireSubscription_send_iterator)

class WrappedPipeSubscriptionDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def PipePacketReceived(self, pipe_subscription):
        return _RobotRaconteurPython.WrappedPipeSubscriptionDirector_PipePacketReceived(self, pipe_subscription)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeSubscriptionDirector

    def __init__(self):
        if self.__class__ == WrappedPipeSubscriptionDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.WrappedPipeSubscriptionDirector_swiginit(self, _RobotRaconteurPython.new_WrappedPipeSubscriptionDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_WrappedPipeSubscriptionDirector(self)
        return weakref.proxy(self)

# Register WrappedPipeSubscriptionDirector in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeSubscriptionDirector_swigregister(WrappedPipeSubscriptionDirector)

class WrappedPipeSubscription(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ReceivePacket(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_ReceivePacket(self)

    def TryReceivePacket(self, packet):
        return _RobotRaconteurPython.WrappedPipeSubscription_TryReceivePacket(self, packet)

    def TryReceivePacketWait(self, *args):
        return _RobotRaconteurPython.WrappedPipeSubscription_TryReceivePacketWait(self, *args)

    def Available(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_Available(self)

    def GetActivePipeEndpointCount(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_GetActivePipeEndpointCount(self)

    def GetIgnoreReceived(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_GetIgnoreReceived(self)

    def SetIgnoreReceived(self, ignore):
        return _RobotRaconteurPython.WrappedPipeSubscription_SetIgnoreReceived(self, ignore)

    def Close(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_Close(self)

    def SetRRDirector(self, director, id):
        return _RobotRaconteurPython.WrappedPipeSubscription_SetRRDirector(self, director, id)

    def GetNode(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_GetNode(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeSubscription

# Register WrappedPipeSubscription in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeSubscription_swigregister(WrappedPipeSubscription)

class WrappedPipeSubscription_send_iterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sub):
        _RobotRaconteurPython.WrappedPipeSubscription_send_iterator_swiginit(self, _RobotRaconteurPython.new_WrappedPipeSubscription_send_iterator(sub))

    def Next(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_send_iterator_Next(self)

    def AsyncSendPacket(self, value):
        return _RobotRaconteurPython.WrappedPipeSubscription_send_iterator_AsyncSendPacket(self, value)

    def GetType(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_send_iterator_GetType(self)

    def GetStub(self):
        return _RobotRaconteurPython.WrappedPipeSubscription_send_iterator_GetStub(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedPipeSubscription_send_iterator

# Register WrappedPipeSubscription_send_iterator in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedPipeSubscription_send_iterator_swigregister(WrappedPipeSubscription_send_iterator)


def WrappedServiceInfo2SubscriptionServicesToVector(infos):
    return _RobotRaconteurPython.WrappedServiceInfo2SubscriptionServicesToVector(infos)

def WrappedSubscribeServiceInfo2(*args):
    return _RobotRaconteurPython.WrappedSubscribeServiceInfo2(*args)

def WrappedServiceSubscriptionClientsToVector(clients):
    return _RobotRaconteurPython.WrappedServiceSubscriptionClientsToVector(clients)

def WrappedSubscribeServiceByType(*args):
    return _RobotRaconteurPython.WrappedSubscribeServiceByType(*args)

def WrappedSubscribeService(*args):
    return _RobotRaconteurPython.WrappedSubscribeService(*args)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class RRLogRecord(object):
    r"""

    Robot Raconteur log record

    Records information about a logging event

    See \ref logging for more information.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def _GetNode(self):
        return _RobotRaconteurPython.RRLogRecord__GetNode(self)

    def _SetNode(self, node):
        return _RobotRaconteurPython.RRLogRecord__SetNode(self, node)
    Level = property(_RobotRaconteurPython.RRLogRecord_Level_get, _RobotRaconteurPython.RRLogRecord_Level_set, doc=r"""(int) The log level """)
    Component = property(_RobotRaconteurPython.RRLogRecord_Component_get, _RobotRaconteurPython.RRLogRecord_Component_set, doc=r"""(int) The source component""")
    ComponentName = property(_RobotRaconteurPython.RRLogRecord_ComponentName_get, _RobotRaconteurPython.RRLogRecord_ComponentName_set, doc=r"""(str) The source component name""")
    ComponentObjectID = property(_RobotRaconteurPython.RRLogRecord_ComponentObjectID_get, _RobotRaconteurPython.RRLogRecord_ComponentObjectID_set, doc=r"""(str) The source component object ID""")
    Endpoint = property(_RobotRaconteurPython.RRLogRecord_Endpoint_get, _RobotRaconteurPython.RRLogRecord_Endpoint_set, doc=r"""(int) The source endpoint""")
    ServicePath = property(_RobotRaconteurPython.RRLogRecord_ServicePath_get, _RobotRaconteurPython.RRLogRecord_ServicePath_set, doc=r"""(str) The service path of the source object""")
    Member = property(_RobotRaconteurPython.RRLogRecord_Member_get, _RobotRaconteurPython.RRLogRecord_Member_set, doc=r"""(str) The source member""")
    Message = property(_RobotRaconteurPython.RRLogRecord_Message_get, _RobotRaconteurPython.RRLogRecord_Message_set, doc=r"""(str) Human readable log message""")
    Time = property(_RobotRaconteurPython.RRLogRecord_Time_get, _RobotRaconteurPython.RRLogRecord_Time_set, doc=r"""(datetime.datetime) Time of logging event""")
    SourceFile = property(_RobotRaconteurPython.RRLogRecord_SourceFile_get, _RobotRaconteurPython.RRLogRecord_SourceFile_set, doc=r"""(str) The sourcecode filename""")
    SourceLine = property(_RobotRaconteurPython.RRLogRecord_SourceLine_get, _RobotRaconteurPython.RRLogRecord_SourceLine_set, doc=r"""(int) The line within the sourcecode file""")
    ThreadID = property(_RobotRaconteurPython.RRLogRecord_ThreadID_get, _RobotRaconteurPython.RRLogRecord_ThreadID_set, doc=r"""(str) The source thread""")
    FiberID = property(_RobotRaconteurPython.RRLogRecord_FiberID_get, _RobotRaconteurPython.RRLogRecord_FiberID_set, doc=r"""(str) The source coroutine fiber""")

    def __str__(self):
        return _RobotRaconteurPython.RRLogRecord___str__(self)

    Node = property(lambda self: self._GetNode(), lambda self,node: self._SetNode(node), doc = """(RobotRaconteur.RobotRaconteurNode) The source node""")


    def __init__(self):
        _RobotRaconteurPython.RRLogRecord_swiginit(self, _RobotRaconteurPython.new_RRLogRecord())
    __swig_destroy__ = _RobotRaconteurPython.delete_RRLogRecord

# Register RRLogRecord in _RobotRaconteurPython:
_RobotRaconteurPython.RRLogRecord_swigregister(RRLogRecord)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class LogRecordHandler(object):
    r"""

    LogRecordHandler()

    Base class of log record handler

    By default, RobotRaconteurNode will print log records to ``stderr``. Use
    RobotRaconteur.RobotRaconteurNode.SetLogRecordHandler() to specify a LogRecordHandler
    to accept log records instead of printing them to the terminal.

    See \ref logging for more information.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_LogRecordHandler

# Register LogRecordHandler in _RobotRaconteurPython:
_RobotRaconteurPython.LogRecordHandler_swigregister(LogRecordHandler)

class FileLogRecordHandler(object):
    r"""

    Log record handler that saves to a file

    See \ref logging for more information.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def OpenFile(self, filename, append=True):
        r"""

        Open a file to store log records

        :param filename: The filename
        :type filename: str
        :param append: If True, log messages are appended. If False, the file is truncated when opened
        :type append: bool

        """
        return _RobotRaconteurPython.FileLogRecordHandler_OpenFile(self, filename, append)

    def __init__(self):
        _RobotRaconteurPython.FileLogRecordHandler_swiginit(self, _RobotRaconteurPython.new_FileLogRecordHandler())
    __swig_destroy__ = _RobotRaconteurPython.delete_FileLogRecordHandler

# Register FileLogRecordHandler in _RobotRaconteurPython:
_RobotRaconteurPython.FileLogRecordHandler_swigregister(FileLogRecordHandler)

class UserLogRecordHandlerDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def HandleLogRecord(self, record):
        return _RobotRaconteurPython.UserLogRecordHandlerDirector_HandleLogRecord(self, record)
    __swig_destroy__ = _RobotRaconteurPython.delete_UserLogRecordHandlerDirector

    def __init__(self):
        if self.__class__ == UserLogRecordHandlerDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.UserLogRecordHandlerDirector_swiginit(self, _RobotRaconteurPython.new_UserLogRecordHandlerDirector(_self, ))
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_UserLogRecordHandlerDirector(self)
        return weakref.proxy(self)

# Register UserLogRecordHandlerDirector in _RobotRaconteurPython:
_RobotRaconteurPython.UserLogRecordHandlerDirector_swigregister(UserLogRecordHandlerDirector)

class UserLogRecordHandlerBase(LogRecordHandler):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def _SetHandler(self, director, id):
        return _RobotRaconteurPython.UserLogRecordHandlerBase__SetHandler(self, director, id)

    def __init__(self):
        _RobotRaconteurPython.UserLogRecordHandlerBase_swiginit(self, _RobotRaconteurPython.new_UserLogRecordHandlerBase())
    __swig_destroy__ = _RobotRaconteurPython.delete_UserLogRecordHandlerBase

# Register UserLogRecordHandlerBase in _RobotRaconteurPython:
_RobotRaconteurPython.UserLogRecordHandlerBase_swigregister(UserLogRecordHandlerBase)

class NodeDirectories(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    system_data_dir = property(_RobotRaconteurPython.NodeDirectories_system_data_dir_get, _RobotRaconteurPython.NodeDirectories_system_data_dir_set)
    system_config_dir = property(_RobotRaconteurPython.NodeDirectories_system_config_dir_get, _RobotRaconteurPython.NodeDirectories_system_config_dir_set)
    system_state_dir = property(_RobotRaconteurPython.NodeDirectories_system_state_dir_get, _RobotRaconteurPython.NodeDirectories_system_state_dir_set)
    system_cache_dir = property(_RobotRaconteurPython.NodeDirectories_system_cache_dir_get, _RobotRaconteurPython.NodeDirectories_system_cache_dir_set)
    system_run_dir = property(_RobotRaconteurPython.NodeDirectories_system_run_dir_get, _RobotRaconteurPython.NodeDirectories_system_run_dir_set)
    user_data_dir = property(_RobotRaconteurPython.NodeDirectories_user_data_dir_get, _RobotRaconteurPython.NodeDirectories_user_data_dir_set)
    user_config_dir = property(_RobotRaconteurPython.NodeDirectories_user_config_dir_get, _RobotRaconteurPython.NodeDirectories_user_config_dir_set)
    user_state_dir = property(_RobotRaconteurPython.NodeDirectories_user_state_dir_get, _RobotRaconteurPython.NodeDirectories_user_state_dir_set)
    user_cache_dir = property(_RobotRaconteurPython.NodeDirectories_user_cache_dir_get, _RobotRaconteurPython.NodeDirectories_user_cache_dir_set)
    user_run_dir = property(_RobotRaconteurPython.NodeDirectories_user_run_dir_get, _RobotRaconteurPython.NodeDirectories_user_run_dir_set)

    def __init__(self):
        _RobotRaconteurPython.NodeDirectories_swiginit(self, _RobotRaconteurPython.new_NodeDirectories())
    __swig_destroy__ = _RobotRaconteurPython.delete_NodeDirectories

# Register NodeDirectories in _RobotRaconteurPython:
_RobotRaconteurPython.NodeDirectories_swigregister(NodeDirectories)

class NodeDirectoriesFD(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _RobotRaconteurPython.delete_NodeDirectoriesFD

# Register NodeDirectoriesFD in _RobotRaconteurPython:
_RobotRaconteurPython.NodeDirectoriesFD_swigregister(NodeDirectoriesFD)

class NodeDirectoriesUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def GetDefaultNodeDirectories(*args):
        return _RobotRaconteurPython.NodeDirectoriesUtil_GetDefaultNodeDirectories(*args)

    @staticmethod
    def GetLogonUserName():
        return _RobotRaconteurPython.NodeDirectoriesUtil_GetLogonUserName()

    @staticmethod
    def IsLogonUserRoot():
        return _RobotRaconteurPython.NodeDirectoriesUtil_IsLogonUserRoot()

    @staticmethod
    def ReadInfoFile(fname, data):
        return _RobotRaconteurPython.NodeDirectoriesUtil_ReadInfoFile(fname, data)

    @staticmethod
    def CreatePidFile(path):
        return _RobotRaconteurPython.NodeDirectoriesUtil_CreatePidFile(path)

    @staticmethod
    def CreateInfoFile(path, info):
        return _RobotRaconteurPython.NodeDirectoriesUtil_CreateInfoFile(path, info)

    @staticmethod
    def RefreshInfoFile(h_info, updated_info):
        return _RobotRaconteurPython.NodeDirectoriesUtil_RefreshInfoFile(h_info, updated_info)

    def __init__(self):
        _RobotRaconteurPython.NodeDirectoriesUtil_swiginit(self, _RobotRaconteurPython.new_NodeDirectoriesUtil())
    __swig_destroy__ = _RobotRaconteurPython.delete_NodeDirectoriesUtil

# Register NodeDirectoriesUtil in _RobotRaconteurPython:
_RobotRaconteurPython.NodeDirectoriesUtil_swigregister(NodeDirectoriesUtil)

def NodeDirectoriesUtil_GetDefaultNodeDirectories(*args):
    return _RobotRaconteurPython.NodeDirectoriesUtil_GetDefaultNodeDirectories(*args)

def NodeDirectoriesUtil_GetLogonUserName():
    return _RobotRaconteurPython.NodeDirectoriesUtil_GetLogonUserName()

def NodeDirectoriesUtil_IsLogonUserRoot():
    return _RobotRaconteurPython.NodeDirectoriesUtil_IsLogonUserRoot()

def NodeDirectoriesUtil_ReadInfoFile(fname, data):
    return _RobotRaconteurPython.NodeDirectoriesUtil_ReadInfoFile(fname, data)

def NodeDirectoriesUtil_CreatePidFile(path):
    return _RobotRaconteurPython.NodeDirectoriesUtil_CreatePidFile(path)

def NodeDirectoriesUtil_CreateInfoFile(path, info):
    return _RobotRaconteurPython.NodeDirectoriesUtil_CreateInfoFile(path, info)

def NodeDirectoriesUtil_RefreshInfoFile(h_info, updated_info):
    return _RobotRaconteurPython.NodeDirectoriesUtil_RefreshInfoFile(h_info, updated_info)

class GetUuidForNameAndLockResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uuid = property(_RobotRaconteurPython.GetUuidForNameAndLockResult_uuid_get, _RobotRaconteurPython.GetUuidForNameAndLockResult_uuid_set)
    name = property(_RobotRaconteurPython.GetUuidForNameAndLockResult_name_get, _RobotRaconteurPython.GetUuidForNameAndLockResult_name_set)
    scope = property(_RobotRaconteurPython.GetUuidForNameAndLockResult_scope_get, _RobotRaconteurPython.GetUuidForNameAndLockResult_scope_set)
    fd = property(_RobotRaconteurPython.GetUuidForNameAndLockResult_fd_get, _RobotRaconteurPython.GetUuidForNameAndLockResult_fd_set)

    def __init__(self):
        _RobotRaconteurPython.GetUuidForNameAndLockResult_swiginit(self, _RobotRaconteurPython.new_GetUuidForNameAndLockResult())
    __swig_destroy__ = _RobotRaconteurPython.delete_GetUuidForNameAndLockResult

# Register GetUuidForNameAndLockResult in _RobotRaconteurPython:
_RobotRaconteurPython.GetUuidForNameAndLockResult_swigregister(GetUuidForNameAndLockResult)


def GetUuidForNameAndLock(node_dirs, name, scope):
    return _RobotRaconteurPython.GetUuidForNameAndLock(node_dirs, name, scope)
class NodeDirectoriesResourceAlreadyInUse(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _RobotRaconteurPython.NodeDirectoriesResourceAlreadyInUse_swiginit(self, _RobotRaconteurPython.new_NodeDirectoriesResourceAlreadyInUse())
    __swig_destroy__ = _RobotRaconteurPython.delete_NodeDirectoriesResourceAlreadyInUse

# Register NodeDirectoriesResourceAlreadyInUse in _RobotRaconteurPython:
_RobotRaconteurPython.NodeDirectoriesResourceAlreadyInUse_swigregister(NodeDirectoriesResourceAlreadyInUse)

class ClientServiceListenerDirector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    objectheapid = property(_RobotRaconteurPython.ClientServiceListenerDirector_objectheapid_get, _RobotRaconteurPython.ClientServiceListenerDirector_objectheapid_set)

    def __init__(self):
        if self.__class__ == ClientServiceListenerDirector:
            _self = None
        else:
            _self = self
        _RobotRaconteurPython.ClientServiceListenerDirector_swiginit(self, _RobotRaconteurPython.new_ClientServiceListenerDirector(_self, ))

    def Callback(self, code):
        return _RobotRaconteurPython.ClientServiceListenerDirector_Callback(self, code)

    def Callback2(self, code, p):
        return _RobotRaconteurPython.ClientServiceListenerDirector_Callback2(self, code, p)
    __swig_destroy__ = _RobotRaconteurPython.delete_ClientServiceListenerDirector
    def __disown__(self):
        self.this.disown()
        _RobotRaconteurPython.disown_ClientServiceListenerDirector(self)
        return weakref.proxy(self)

# Register ClientServiceListenerDirector in _RobotRaconteurPython:
_RobotRaconteurPython.ClientServiceListenerDirector_swigregister(ClientServiceListenerDirector)

RobotRaconteurObjectLockFlags_USER_LOCK = _RobotRaconteurPython.RobotRaconteurObjectLockFlags_USER_LOCK
RobotRaconteurObjectLockFlags_CLIENT_LOCK = _RobotRaconteurPython.RobotRaconteurObjectLockFlags_CLIENT_LOCK
@_swig_add_metaclass(_SwigNonDynamicMeta)
class RobotRaconteurNode(object):
    r"""

    The central node implementation

    RobotRaconteurNode implements the current Robot Raconteur instance
    and acts as the central switchpoint for the instance. The user 
    registers types, connects clients, registers services, and 
    registers transports through this class.

    If the current program only needs one instance of RobotRaconteurNode,
    the singleton can be used. The singleton is accessed using:

    RobotRaconteurNode.s

    The singleton node is typically aliased to ``RRN`` for shorthand.

    If

    .. code-block:: python

       from RobotRaconteur.Client import *

    is used, then ``RRN`` is automatically imported. If not used, the following
    is typically used:

    .. code-block:: python

       import RobotRaconteur as RR
       RRN = RobotRaconteur.s


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def RegisterTransport(self, transport):
        r"""


        Register a transport for use by the node

        :param transport: The transport to register
        :type transport: RobotRaconteur.Transport
        :return: The transport internal id
        :rtype: int


        """
        return _RobotRaconteurPython.RobotRaconteurNode_RegisterTransport(self, transport)

    def _GetRequestTimeout(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetRequestTimeout(self)

    def _SetRequestTimeout(self, timeout):
        return _RobotRaconteurPython.RobotRaconteurNode__SetRequestTimeout(self, timeout)

    def _GetTransportInactivityTimeout(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetTransportInactivityTimeout(self)

    def _SetTransportInactivityTimeout(self, timeout):
        return _RobotRaconteurPython.RobotRaconteurNode__SetTransportInactivityTimeout(self, timeout)

    def _GetEndpointInactivityTimeout(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetEndpointInactivityTimeout(self)

    def _SetEndpointInactivityTimeout(self, timeout):
        return _RobotRaconteurPython.RobotRaconteurNode__SetEndpointInactivityTimeout(self, timeout)

    def _GetMemoryMaxTransferSize(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetMemoryMaxTransferSize(self)

    def _SetMemoryMaxTransferSize(self, size):
        return _RobotRaconteurPython.RobotRaconteurNode__SetMemoryMaxTransferSize(self, size)

    def _GetNodeDiscoveryMaxCacheCount(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetNodeDiscoveryMaxCacheCount(self)

    def _SetNodeDiscoveryMaxCacheCount(self, count):
        return _RobotRaconteurPython.RobotRaconteurNode__SetNodeDiscoveryMaxCacheCount(self, count)

    def UnregisterServiceType(self, type):
        r"""


        Unregister a previously registered service type

        This function is not recommended as the results can be unpredictable

        :param type: The service type to unregister
        :type type: str

        """
        return _RobotRaconteurPython.RobotRaconteurNode_UnregisterServiceType(self, type)

    def _ConnectService(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__ConnectService(self, *args)

    def _AsyncConnectService(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__AsyncConnectService(self, *args)

    def _DisconnectService(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__DisconnectService(self, obj)

    def _AsyncDisconnectService(self, obj, handler, id):
        return _RobotRaconteurPython.RobotRaconteurNode__AsyncDisconnectService(self, obj, handler, id)

    @staticmethod
    def SelectRemoteNodeURL(urls):
        r"""


        Select the "best" URL from a std::vector of candidates

        Service discovery will often return a list of candidate URLs to 
        use to connect to a node. This function uses hueristics to select
        the "best" URL to use. The selection criteria ranks URLs in roughly
        the following order, lower number being better:

        1. "rr+intra" for IntraTransport
        2. "rr+local" for LocalTransport
        3. "rr+pci" or "rr+usb" for HardwareTransport
        4. "rrs+tcp://127.0.0.1" for secure TcpTransport loopback
        5. "rrs+tcp://[::1]" for secure TcpTransport IPv6 loopback
        6. "rrs+tcp://localhost" for secure TcpTransport loopback
        7. "rrs+tcp://[fe80" for secure TcpTransport link-local IPv6
        8. "rrs+tcp://" for any secure TcpTransport
        9. "rr+tcp://127.0.0.1" for TcpTransport loopback
        10. "rr+tcp://[::1]" for TcpTransport IPv6 loopback
        11. "rr+tcp://localhost" for TcpTransport loopback
        12. "rr+tcp://[fe80" for TcpTransport link-local IPv6
        13. "rr+tcp://" for any TcpTransport

        :param urls: The candidate URLs
        :type urls: List[str]
        :return: The "best" URL out of the candidates
        :rtype: str

        """
        return _RobotRaconteurPython.RobotRaconteurNode_SelectRemoteNodeURL(urls)

    def _RegisterServiceType(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__RegisterServiceType(self, *args)

    def _RegisterServiceTypes(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__RegisterServiceTypes(self, *args)

    def _GetServiceType(self, servicename):
        return _RobotRaconteurPython.RobotRaconteurNode__GetServiceType(self, servicename)

    def _GetPulledServiceType(self, obj, servicename):
        return _RobotRaconteurPython.RobotRaconteurNode__GetPulledServiceType(self, obj, servicename)

    def IsServiceTypeRegistered(self, servicename):
        r"""


        Test if a service type has been registered

        :param type: The name of the service type to check
        :type type: str
        :rtype: bool

        """
        return _RobotRaconteurPython.RobotRaconteurNode_IsServiceTypeRegistered(self, servicename)

    def _GetRegisteredServiceTypes(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetRegisteredServiceTypes(self)

    def _GetPulledServiceTypes(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetPulledServiceTypes(self, obj)

    @staticmethod
    def _get_s():
        return _RobotRaconteurPython.RobotRaconteurNode__get_s()

    def _Shutdown(self):
        return _RobotRaconteurPython.RobotRaconteurNode__Shutdown(self)

    def _RequestObjectLock(self, obj, flags):
        return _RobotRaconteurPython.RobotRaconteurNode__RequestObjectLock(self, obj, flags)

    def _ReleaseObjectLock(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__ReleaseObjectLock(self, obj)

    def _MonitorEnter(self, obj, timeout=-1):
        return _RobotRaconteurPython.RobotRaconteurNode__MonitorEnter(self, obj, timeout)

    def _MonitorExit(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__MonitorExit(self, obj)

    def _NowUTC(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NowUTC(self)

    def _NowTimeSpec(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NowTimeSpec(self)

    def _NowNodeTime(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NowNodeTime(self)

    def _NodeSyncTimeUTC(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NodeSyncTimeUTC(self)

    def _NodeSyncTimeSpec(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NodeSyncTimeSpec(self)

    def _AsyncRequestObjectLock(self, obj, flags, timeout, handler, id):
        return _RobotRaconteurPython.RobotRaconteurNode__AsyncRequestObjectLock(self, obj, flags, timeout, handler, id)

    def _AsyncReleaseObjectLock(self, obj, timeout, handler, id):
        return _RobotRaconteurPython.RobotRaconteurNode__AsyncReleaseObjectLock(self, obj, timeout, handler, id)

    def _GetServiceAttributes(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetServiceAttributes(self, obj)

    def _GetServiceNodeID(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetServiceNodeID(self, obj)

    def _GetServiceNodeName(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetServiceNodeName(self, obj)

    def _GetServiceName(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetServiceName(self, obj)

    def _GetObjectServicePath(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetObjectServicePath(self, obj)

    def _GetObjectType(self, obj):
        return _RobotRaconteurPython.RobotRaconteurNode__GetObjectType(self, obj)

    def _RegisterService(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__RegisterService(self, *args)

    def CloseService(self, sname):
        r"""


        Closes a previously registered service

        Services are automatically closed by Shutdown, so this function
        is rarely used.

        :param sname: The name of the service to close
        :type sname: str

        """
        return _RobotRaconteurPython.RobotRaconteurNode_CloseService(self, sname)

    def _NodeID(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NodeID(self)

    def _SetNodeID(self, id):
        return _RobotRaconteurPython.RobotRaconteurNode__SetNodeID(self, id)

    def _NodeName(self):
        return _RobotRaconteurPython.RobotRaconteurNode__NodeName(self)

    def _SetNodeName(self, name):
        return _RobotRaconteurPython.RobotRaconteurNode__SetNodeName(self, name)

    def _GetThreadPoolCount(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetThreadPoolCount(self)

    def _SetThreadPoolCount(self, count):
        return _RobotRaconteurPython.RobotRaconteurNode__SetThreadPoolCount(self, count)

    def _FindObjectType(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__FindObjectType(self, *args)

    def _AsyncFindObjectType(self, *args):
        return _RobotRaconteurPython.RobotRaconteurNode__AsyncFindObjectType(self, *args)

    def _SetExceptionHandler(self, handler, id):
        return _RobotRaconteurPython.RobotRaconteurNode__SetExceptionHandler(self, handler, id)

    def _ClearExceptionHandler(self):
        return _RobotRaconteurPython.RobotRaconteurNode__ClearExceptionHandler(self)

    def Sleep(self, duration):
        r"""


        Sleeps for a specified duration

        Normally will sleep based on the system clock, but in certain
        circumstances will use simulation time

        :param duration: Duration to sleep in seconds
        :type duration: float

        """
        return _RobotRaconteurPython.RobotRaconteurNode_Sleep(self, duration)

    def _CreateTimer(self, period, oneshot, handler, id):
        return _RobotRaconteurPython.RobotRaconteurNode__CreateTimer(self, period, oneshot, handler, id)

    def CreateRate(self, frequency):
        r"""


        Create a Rate object

        Rate is used to stabilize periodic loops to a specified frequency

        This function will normally return a WallRate instance

        :param frequency: Frequency of loop in Hz
        :type frequency: float
        :return: The new Rate object
        :rtype: RobotRaconteur.Rate

        """
        return _RobotRaconteurPython.RobotRaconteurNode_CreateRate(self, frequency)

    def CreateAutoResetEvent(self):
        r"""

        Create an AutoResetEvent object

        Normally the AutoResetEvent will use the system clock for timeouts,
        but in certain circumstances will use simulation time

        :return: The new AutoResetEvent object
        :rtype: RobotRaconteur.AutoResetEvent

        """
        return _RobotRaconteurPython.RobotRaconteurNode_CreateAutoResetEvent(self)

    def _PostToThreadPool(self, handler, id):
        return _RobotRaconteurPython.RobotRaconteurNode__PostToThreadPool(self, handler, id)

    def _GetRobotRaconteurVersion(self):
        return _RobotRaconteurPython.RobotRaconteurNode__GetRobotRaconteurVersion(self)

    def CompareLogLevel(self, log_level):
        r"""


        Test if the specified log level would be accepted

        :param log_level: Log level to test
        :type log_level: int
        :return: True if the log would be accepted, False if it would be ignored
        :rtype: bool

        """
        return _RobotRaconteurPython.RobotRaconteurNode_CompareLogLevel(self, log_level)

    def LogMessage(self, level, message):
        r"""


        Log a simple message using the current node

        The record will be sent to the configured log handler,
        or sent to std::cerr if none is configured

        If the level of the message is below the current log level
        for the node, the record will be ignored


        """
        return _RobotRaconteurPython.RobotRaconteurNode_LogMessage(self, level, message)

    def LogRecord(self, record):
        r"""


        Log a record to the node.

        The record will be sent to the configured log handler,
        or sent to std::cerr if none is configured

        If the level of the message is below the current log level
        for the node, it will be ignored

        :param record: The record to log
        :type record: RRLogRecord

        """
        return _RobotRaconteurPython.RobotRaconteurNode_LogRecord(self, record)

    def GetLogLevel(self):
        r"""


        Get the current log level for the node

        Default level is "info"

        :return: The current log level
        :rtype: int

        """
        return _RobotRaconteurPython.RobotRaconteurNode_GetLogLevel(self)

    def SetLogLevel(self, level):
        r"""


        Set the log level for the node

        Set RobotRaconteur.RobotRaconteur_LogLevel_Disable to disable logging

        :param level: The desired log level
        :type level: int

        """
        return _RobotRaconteurPython.RobotRaconteurNode_SetLogLevel(self, level)

    def SetLogLevelFromString(self, level):
        r"""


        Set the log level for the node from a string

        Must be one of the following values: DISABLE, FATAL, ERROR, WARNING, INFO, DEBUG, TRACE

        Defaults to WARNING

        :param level: The desired log level
        :type level: str
        :return: The log level
        :rtype: int

        """
        return _RobotRaconteurPython.RobotRaconteurNode_SetLogLevelFromString(self, level)

    def SetLogLevelFromEnvVariable(self, *args):
        r"""


        Set the log level for the node from specified environmental variable

        Retrieves the specified environmental variable and sets the log level based
        on one of the following values: DISABLE, FATAL, ERROR, WARNING, INFO, DEBUG, TRACE

        If an invalid value or the variable does not exist, the log level is left unchanged. 

        :param env_variable_name: The environmental variable to use. Defaults to 
         ``ROBOTRACONTEUR_LOG_LEVEL``
        :type env_variable_name: str
        :return: The log level
        :rtype: int

        """
        return _RobotRaconteurPython.RobotRaconteurNode_SetLogLevelFromEnvVariable(self, *args)

    def GetLogRecordHandler(self):
        r"""


        Get the currently configured log record handler

        If None, records are sent to ``stdout``

        :return: The log record handler
        :rtype: LogRecordHandler

        """
        return _RobotRaconteurPython.RobotRaconteurNode_GetLogRecordHandler(self)

    def SetLogRecordHandler(self, handler):
        r"""


        Set the handler for log records

        If handler is NULL, records are sent to std::cerr

        :param handler: The log record handler function
        :type handler: RobotRaconteur.LogRecordHandler

        """
        return _RobotRaconteurPython.RobotRaconteurNode_SetLogRecordHandler(self, handler)

    def CheckConnection(self, client):
        r"""


        Check that the TransportConnection associated with an endpoint
        is connected

        Raises `RobotRaconteur.ConnectionException` or other exception if connection is invalid.

        :param endpoint: The LocalEndpoint identifier to check
        :type endpoint: int

        """
        return _RobotRaconteurPython.RobotRaconteurNode_CheckConnection(self, client)

    def GetNodeDirectories(self):
        return _RobotRaconteurPython.RobotRaconteurNode_GetNodeDirectories(self)

    def SetNodeDirectories(self, dir):
        return _RobotRaconteurPython.RobotRaconteurNode_SetNodeDirectories(self, dir)

    def FindServiceByType(self,servicetype,transportschemes):
    	"""
    	Use discovery to find available services by service type

    	Uses discovery to find available services based on a service type. This
    	service type is the type of the root object, ie 
    	\"com.robotraconteur.robotics.robot.Robot\". This process will update the detected 
    	node cache.

    	:param servicetype: The service type to find, ie \"com.robotraconteur.robotics.robot.Robot\"
    	:type servicetype: str
    	:param transportschemes: A list of transport types to search, ie \"rr+tcp\", \"rr+local\", \"rrs+tcp\", etc
    	:type transportschemes: List[str]
    	:return: The discovered services
    	:rtype: List[RobotRaconteur.ServiceInfo2]
    	"""
    	from .RobotRaconteurPythonUtil import ServiceInfo2
    	ts2=vectorstring()
    	for t in transportschemes:
    		ts2.push_back(t)
    	info1=WrappedFindServiceByType(self, servicetype,ts2)
    	ret=[]
    	for e in info1:
    		ret.append(ServiceInfo2(e))
    	return ret

    def AsyncFindServiceByType(self,servicetype,transportschemes,handler,timeout=5):
    	"""
    	Asynchronously use discovery to find availabe services by service type

    	Same as FindServiceByType() but returns asynchronously

    	If ``handler`` is None, returns an awaitable future.

    	:param servicetype: The service type to find, ie \"com.robotraconteur.robotics.robot.Robot\"
    	:type servicetype: str
    	:param transportschemes: A list of transport types to search, ie \"rr+tcp\", \"rr+local\", \"rrs+tcp\", etc
    	:type transportschemes: List[str]
    	:param handler: Handler to call on completion
    	:type handler: Callable[[List[ServiceInfo2]],None]
    	:param timeout: Timeout in seconds. Using a timeout greater than 5 seconds is not recommended.
    	:type timeout: float
    	"""
    	class ServiceInfo2Director(AsyncServiceInfo2VectorReturnDirector):
    		def __init__(self,handler):			
    			super(ServiceInfo2Director,self).__init__()
    			self._handler=handler

    		def handler(self,info1):
    			from .RobotRaconteurPythonUtil import ServiceInfo2
    			ret=[]			
    			for e in info1:
    				ret.append(ServiceInfo2(e))
    			self._handler(ret)

    	ts2=vectorstring()
    	for t in transportschemes:
    		ts2.push_back(t)

    	from .RobotRaconteurPythonUtil import async_call, adjust_timeout
    	return async_call(AsyncWrappedFindServiceByType,(self,servicetype,ts2,adjust_timeout(timeout)),ServiceInfo2Director,handler,False)



    def FindNodeByID(self,id,transportschemes):
    	"""
    	Finds nodes on the network with a specified NodeID

    	Updates the discovery cache and find nodes with the specified NodeID.
    	This function returns unverified cache information.

    	:param id: The NodeID to find
    	:type id: RobotRaconteur.NodeID
    	:param transportschemes: A list of transport types to search, ie \"rr+tcp\", \"rr+local\", \"rrs+tcp\", etc
    	:type transportschemel: str
    	:return: The discovered nodes
    	:rtype: List[NodeInfo2]
    	"""
    	from .RobotRaconteurPythonUtil import NodeInfo2
    	ts2=vectorstring()
    	for t in transportschemes:
    		ts2.push_back(t)
    	info1=WrappedFindNodeByID(self,id,ts2)
    	ret=[]
    	for e in info1:
    		ret.append(NodeInfo2(e))
    	return ret

    def FindNodeByName(self,name,transportschemes):
    	"""
    	Finds nodes on the network with a specified NodeName

    	Updates the discovery cache and find nodes with the specified NodeName.
    	This function returns unverified cache information.

    	:param name: The NodeName to find
    	:type name: str
    	:param transportschemes: A list of transport types to search, ie \"rr+tcp\", \"rr+local\", \"rrs+tcp\", etc
    	:return: The discovered nodes
    	:rtype: List[NodeInfo2]
    	"""
    	from .RobotRaconteurPythonUtil import NodeInfo2
    	ts2=vectorstring()
    	for t in transportschemes:
    		ts2.push_back(t)
    	info1=WrappedFindNodeByName(self,name,ts2)
    	ret=[]
    	for e in info1:
    		ret.append(NodeInfo2(e))
    	return ret

    def AsyncFindNodeByID(self,id,transportschemes,handler,timeout=5):
    	"""
    	Asynchronously finds nodes on the network with the specified NodeID

    	Same as FindNodeByID() but returns asynchronously

    	If ``handler`` is None, returns an awaitable future.

    	:param id: The NodeID to find
    	:type id: RobotRaconteur.NodeID
    	:param transportschemes: A list of transport types to search, ie \"rr+tcp\", \"rr+local\", \"rrs+tcp\", etc
    	:type transportschemes: List[str]
    	:param handler: Handler to call on completion
    	:type handler: Callable[List[NodeInfo2],None]
    	:param timeout: Timeout in seconds. Using a timeout greater than 5 seconds is not recommended.
    	:type timeout: float
    	"""
    	class NodeInfo2Director(AsyncNodeInfo2VectorReturnDirector):
    		def __init__(self,handler):
    			super(NodeInfo2Director,self).__init__()
    			self._handler=handler

    		def handler(self,info1):
    			from .RobotRaconteurPythonUtil import NodeInfo2
    			ret=[]			
    			for e in info1:
    				ret.append(NodeInfo2(e))
    			self._handler(ret)
    	ts2=vectorstring()
    	for t in transportschemes:
    		ts2.push_back(t)

    	from .RobotRaconteurPythonUtil import async_call, adjust_timeout
    	return async_call(AsyncWrappedFindNodeByID,(self,id,ts2,adjust_timeout(timeout)),NodeInfo2Director,handler,False)

    def AsyncFindNodeByName(self,name,transportschemes,handler,timeout=5):
    	"""
    	Asynchronously finds nodes on the network with the specified NodeName

    	Same as FindNodeByName() but returns asynchronously

    	If ``handler`` is None, returns an awaitable future.

    	:param name: The NodeName to find
    	:type name: str
    	:param transportschemes: A list of transport types to search, ie \"rr+tcp\", \"rr+local\", \"rrs+tcp\", etc
    	:type transportschemes: List[str]
    	:param handler: Handler to call on completion
    	:type handler: Callable[List[NodeInfo2],None]
    	:param timeout: Timeout in seconds. Using a timeout greater than 5 seconds is not recommended.
    	:type timeout: float
    	"""
    	class NodeInfo2Director(AsyncNodeInfo2VectorReturnDirector):
    		def __init__(self,handler):
    			super(NodeInfo2Director,self).__init__()
    			self._handler=handler

    		def handler(self,info1):
    			from .RobotRaconteurPythonUtil import NodeInfo2
    			ret=[]			
    			for e in info1:
    				ret.append(NodeInfo2(e))
    			self._handler(ret)
    	ts2=vectorstring()
    	for t in transportschemes:
    		ts2.push_back(t)

    	from .RobotRaconteurPythonUtil import async_call, adjust_timeout
    	return async_call(AsyncWrappedFindNodeByName,(self,name,ts2,adjust_timeout(timeout)),NodeInfo2Director,handler,False)	

    def UpdateDetectedNodes(self, schemes):
    	"""
    	Update the detected nodes cache

    	The node keeps a cache of detected nodes, but this may become stale
    	if nodes are rapidly added and removed from the network. Call this
    	function to update the detected nodes.

    	:param schemes: A list of transport schemes, ie \"rr+tcp\", \"rr+local\", etc. to update.
    	:type schemes: List[str]
    	"""
    	ts2=vectorstring()
    	for t in schemes:
    		ts2.push_back(t)
    	WrappedUpdateDetectedNodes(self,ts2)

    def AsyncUpdateDetectedNodes(self,schemes,handler,timeout=5):
    	"""
    	Asynchronously update the detected nodes cache

    	Same as UpdateDetectedNodes() but returns asynchronously

    	If ``handler`` is None, returns an awaitable future.

    	:param schemes: A list of transport schemes, ie \"rr+tcp\", \"rr+local\", etc. to update.
    	:type schemes: List[str]
    	:param handler: The handler to call on completion
    	:type handler: Callable[[],None]
    	:param timeout: The timeout for the operation in seconds. This function will often run
    	 for the full timeout, so values less than 5 seconds are recommended.
    	:type timeout: float
    	"""
    	ts2=vectorstring()
    	for t in schemes:
    		ts2.push_back(t)

    	from .RobotRaconteurPythonUtil import async_call, adjust_timeout, AsyncVoidNoErrReturnDirectorImpl
    	return async_call(AsyncWrappedUpdateDetectedNodes,(self,ts2, adjust_timeout(timeout),), AsyncVoidNoErrReturnDirectorImpl,handler,noerror=True)

    def GetDetectedNodes(self):
    	"""
    	Get the nodes currently detected by Transports

    	Transports configured to listen for node discovery send detected node
    	information to the parent node, where it is stored. Normally this information
    	will expire after one minute, and needs to be constantly refreshed.

    	This node information is not verified. It is the raw discovery 
    	information received by the transports. Verification is done
    	when the node is interrogated for service information.

    	:return: List of detected NodeID
    	:rtype: List[RobotRaconteur.NodeID]
    	"""
    	o1=WrappedGetDetectedNodes(self)
    	return [NodeID(x) for x in o1]

    def GetDetectedNodeCacheInfo(self, nodeid):
    	"""
    	Get cached node discovery information

    	Return current node information from the discovery cache. This
    	information is unverified and is used for the first step in the
    	discovery process.

    	:param nodeid: The NodeID of the requested node
    	:type nodeid: RobotRaconteur.NodeID
    	:return: The node info
    	:rtype: RobotRaconteur.NodeInfo2
    	"""
    	from .RobotRaconteurPythonUtil import NodeInfo2
    	return NodeInfo2(WrappedGetDetectedNodeCacheInfo(self, nodeid))

    def TryGetDetectedNodeCacheInfo(self, nodeid):
    	"""
    	Try get cached node discovery information

    	Same as GetDetectedNodeCacheInfo, but returns bool
    	for success or failure instead of throwing an exception
    	"""
    	from .RobotRaconteurPythonUtil import NodeInfo2 as NodeInfo2py
    	ret = NodeInfo2()
    	res = WrappedTryGetDetectedNodeCacheInfo(self,nodeid,ret)
    	if not res:
    		return False, None
    	else:
    		return True, NodeInfo2py(ret)


    def Init(self, thread_count=20):
        r"""
        Initialize the node. Called automatically for ``RRN``

        This function must be called to initialize background tasks before
        using the node. It is called automatically by the
        singleton accesors, so the user only needs to call this function
        when not using the singleton. If a custom thread pool is being
        used, the thread pool factory must be specified before 
        calling init.

        :param thread_count: The initial number of threads in the thread pool (default 20)
        :type thread_count: int

        """
        return _RobotRaconteurPython.RobotRaconteurNode_Init(self, thread_count)

    def ConnectService(self,*args):
        """
        ConnectService(url,username=None,credentials=None,listener=None)
        Create a client connection to a remote service using a URL

        Synchronously creates a connection to a remote service using a URL. URLs are either provided by
        the service, or are determined using discovery functions such as FindServiceByType().
        This function is the primary way to create client connections.

        username and credentials can be used to specify authentication information. Credentials will
        often contain a \"password\" or token entry.

        The listener is a function that is called during various events. See ClientServiceListenerEventType
        constants for a description of the possible events.

        ConnectService will attempt to instantiate a client object reference (proxy) based on the type
        information provided by the service. The type information will contain the type of the object,
        and all the implemented types.

        :param url: The URL of the service to connect
        :type url: Union[str,List[str]]
        :param username: An optional username for authentication, None for no authentication
        :type username: str
        :param credentials: Optional credentials for authentication, None for no authentication
        :type credentials: Dict[str,Any]
        :param listener: Optional listener callback function
        :type listener: Callable[[object,int,Any],None]
        :return: The client object reference (proxy).
        """
        from .RobotRaconteurPythonUtil import PackMessageElement, WrappedClientServiceListenerDirector, InitStub
        args2=list(args)
        if (len(args) >= 3):
            if (args[1]==None): args2[1]=""
            args2[2]=PackMessageElement(args[2],"varvalue{string}",None,self).GetData()
        if (len(args)>=4):
            args2[3]=WrappedClientServiceListenerDirector(args[3])
            args2[3].__disown__()
        if (len(args2) > 4):
            args2=args2[0:4]
        res=self._ConnectService(*args2)
        stub=InitStub(res)
        if (len(args2)>=4):
            args2[3].stub=stub
        return stub

    def AsyncConnectService(self, url, username, credentials, listener, handler, timeout=RR_TIMEOUT_INFINITE):
        """
        Asynchronously create a client connection to a remote service using a URL

        Same as ConnectService but returns asynchronously. See ConnectService() for more details
        on client connections.

        handler is called after the client connection succeeds are fails. On success, the object reference
        is returned and the exception is None. On failure, the returned object is None and the exception
        contains a subclass of Exception.

        If ``handler`` is None, returns an awaitable future.

        :param url: The URL of the service to connect
        :type url: Union[str,List[str]]
        :param username: A username for authentication, None for no authentication
        :type username: str
        :param credentials: credentials for authentication, None for no authentication
        :type credentials: Dict[str,Any]
        :param listener: A listener callback function, None for no listener
        :type listener: Callable[[object,int,Any],None]
        :param handler: A handler function to receive the object reference or an exception
        :type handler: Callable[[object,Exception],None]
        :param timeout: Timeout in seconds, or -1 for no timeout
        :type timeout: float
        """
        from .RobotRaconteurPythonUtil import PackMessageElement, WrappedClientServiceListenerDirector, AsyncStubReturnDirectorImpl, async_call, adjust_timeout

        if (username is None ): username=""
        if (credentials is not None): credentials=PackMessageElement(credentials,"varvalue{string}",None,self).GetData()
        listener2=None
        if (listener is not None):
            listener2=WrappedClientServiceListenerDirector(listener)
            listener2.__disown__()

        return async_call(self._AsyncConnectService,(url, username, credentials, listener2, "", adjust_timeout(timeout)), AsyncStubReturnDirectorImpl, handler)

    def DisconnectService(self, stub):
        """
        Disconnects a client connection to a service

        Synchronously disconnects a client connection. Client connections
        are automatically closed by Shutdown(), so this function
        is optional. 

        :param obj: The root object of the service to disconnect
        """
        self._DisconnectService(stub.rrinnerstub)

    def AsyncDisconnectService(self, stub, handler):
        """
        Asynchronously disconnects a client connection to a service

        Same as DisconnectService() but returns asynchronously.

        If ``handler`` is None, returns an awaitable future.

        :param obj: The root object of the client to disconnect
        :param handler: The handler to call when complete
        :type handler: Callable[[],None]
        """
        from .RobotRaconteurPythonUtil import async_call, AsyncVoidNoErrReturnDirectorImpl
        return async_call(self._AsyncDisconnectService,(stub.rrinnerstub,), AsyncVoidNoErrReturnDirectorImpl,handler,noerror=True)

    @classproperty.classpropertyreadonly
    def s(self):
        return RobotRaconteurNode._get_s()

    def RegisterServiceType(self, d):
        """
        Register a service type

        If passed a string, the string will be parsed as a service definition file

        The service type will be verified. All imported types must already have
        been registered for verification to succeed. It is recommended that
        RegisterServiceTypes() be used for lists of service types.

        :param d: The service definition implementing the type to register
        :type d: Union[RobotRaconteur.ServiceDefinition,str]
        """
        self._RegisterServiceType(d)

    def RegisterServiceTypes(self, d):
        """
        Register a list of service types

        If passed a string, the string will be parsed as a service definition file

        The service types will be verified. All imported types must be included in the list
        or already have	been registered for verification to succeed. 

        :param d: The service types implementing the types to register
        :type d: Union[List[RobotRaconteur.ServiceDefinition],List[str]]
        """
        self._RegisterServiceTypes(d)

    def RegisterServiceTypeFromFile(self, file_name):
        """
        Register a service type from a file

        The file_name must point to a plain text \"robdef\" file. The file_name
        may leave off the \".robdef\" extension.

        The path in the environmental variable ``ROBOTRACONTEUR_ROBDEF_PATH`` will
        be searched if the file is not found in the working directory.

        The service type will be verified. All imported types must already have
        been registered for verification to succeed. It is recommended that
        RegisterServiceTypesFromFiles() be used for lists of service types.

        :param d: The filename of the service type to load
        :type d: str
        """
        from .RobotRaconteurPythonUtil import ReadServiceDefinitionFile
        d = ReadServiceDefinitionFile(file_name)
        self._RegisterServiceType(str(d))

    def RegisterServiceTypesFromFiles(self, file_names, auto_import = False):
        """
        Register a list of service type from files

        The file names in file_names must point to plain text \"robdef\" files. The 
        file names may leave off the \".robdef\" extension.

        The path in the environmental variable ``ROBOTRACONTEUR_ROBDEF_PATH`` will
        be searched if a file is not found in the working directory.

        The service types will be verified. All imported types must already have
        been registered or included in the file_names list for verification to 
        succeed.

        If auto_import is True, missing service type files will be loaded automatically from
        the filesystem.

        :param file_names: The filenames of the service types to load
        :type file_names: List[str]
        :param auto_import: If True, attempt to import missing service types
        :type auto_import: bool
        """
        from .RobotRaconteurPythonUtil import ReadServiceDefinitionFiles
        d = ReadServiceDefinitionFiles(file_names, auto_import)
        self._RegisterServiceTypes(d)

    def GetServiceType(self, name):
        """
        Returns a previously registered service type

        :param name: The name of the service type to retrieve
        :type name: str
        :rtype: ServiceDefinition
        """
        return self._GetServiceType(name)

    def GetRegisteredServiceTypes(self):
        """
        Return names of registered service types

        :rtype: List[str] 
        """
        return self._GetRegisteredServiceTypes()

    def GetPulledServiceTypes(self,obj):
        """
        Get the names of service types pulled by a client

        Clients pull service definitions from services and create
        instances of ServiceFactory if a DynamicServiceFactory has 
        been configured. GetPulledServiceTypes returns a list of  the
        names of these pulled service types. Use GetPulledServiceType()
        to retrieve the ServiceFactory for a specific type.

        :param obj: Client object referenece returned by ConnectService() or AsyncConnectService()
        :return: The names of the pulled service types
        :rtype: List[str]
        """
        if (hasattr(obj,'rrinnerstub')):
            obj=obj.rrinnerstub
        return self._GetPulledServiceTypes(obj)

    def GetPulledServiceType(self,obj,servicetype):
        """
        Get a ServiceFactory created from a service type pulled by a client

        Clients pull service definitions from services and create
        instances of ServiceFactory if a DynamicServiceFactory has 
        been configured. GetPulledServiceType() returns a
        generated ServiceFactory. Use GetPulledServiceTypes() to 
        return a list of available service types.

        :param obj: Client object referenece returned by ConnectService() or AsyncConnectService()
        :param servicetype: The name of the service type
        :type servicetype: str
        :return: The pulled service factory
        :rtype: RobotRaconteur.ServiceDefinition
        """
        if (hasattr(obj,'rrinnerstub')):
            obj=obj.rrinnerstub
        return self._GetPulledServiceType(obj,servicetype)

    def NewStructure(self,structtype,obj=None):
        """
        Returns a new Robot Raconteur structure with type ``structtype``

        :param structtype: The fully qualified type of the structure
        :type structtype: str
        :param obj: The client connection object reference to be used with this structure.  
          This is necessary because each client maintains type information.  A client must be provided from 
          which type information can be queried. For services this parameter is unnecessary.
        :return: The new structure instance
        """
        from .RobotRaconteurPythonUtil import NewStructure
        return NewStructure(structtype,obj,self)

    def GetStructureType(self,structtype,obj=None):
        """
        Returns a constructor for Robot Raconteur structure with type ``structtype``

        :param structtype: The fully qualified type of the structure
        :type structtype: str
        :param obj: The client connection object reference to be used with this structure.  
          This is necessary because each client maintains type information.  A client must be provided from 
          which type information can be queried. For services this parameter is unnecessary.
        :return: The constructer for the structure type
        :rtype: Callable[[],<structtype>]
        """
        from .RobotRaconteurPythonUtil import GetStructureType
        return GetStructureType(structtype,obj,self)

    def GetPodDType(self,podtype,obj=None):
        """
        Returns the numpy dtype for ``podtype``

        Use with numpy.array() or numpy.zeros() to create new pod arrays.

        :param type: The fully qualified type of the pod
        :type type: str
        :param obj: The client connection object reference to be used with this pod type.  
          This is necessary because each client maintains type information.  A client must be provided from 
          which type information can be queried. For services this parameter is unnecessary.
        :return: The dtype for the specified podtype
        :rtype: numpy.dtype
        """
        from .RobotRaconteurPythonUtil import GetPodDType
        return GetPodDType(podtype,obj,self)

    def GetNamedArrayDType(self,namedarraytype,obj=None):
        """
        Returns the numpy dtype for ``namedarraytype``

        Use with numpy.array() or numpy.zeros() to create new namedarray arrays.

        :param type: The fully qualified type of the namedarray
        :type type: str
        :param obj: The client connection object reference to be used with this namedarray type.  
            This is necessary because each client maintains type information.  A client must be provided from 
            which type information can be queried. For services this parameter is unnecessary.
        :return: The dtype for the specified namedarray
        :rtype: numpy.dtype
        """
        from .RobotRaconteurPythonUtil import GetNamedArrayDType
        return GetNamedArrayDType(namedarraytype,obj,self)

    def NamedArrayToArray(self,named_array):
        """
        Converts a namedarray type into a primitive array with the namedarray numeric type. 
        This function will return an array with one more dimension than the input array, 
        with the first dimension set to the element count of the named array.

        :param namedarray: The namedarray to convert stored in a ``numpy.ndarray``
        :type namedarray: numpy.ndarray
        :return: The converted numeric array
        :rtype: numpy.ndarray
        """
        from .RobotRaconteurPythonUtil import NamedArrayToArray
        return NamedArrayToArray(named_array)

    def ArrayToNamedArray(self,a,named_array_dt):
        """
        Converts a numeric array into a namedarray. The type of the namedarray is 
        specified using ``dt``, which is returned from GetNamedArrayDType().
        The input numeric array must have the correct numeric type, and the first dimension 
        must match the element count of the namedarray. The output array will 
        have one fewer dimensions than the input array.

        :param a: The numeric array to convert
        :type a: numpy.ndarray
        :param dt: The data type of the desired namedarray type
        :type dt: numpy.dtype
        :return: The converted namedarray
        :rtype: numpy.ndarray
        """
        from .RobotRaconteurPythonUtil import ArrayToNamedArray
        return ArrayToNamedArray(a,named_array_dt)

    class ScopedMonitorLock(object):
        """
        Wrapper for RobotRaconteurNode.MonitorEnter() and 
        RobotRaconteurNode.MonitorExit() supporting ``with``
        statement scoping
        """
        def __init__(self,obj,timeout=-1):
            """
            Create a monitor lock for the specified object

            Creates a monitor lock by calling RobotRaconteur.MonitorEnter().
            Object will be locked once the scoped lock is created.

            :param obj: The object to monitor lock
            :param timeout: The timeout in seconds to acquire the monitor lock, 
               or -1 for infinite
            :type timeout: float
            """
            self.obj=obj
            self.timeout=timeout
            self.node=obj.rrinnerstub.RRGetNode()
            self.locked=False
        def __enter__(self):
            self.node.MonitorEnter(self.obj,self.timeout)
            self.locked=True
        def __exit__(self,type, value, traceback):
            self.node.MonitorExit(self.obj)
            self.locked=False
        def lock(self,timeout):
            """
            Relock the object after calling unlock()

            :param timeou:t The timeout in seconds to acquire the monitor lock, 
             or -1 for infinite
            :type timeout: float
            """
            self.node.MonitorEnter(self.obj,timeout)
            self.locked=True
        def unlock(self):
            """
            Releases the monitor lock

            The ScopedMonitorLock destructor will release
            the lock automatically, so in most cases it is
            not necessary to call this function
            """
            self.node.MonitorExit(self.obj,)
            self.locked=False
        def release(self):
            """
            Release the monitor lock from the class

            The monitor lock is released from the ScopedMonitorLock
            instance. The monitor lock will not be released
            when the ``with`` block exits. 
            """
            self.obj=None

    def RequestObjectLock(self,obj,flags):
        """
        Request an exclusive access lock to a service object

        Called by clients to request an exclusive lock on a service object and
        all subobjects (\"objrefs\") in the service. The exclusive access lock will
        prevent other users (\"User\" lock) or client connections  (\"Session\" lock) 
        from interacting with the objects.

        :param obj: The object to lock. Must be returned by ConnectService or returned by an \"objref\"
        :param flags: Select either a \"User\" lock with RobotRaconteur.RobotRaconteurObjectLockFlags_USER_LOCK or \"Session\" 
          lock with RobotRaconteur.RobotRaconteurObjectLockFlags_CLIENT_LOCK
        :return: \"OK\" on success
        :rtype: str
        """
        return self._RequestObjectLock(obj.rrinnerstub,flags)

    def ReleaseObjectLock(self,obj):
        """
        Release an excluse access lock previously locked with RequestObjectLock()
        or AsyncRequestObjectLock()

        Object must have previously been locked using RequestObjectLock() or
        AsyncRequestObjectLock()

        :param obj: The object previously locked
        :return: \"OK\" on success
        :rtype: str
        """
        return self._ReleaseObjectLock(obj.rrinnerstub)

    def MonitorEnter(self,obj,timeout=-1):
        """
        Creates a monitor lock on a specified object

        Monitor locks are intendended for short operations that require
        guarding to prevent races, corruption, or other concurrency problems.
        Monitors emulate a single thread locking the service object.

        Use of ScopedMonitorLock instead of this function is highly recommended

        Monitor locks do not lock any sub-objects (objref)

        :param: obj The object to lock
        :param timeout: The timeout in seconds to acquire the monitor lock, 
            or -1 for infinite
        """
        from .RobotRaconteurPythonUtil import adjust_timeout	
        self._MonitorEnter(obj.rrinnerstub,adjust_timeout(timeout))

    def MonitorExit(self,obj):
        """
        Releases a monitor lock

        Use of ScopedMonitorLock instead of this function is highly recommended


        :param obj: The object previously locked by MonitorEnter()
        """
    #obj.rrlock.release()
        self._MonitorExit(obj.rrinnerstub)

    def AsyncRequestObjectLock(self,obj,flags,handler,timeout=RR_TIMEOUT_INFINITE):
        """
        Asynchronously request an exclusive access lock to a service object

        Same as RequestObjectLock() but returns asynchronously

        If ``handler`` is None, returns an awaitable future.

        :param obj: The object to lock. Must be returned by ConnectService or returned by an \"objref\"
        :param flags: Select either a \"User\" lock with RobotRaconteur.RobotRaconteurObjectLockFlags_USER_LOCK or \"Session\" 
          lock with RobotRaconteur.RobotRaconteurObjectLockFlags_CLIENT_LOCK
        :param handler: Handler to call on completion
        :type handler: Callable[[str,Exception],None]
        :param timeout: Timeout in seconds, or -1 for infinite
        :type timeout: float
        """
        from .RobotRaconteurPythonUtil import async_call, adjust_timeout, AsyncStringReturnDirectorImpl
        return async_call(self._AsyncRequestObjectLock,(obj.rrinnerstub,flags,adjust_timeout(timeout)),AsyncStringReturnDirectorImpl,handler)

    def AsyncReleaseObjectLock(self,obj,handler,timeout=RR_TIMEOUT_INFINITE): 
        """
        Asynchronously release an excluse access lock previously locked 
        with RequestObjectLock() or AsyncRequestObjectLock()

        Same as ReleaseObjectLock() but returns asynchronously

        If ``handler`` is None, returns an awaitable future.

        :param obj: The object previously locked
        :param handler: Handler to call on completion
        :type handler: Callable[[str,Exception],None]
        :param timeout: Timeout in seconds, or -1 for infinite
        :type timout: float
        """
        from .RobotRaconteurPythonUtil import async_call, adjust_timeout, AsyncStringReturnDirectorImpl
        return async_call(self._AsyncReleaseObjectLock,(obj.rrinnerstub,adjust_timeout(timeout)),AsyncStringReturnDirectorImpl,handler)

    def GetServiceAttributes(self,obj):
        """
        Get the service attributes of a client connection

        Returns the service attributes of a client connected using 
        ConnectService()

        :param obj: The root object of the client to use to retrieve service attributes
        :return: The service attributes
        :rtype: Dict[str,Any]
        """
        from .RobotRaconteurPythonUtil import UnpackMessageElement
        return UnpackMessageElement(self._GetServiceAttributes(obj.rrinnerstub),"varvalue{string} value",None,self)

    def GetServiceNodeID(self,obj):
        """
        Get the service NodeID of the remote node from a client connection

        Returns the NodeID of the remote node that a client is connected

        :param obj: The root object of the client to use to retrieve service attributes
        :return: The NodeID
        :rtype: NodeID
        """
        return self._GetServiceNodeID(obj.rrinnerstub)

    def GetServiceNodeName(self,obj):
        """
        Get the service NodeName of the remote node from a client connection

        Returns the NodeName of the remote node that a client is connected

        :param obj: The root object of the client to use to retrieve service attributes
        :return: The NodeName
        :rtype: str
        """
        return self._GetServiceNodeName(obj.rrinnerstub)

    def GetServiceName(self,obj):
        """
        Get the name of a service from a client connection

        Returns the service name of the remote service that a client is connected

        :param: obj The root object of the client to use to retrieve service attributes
        :return: The service name
        :rtype: str
        """
        return self._GetServiceName(obj.rrinnerstub)

    def GetObjectServicePath(self,obj):
        """
        Get the service path of a client object

        :param obj: The object to get the service path for
        :return: The object's service path
        :rtype: str
        """
        return self._GetObjectServicePath(obj.rrinnerstub)

    def GetObjectType(self,obj):
        """
        Get the Robot Raconteur type of a connected service object
        ``obj`` have been returned by ConnectService(), AsyncConnectService(),
        or an ``objref``

        :param obj: The object to query
        :return: The Robot Raconteur type of the object
        :rtype: str
        """
        if (hasattr(obj,'rrinnerstub')):
            obj=obj.rrinnerstub
        return self._GetObjectType(obj)

    def RegisterService(self, name, objecttype, obj, securitypolicy=None):
        """
        Registers a service for clients to connect

        The supplied object becomes the root object in the service. Other objects may
        be accessed by clients using \"objref\" members. The name of the service must conform
        to the naming rules of Robot Raconteur member names. A service is closed using
        either CloseService() or when Shutdown() is called.

        Multiple services can be registered within the same node. Service names
        within a single node must be unique.

        :param name: The name of the service, must follow member naming rules
        :type name: str
        :param objecttype: The fully qualified Robot Raconteur type of the object
        :param obj: The root object of the service
        :param securitypolicy: An optional security policy for the service to control authentication
          and other security functions
        :type securitypolicy: ServiceSecurityPolicy
        :return: The instantiated ServerContext. This object is owned
          by the node and the return can be safely ignored.
        :rtype: ServerContext
        """
        from .RobotRaconteurPythonUtil import WrappedServiceSkelDirectorPython, SplitQualifiedName
        director=WrappedServiceSkelDirectorPython(obj)
        rrobj=WrappedRRObject(objecttype,director,0)
        director.__disown__()
        return self._RegisterService(name,SplitQualifiedName(objecttype)[0],rrobj,securitypolicy)

    NodeID = property(lambda self: self._NodeID(), 
        doc = """
        (RobotRaconteur.NodeID) The current NodeID. If one has not been set, one will be automatically generated
        when read. NodeID cannot be set after it has been configured.	
        """)
    def SetNodeID(self,nodeid):
        """
        Set the NodeID

        The NodeID must be set before NodeID is called. If an attempt to set 
        the NodeID after NodeID has been called, an InvalidOperationException
        will be thrown.

        The NodeID must not be all zeros.

        :param nodeid: The NodeID
        :type nodeid: RobotRaconteur.NodeID
        """
        self._SetNodeID(nodeid)
    NodeName =property(lambda self: self._NodeName(),
        doc = """
        (str) The current NodeName. If one has not been set, it will be the empty string. Cannot be set after it has been configured.	
        """)
    def SetNodeName(self,nodename):
        """
        Set the NodeName

        The NodeName must be set before calling NodeName If an attempt to set 
        the NodeName after NodeName has been called, an InvalidOperationException
        will be thrown.

        The NodeName must not be empty, and must conform to the following regex:

        ^[a-zA-Z][a-zA-Z0-9_\\.\\-]*$

        :param nodename: The NodeName
        :type nodename: str
        """
        self._SetNodeName(nodename)
    ThreadPoolCount = property(lambda self: self._GetThreadPoolCount(), lambda self,c: self._SetThreadPoolCount(c),
        doc = """
        (int) The size of the native thread pool. May be configured dynamically.
        """)

    RequestTimeout = property(lambda self : self._GetRequestTimeout()/1000.0, lambda self,t : self._SetRequestTimeout(t*1000),
        doc = """
        (float) The timeout for requests in seconds

        Requests are calls to a remote node that expect a response. \"function\",
        \"property\", \"callback\", \"memory\", and setup calls in \"pipe\" and \"wire\"
        are all requests. All other Robot Raconteur functions that call the remote
        node and expect a response are requests. Default timeout is 15 seconds.
        """)
    TransportInactivityTimeout = property(lambda self : self._GetTransportInactivityTimeout()/1000.0, lambda self,t : self._SetTransportInactivityTimeout(t*1000),
        doc = """
        (float) The timeout for transport activity in seconds

        Sets a timeout for transport inactivity. If no message
        is sent or received on the transport for the specified time,
        the transport is closed. Default timeout is 10 minutes.
        """)
    EndpointInactivityTimeout = property(lambda self : self._GetEndpointInactivityTimeout()/1000.0, lambda self,t : self._SetEndpointInactivityTimeout(t*1000),
        doc = """
        (float) The timeout for endpoint activity in seconds

        Sets a timeout for endpoint inactivity. If no message
        is sent or received by the endpoint for the specified time,
        the endpoint is closed. Default timeout is 10 minutes.
        """
    )
    MemoryMaxTransferSize = property(lambda self: self._GetMemoryMaxTransferSize(), lambda self,m: self._SetMemoryMaxTransferSize(m),
        doc = """
        (int) The maximum chunk size for memory transfers in bytes

        \"memory\" members break up large transfers into chunks to avoid
        sending messages larger than the transport maximum, which is normally
        approximately 10 MB. The memory max transfer size is the largest
        data chunk the memory will send, in bytes. Default is 100 kB.
        """
    )
    NodeDiscoveryMaxCacheCount = property(lambda self: self._GetNodeDiscoveryMaxCacheCount(), lambda self,c: self._SetNodeDiscoveryMaxCacheCount(c),
        doc = """
        the maximum number of detected nodes that will be cached

        The node keeps a cache of detected nodes. The NodeDiscoveryMaxCacheCount
        sets an upper limit to how many detected nodes are cached. By default set to 4096
        """
    )

    def GetConstants(self,servicetype, obj=None):
        """
        Returns a structure that contains the constants of the specified service type

        :param servicetype: The name of the service definition
        :type servicetype: str
        :param obj: The client connection object reference to be used with to retrive service types.  
                This is necessary because each client maintains type information.  A client must be provided from 
                which type information can be queried. For services this parameter is unnecessary.
        :rtype: Dict[str,Any]
        """
        from .RobotRaconteurPythonUtil import ServiceDefinitionConstants
        if obj is None:
            d=self.GetServiceType(servicetype)
        else:
            d=self.GetPulledServiceType(obj,servicetype)
        return ServiceDefinitionConstants(d,self,obj)

    def GetExceptionType(self, exceptionname, obj=None):
        """
        Returns a reference to the exception class of fully qualified type ``exceptiontype``. 
        Note that this is a class reference, not an instance.

        :param exceptionname: The fully qualified name of the exception type
        :type exceptionname: str
        :param obj: The client connection object reference to be used with to retrive service types.  
                This is necessary because each client maintains type information.  A client must be provided from 
                which type information can be queried. For services this parameter is unnecessary.
        :return: Exception type
        """
        from .RobotRaconteurPythonUtil import SplitQualifiedName
        from .RobotRaconteurPythonError import GetExceptionType
        t=SplitQualifiedName(exceptionname)
        if (obj is None):
            d=self.GetServiceType(t[0])
        else:
            d=self.GetPulledServiceType(obj,t[0])
        if (not any(x.Name == t[1] for x in d.Exceptions)): 
            raise Exception('Invalid exception type')
        return GetExceptionType(exceptionname)

    def FindObjectType(self,obj,member,ind=None):
        """
        Returns the fully qualified object type that would be returned by an \"objref\" member

        :param obj: The object with the desired \"objref\"
        :param objref: The name of the \"objref\" member
        :type objref: str
        :param ind: The index for the \"objref\"
        :type ind: Union[int,str]
        :return: The fully qualified object type
        :rtype: str
        """
        if (ind is None):
            return self._FindObjectType(obj.rrinnerstub,member)
        else:
            return self._FindObjectType(obj.rrinnerstub,member,ind)

    def AsyncFindObjectType(self,obj,member,handler,timeout=RR_TIMEOUT_INFINITE):
        """
        Asynchronously returns an objref as a specific type

        Same as FindObjectType() but returns asynchronously

        If ``handler`` is None, returns an awaitable future.

        :param obj: The object with the desired \"objref\"
        :param objref: The name of the \"objref\" member
        :type objref: str
        :param handler: A handler function to receive the object type or an exception
        :type handler: Callable[[str,Exception],None]
        :param timeout: Timeout is milliseconds, or -1 for infinite
        :type timeout: float
        """
        from .RobotRaconteurPythonUtil import async_call, adjust_timeout, AsyncStringReturnDirectorImpl
        return async_call(self._AsyncFindObjectType,(obj.rrinnerstub,member,adjust_timeout(timeout)),AsyncStringReturnDirectorImpl,handler)

    def AsyncFindObjectTypeInd(self,obj,member,ind,handler,timeout=RR_TIMEOUT_INFINITE):
        """
        Asynchronously returns an objref as a specific type

        Same as FindObjectType() but returns asynchronously

        If ``handler`` is None, returns an awaitable future.

        :param obj: The object with the desired \"objref\"
        :param objref: The name of the \"objref\" member
        :type objref: str
        :param ind: The index for the \"objref\"
        :type ind: Union[int,str]
        :param handler: A handler function to receive the object type or an exception
        :type handler: Callable[[str,Exception],None]
        :param timeout: Timeout is milliseconds, or -1 for infinite
        :type timeout: float
        """
        from .RobotRaconteurPythonUtil import async_call, adjust_timeout, AsyncStringReturnDirectorImpl
        return async_call(self._AsyncFindObjectType,(obj.rrinnerstub,member,ind,adjust_timeout(timeout)),AsyncStringReturnDirectorImpl,handler)


    def SetExceptionHandler(self, handler):
        """
        Set an exception handler function

        The ThreadPool will catch exceptions that are uncaught
        by other logic and pass the exception to the specified
        exception handler. User handler functions that throw exceptions
        will also be caught and passed to the specified handler
        function

        :param handler: The handler function for uncaught exceptions
        :type handler: Callable[[Exception],None]
        """
        from .RobotRaconteurPythonUtil import ExceptionHandlerDirectorImpl
        if (handler is None):
            self._ClearExceptionHandler()
        else:
            d=ExceptionHandlerDirectorImpl(handler)
            d.__disown__()
            self._SetExceptionHandler(d,0)


    def CreateTimer(self,period,handler,oneshot=False):
        """
        Create a Timer object

        This function will normally return a WallTimer instance

        Start() must be called after timer creation

        :param period: The period of the timer in seconds
        :type period: float
        :param handler: The handler function to call when timer times out
        :type handler: Callable[[TimerEvent],None]
        :param oneshot: True if timer is a one-shot timer, False for repeated timer
        :type oneshot: bool
        :return: The new Timer object. Must call Start()
        :rtype: RobotRaconteur.Timer
        """
        from .RobotRaconteurPythonUtil import AsyncTimerEventReturnDirectorImpl

        handler2=AsyncTimerEventReturnDirectorImpl(handler)
        handler2.__disown__()
        ret= self._CreateTimer(period,oneshot,handler2,0)

        return ret

    def PostToThreadPool(self, handler):
        """
        Posts a function to be called by the node's native thread pool.

        :param handler: The function to call
        :type handler: Callable[[],None]
        """
        from .RobotRaconteurPythonUtil import async_call, AsyncVoidNoErrReturnDirectorImpl
        return async_call(self._PostToThreadPool,(), AsyncVoidNoErrReturnDirectorImpl,handler,noerror=True)

    RobotRaconteurVersion = property(lambda self: self._GetRobotRaconteurVersion(),
        doc = """(str) Returns the Robot Raconteur library version"""
    )

    def NowUTC(self):
        """
        The current time in UTC time zone

        Uses the internal node clock to get the current time in UTC.
        While this will normally use the system clock, this may
        use simulation time in certain circumstances

        :return: The current time in UTC
        :rtype: datetime.DateTime
        """
        return self._NowUTC()

    def NowTimeSpec(self):
        """
        The current time node time as a TimeSpec

        The current node time as a TimeSpec. See NowNodeTime()

        :return: The current node time as a TimeSpec
        :rtype: RobotRaconteur.TimeSpec
        """
        return self._NowTimeSpec()

    def NowNodeTime(self):
        """
        The current node time

        UTC time is not monotonic, due to the introduction of leap-seconds, and the possibility
        of the system clock being updated by the user. For a real-time systems, 
    	this is unaccetpable and can lead to system instability. The "node time" used by Robot Raconteur
    	is synchronized to UTC at startup, and is then steadily increasing from that initial time.
    	It will ignore changes to the system clock, and will also ignore corrections like leap
    	seconds.

        :return: The current node time
        :rtype: datetime.DateTime
        """
        return self._NowNodeTime()

    def NodeSyncTimeUTC(self):
        """
        The sync time of the node as a TimeSpec

        See NowNodeTime()

        :return: The node sync time as a TimeSpec
        :rtype: datetime.DateTime
        """
        return self._NodeSyncTimeUTC()

    def NodeSyncTimeSpec(self):
        """
        The sync time of the node as a TimeSpec

        See NowTimeSpec()

        :return: The node sync time as a TimeSpec
        :rtype: RobotRaconteur.TimeSpec
        """
        return self._NodeSyncTimeSpec()

    def Shutdown(self):
        """
        Shuts down the node. Called automatically by ClientNodeSetup and ServerNodeSetup

        Shutdown must be called before program exit to avoid segfaults and other undefined
        behavior. The singleton node is automatically shut down in Python. The use of 
        ClientNodeSetup and ServerNodeSetup is recommended to automate
        the node lifecycle. Calling this function does the following:
        1. Closes all services and releases all service objects
        2. Closes all client connections
        3. Shuts down discovery
        4. Shuts down all transports
        5. Notifies all shutdown listeners
        6. Releases all periodic cleanup task listeners
        7. Shuts down and releases the thread pool

        """
        self._Shutdown()

    def SubscribeServiceByType(self, service_types, filter_=None):
        """
        Subscribe to listen for available services and automatically connect

        A ServiceSubscription will track the availability of service types and
        create connections when available.

        :param service_types: A list of service types to listen for, ie \"com.robotraconteur.robotics.robot.Robot\"
        :type service_types: List[str]
        :param filter: A filter to select individual services based on specified criteria
        :type filter: RobotRaconteur.ServiceSubscriptionFilter
        :return: The active subscription
        :rtype: ServiceSubscription
        """
        from .RobotRaconteurPythonUtil import SubscribeServiceByType
        return SubscribeServiceByType(self, service_types, filter_)

    def SubscribeServiceInfo2(self, service_types, filter_=None):
        """
        Subscribe to listen for available services information

        A ServiceInfo2Subscription will track the availability of service types and
        inform when services become available or are lost. If connections to
        available services are also required, ServiceSubscription should be used.

        :param service_types: A list of service types to listen for, ie \"com.robotraconteur.robotics.robot.Robot\"
        :type service_types: List[str]
        :param filter: A filter to select individual services based on specified criteria
        :type filter: RobotRaconteur.ServiceSubscriptionFilter
        :return: The active subscription
        :rtype: ServiceInfo2Subscription
        """
        from .RobotRaconteurPythonUtil import SubscribeServiceInfo2
        return SubscribeServiceInfo2(self, service_types, filter_)

    def SubscribeService(self,*args):
        """
        SubscribeService(url,username=None,credentials=None)

        Subscribe to a service using one or more URL. Used to create robust connections to services

        Creates a ServiceSubscription assigned to a service with one or more candidate connection URLs. The
        subscription will attempt to maintain a peristent connection, reconnecting if the connection is lost.

        :param url: One or more candidate connection urls
        :type url: Union[str,List[str]]
        :param username: An optional username for authentication
        :type username: str
        :param credentials: Optional credentials for authentication
        :type credentials: Dict[str,Any]
        :return: The subscription object
        :rtype: RobotRaconteur.ServiceSubscription
        """
        from .RobotRaconteurPythonUtil import SubscribeService
        return SubscribeService(self, *args)



    def __init__(self):
        _RobotRaconteurPython.RobotRaconteurNode_swiginit(self, _RobotRaconteurPython.new_RobotRaconteurNode())
    __swig_destroy__ = _RobotRaconteurPython.delete_RobotRaconteurNode

# Register RobotRaconteurNode in _RobotRaconteurPython:
_RobotRaconteurPython.RobotRaconteurNode_swigregister(RobotRaconteurNode)

def RobotRaconteurNode_SelectRemoteNodeURL(urls):
    r"""


    Select the "best" URL from a std::vector of candidates

    Service discovery will often return a list of candidate URLs to 
    use to connect to a node. This function uses hueristics to select
    the "best" URL to use. The selection criteria ranks URLs in roughly
    the following order, lower number being better:

    1. "rr+intra" for IntraTransport
    2. "rr+local" for LocalTransport
    3. "rr+pci" or "rr+usb" for HardwareTransport
    4. "rrs+tcp://127.0.0.1" for secure TcpTransport loopback
    5. "rrs+tcp://[::1]" for secure TcpTransport IPv6 loopback
    6. "rrs+tcp://localhost" for secure TcpTransport loopback
    7. "rrs+tcp://[fe80" for secure TcpTransport link-local IPv6
    8. "rrs+tcp://" for any secure TcpTransport
    9. "rr+tcp://127.0.0.1" for TcpTransport loopback
    10. "rr+tcp://[::1]" for TcpTransport IPv6 loopback
    11. "rr+tcp://localhost" for TcpTransport loopback
    12. "rr+tcp://[fe80" for TcpTransport link-local IPv6
    13. "rr+tcp://" for any TcpTransport

    :param urls: The candidate URLs
    :type urls: List[str]
    :return: The "best" URL out of the candidates
    :rtype: str

    """
    return _RobotRaconteurPython.RobotRaconteurNode_SelectRemoteNodeURL(urls)

def RobotRaconteurNode__get_s():
    return _RobotRaconteurPython.RobotRaconteurNode__get_s()


def _NewStructure(type, obj, node):
    return _RobotRaconteurPython._NewStructure(type, obj, node)

def _GetStructureType(type, obj, node):
    return _RobotRaconteurPython._GetStructureType(type, obj, node)

def _GetNumPyDescrForType(*args):
    return _RobotRaconteurPython._GetNumPyDescrForType(*args)

def _GetNamedTypeEntryType(type1, obj, node):
    return _RobotRaconteurPython._GetNamedTypeEntryType(type1, obj, node)

def _PackMessageElement(*args):
    return _RobotRaconteurPython._PackMessageElement(*args)

def _UnpackMessageElement(*args):
    return _RobotRaconteurPython._UnpackMessageElement(*args)

def _PackToRRArray(array_, type1, destrrarray):
    return _RobotRaconteurPython._PackToRRArray(array_, type1, destrrarray)

def _UnpackFromRRArray(rrarray, type1):
    return _RobotRaconteurPython._UnpackFromRRArray(rrarray, type1)

def _RRTypeIdToNumPyDataType(rr_type):
    return _RobotRaconteurPython._RRTypeIdToNumPyDataType(rr_type)
RobotRaconteurNodeSetupFlags_NONE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_NONE
r"""No options enabled"""
RobotRaconteurNodeSetupFlags_ENABLE_NODE_DISCOVERY_LISTENING = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_NODE_DISCOVERY_LISTENING
r"""Enable node discovery listening on all transports"""
RobotRaconteurNodeSetupFlags_ENABLE_NODE_ANNOUNCE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_NODE_ANNOUNCE
r"""Enable node announce on all transports"""
RobotRaconteurNodeSetupFlags_ENABLE_LOCAL_TRANSPORT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_LOCAL_TRANSPORT
r"""Enable LocalTransport"""
RobotRaconteurNodeSetupFlags_ENABLE_TCP_TRANSPORT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_TCP_TRANSPORT
r"""Enable TcpTransport"""
RobotRaconteurNodeSetupFlags_ENABLE_HARDWARE_TRANSPORT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_HARDWARE_TRANSPORT
r"""Enable HardwareTransport"""
RobotRaconteurNodeSetupFlags_LOCAL_TRANSPORT_START_SERVER = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_LOCAL_TRANSPORT_START_SERVER
r"""Start the LocalTransport server to listen for incoming clients"""
RobotRaconteurNodeSetupFlags_LOCAL_TRANSPORT_START_CLIENT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_LOCAL_TRANSPORT_START_CLIENT
r"""Start the LocalTransport client with specified node name"""
RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_START_SERVER = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_START_SERVER
r"""Start the TcpTransport server to listen for incoming clients on the specified port"""
RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_START_SERVER_PORT_SHARER = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_START_SERVER_PORT_SHARER
r"""Start the TcpTransport server to incoming for incoming clients using the port sharer"""
RobotRaconteurNodeSetupFlags_DISABLE_MESSAGE4 = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_DISABLE_MESSAGE4
r"""Disable Message Format Version 4 on all transports"""
RobotRaconteurNodeSetupFlags_DISABLE_STRINGTABLE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_DISABLE_STRINGTABLE
r"""Disable Message Format Version 4 string table on all transports"""
RobotRaconteurNodeSetupFlags_DISABLE_TIMEOUTS = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_DISABLE_TIMEOUTS
r"""Disable all timeouts (useful for debugging)"""
RobotRaconteurNodeSetupFlags_LOAD_TLS_CERT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_LOAD_TLS_CERT
r"""Load the TLS certificate for TcpTransport"""
RobotRaconteurNodeSetupFlags_REQUIRE_TLS = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_REQUIRE_TLS
r"""Require TLS for all clients on TcpTransport"""
RobotRaconteurNodeSetupFlags_LOCAL_TRANSPORT_SERVER_PUBLIC = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_LOCAL_TRANSPORT_SERVER_PUBLIC
r"""Make LocalTransport server listen for incoming clients from all users"""
RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_LISTEN_LOCALHOST = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_LISTEN_LOCALHOST
RobotRaconteurNodeSetupFlags_NODENAME_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_NODENAME_OVERRIDE
r"""Allow NodeName to be configured using command line options"""
RobotRaconteurNodeSetupFlags_NODEID_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_NODEID_OVERRIDE
r"""Allow NodeID to be configured using command line options"""
RobotRaconteurNodeSetupFlags_TCP_PORT_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_PORT_OVERRIDE
r"""Allow TCP port to be configured using command line options"""
RobotRaconteurNodeSetupFlags_TCP_WEBSOCKET_ORIGIN_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_WEBSOCKET_ORIGIN_OVERRIDE
r"""Allow TCP WebSocket origin control to be configured using command line options"""
RobotRaconteurNodeSetupFlags_ENABLE_INTRA_TRANSPORT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_INTRA_TRANSPORT
r"""Enable IntraTransport"""
RobotRaconteurNodeSetupFlags_INTRA_TRANSPORT_START_SERVER = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_INTRA_TRANSPORT_START_SERVER
r"""Start the IntraTransport server to listen for incoming clients"""
RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_IPV4_DISCOVERY = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_IPV4_DISCOVERY
RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_IPV6_DISCOVERY = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_TCP_TRANSPORT_IPV6_DISCOVERY
RobotRaconteurNodeSetupFlags_LOCAL_TAP_ENABLE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_LOCAL_TAP_ENABLE
r"""Enable the LocalTap debug logging system"""
RobotRaconteurNodeSetupFlags_LOCAL_TAP_NAME = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_LOCAL_TAP_NAME
r"""Allow the user to set the LocalTap name"""
RobotRaconteurNodeSetupFlags_JUMBO_MESSAGE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_JUMBO_MESSAGE
RobotRaconteurNodeSetupFlags_ENABLE_ALL_TRANSPORTS = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_ENABLE_ALL_TRANSPORTS
r"""Convenience flag to enable all transports"""
RobotRaconteurNodeSetupFlags_CLIENT_DEFAULT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_CLIENT_DEFAULT
r"""Default configuration for client nodes (See ClientNodeSetup)"""
RobotRaconteurNodeSetupFlags_CLIENT_DEFAULT_ALLOWED_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_CLIENT_DEFAULT_ALLOWED_OVERRIDE
r"""Default allowed overrides for client nodes (See ClientNodeSetup)"""
RobotRaconteurNodeSetupFlags_SERVER_DEFAULT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_SERVER_DEFAULT
r"""Default configuration for server nodes"""
RobotRaconteurNodeSetupFlags_SERVER_DEFAULT_ALLOWED_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_SERVER_DEFAULT_ALLOWED_OVERRIDE
r"""Default allowed overrides for server nodes"""
RobotRaconteurNodeSetupFlags_SECURE_SERVER_DEFAULT = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_SECURE_SERVER_DEFAULT
r"""Default configuration for server nodes requiring TLS network transports"""
RobotRaconteurNodeSetupFlags_SECURE_SERVER_DEFAULT_ALLOWED_OVERRIDE = _RobotRaconteurPython.RobotRaconteurNodeSetupFlags_SECURE_SERVER_DEFAULT_ALLOWED_OVERRIDE
r"""Default allowed overrides for server nodes requiring TLS network transports"""
@_swig_add_metaclass(_SwigNonDynamicMeta)
class CommandLineConfigParser(object):
    r"""

    Command line parser for node setup classes

    The CommandLineConfigParser is used to parse command line options specified
    when a program is launched. These options allow for the node configuration to be
    changed without recompiling the software. See \ref command_line_options for
    a table of the standard command line options.

    ClientNodeSetup, ServerNodeSetup, and SecureServerNodeSetup use this class to parse
    the ``sys.argv`` parameters. The RobotRaconteurNodeSetup constructors will accept
    either ``sys.argv``, or will accept an initialize CommandLineConfigParser.

    The CommandLineConfig() constructor takes the "allowed override" flags, and the option prefix.
    The "allowed override" specifies which options can be overridden using the command line. The
    prefix option allows the command line flag prefix to be changed. By default it expects
    all options to begin with `--robotraconteur-` followed by the name of the option. If there are
    multiple nodes, it is necessary to change the prefix to be unique for each node. For instance,
    "robotraconteur1-" for the first node and "robotraconteur2-" for the second node.

    Users may add additional options to the parser. Use AddStringOption(),
    AddBoolOption(), or AddIntOption() to add additional options.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _RobotRaconteurPython.CommandLineConfigParser_swiginit(self, _RobotRaconteurPython.new_CommandLineConfigParser(*args))

    def SetDefaults(self, node_name, tcp_port, default_flags):
        r"""

        Set the default NodeName, TCP port, and flags

        The command line options will be allowed to override the options
        specified in allowed_overrides passed to CommandLineConfigParser().

        :param node_name: The default NodeName
        :type node_name str
        :param tcp_port: The default TCP port
        :type tcp_port: int
        :param default_flags: The default flags
        :type default_flags: int

        """
        return _RobotRaconteurPython.CommandLineConfigParser_SetDefaults(self, node_name, tcp_port, default_flags)

    def AddStringOption(self, name, descr):
        r"""

        Add a new string option

        :param name: The name of the option
        :type name: str
        :param descr: Description of the option
        :type descr: str

        """
        return _RobotRaconteurPython.CommandLineConfigParser_AddStringOption(self, name, descr)

    def AddBoolOption(self, name, descr):
        r"""

        Add a new bool option

        :param name: The name of the option
        :type name: str
        :param descr: Description of the option
        :type descr: str

        """
        return _RobotRaconteurPython.CommandLineConfigParser_AddBoolOption(self, name, descr)

    def AddIntOption(self, name, descr):
        r"""

        Add a new int32_t option

        :param name: The name of the option
        :type name: str
        :param descr: Description of the option
        :type descr: str

        """
        return _RobotRaconteurPython.CommandLineConfigParser_AddIntOption(self, name, descr)

    def ParseCommandLine(self, args):
        r"""

        Parse a specified string vector containing the options

        Results are stored in the instance

        :param args: The options as a string list
        :type args: List[str]

        """
        return _RobotRaconteurPython.CommandLineConfigParser_ParseCommandLine(self, args)

    def GetOptionOrDefaultAsString(self, *args):
        r"""

        Get the option value as a string

        Returns default_value if option not specified on command line

        :param option: The name of the option
        :type option: str
        :param default_value: The default option value
        :type default_value: str
        :return: The option value, or default_value if not specified on command line
        :rtype: str

        """
        return _RobotRaconteurPython.CommandLineConfigParser_GetOptionOrDefaultAsString(self, *args)

    def GetOptionOrDefaultAsBool(self, *args):
        r"""

        Get the option value as a bool

        Returns default_value if option not specified on command line

        :param option: The name of the option
        :type option: bool
        :param default_value: The default option value
        :type default_value: bool
        :return: The option value, or default_value if not specified on command line
        :rtype: bool

        """
        return _RobotRaconteurPython.CommandLineConfigParser_GetOptionOrDefaultAsBool(self, *args)

    def GetOptionOrDefaultAsInt(self, *args):
        r"""

        Get the option value as an int

        Returns default_value if option not specified on command line

        :param option: The name of the option
        :type option: str
        :param default_value: The default option value
        :type default_value: int
        :return: The option value, or default_value if not specified on command line
        :rtype: int

        """
        return _RobotRaconteurPython.CommandLineConfigParser_GetOptionOrDefaultAsInt(self, *args)
    __swig_destroy__ = _RobotRaconteurPython.delete_CommandLineConfigParser

# Register CommandLineConfigParser in _RobotRaconteurPython:
_RobotRaconteurPython.CommandLineConfigParser_swigregister(CommandLineConfigParser)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class WrappedRobotRaconteurNodeSetup(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def GetLocalTransport(self):
        return _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_GetLocalTransport(self)

    def GetIntraTransport(self):
        return _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_GetIntraTransport(self)

    def GetTcpTransport(self):
        return _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_GetTcpTransport(self)

    def GetHardwareTransport(self):
        return _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_GetHardwareTransport(self)

    def GetCommandLineConfig(self):
        return _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_GetCommandLineConfig(self)

    def ReleaseNode(self):
        return _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_ReleaseNode(self)
    __swig_destroy__ = _RobotRaconteurPython.delete_WrappedRobotRaconteurNodeSetup

    def __init__(self, *args):
        _RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_swiginit(self, _RobotRaconteurPython.new_WrappedRobotRaconteurNodeSetup(*args))

# Register WrappedRobotRaconteurNodeSetup in _RobotRaconteurPython:
_RobotRaconteurPython.WrappedRobotRaconteurNodeSetup_swigregister(WrappedRobotRaconteurNodeSetup)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class BroadcastDownsampler(object):
    r"""

    Downsampler to manage rate of packets sent to client

    PipeBroadcaster and WireBroadcaster by default sends packets to all clients when
    a pipe packet is sent or the wire value is changed. The updates typically happen
    within a sensor or control loop, with the rate set by the specific device producing
    the updates. Some clients may require less frequent data, and may run in to bandwidth
    or processing issues if the data is sent at the full update rate. The BroadcastDownsampler
    is used to implement broadcaster predicates that will drop packets. 
    Clients specify how many packets they want dropped between each packet sent. For instance,
    a downsample of 0 means that no packets are dropped. A downsample of 1 will drop every other
    packet. A downsample of two will drop 2 packets between sending 1 packet, etc. The 
    downsample level for each client is set using SetClientDownsample(). This should be
    made available to the client using a property member.

    PipeBroadcaster and WireBroadcaster must be added to the downsampler
    using AddPipeBroadcaster() and AddWireBroadcaster(), respectively.
    It is recommended that these functions be called within
    the RRServiceObjectInit(context,servicepath) function thit is called
    by the node when a service object is initialized.

    BeginStep() and EndStep() must be called for each iteration of the
    broadcasting loop. Use BroadcastDownsamplerStep for automatic
    management in the loop.

    See com.robotraconteur.isoch.IsochDevice for the standard use 
    of downsampling. 

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self,context,default_downsample = 0):
        """
        Initialize the BroadcastDownsampler

        :param context: The ServerContext of the service
        :type context: ServerContext
        :param default_downsample: The default downsample for clients
        :type default_downsample: int
        """
    #This is a shadowed function		
        _RobotRaconteurPython.BroadcastDownsampler_swiginit(self, _RobotRaconteurPython.new_BroadcastDownsampler())
        self._Init(context, default_downsample)



    def _Init(self, context, default_downsample=0):
        return _RobotRaconteurPython.BroadcastDownsampler__Init(self, context, default_downsample)

    def GetClientDownsample(self, ep):
        r"""

        Get the downsample for the specified client

        :param ep: The endpoint ID of the client
        :type ep: int
        :return: The downsample
        :rtype: int

        """
        return _RobotRaconteurPython.BroadcastDownsampler_GetClientDownsample(self, ep)

    def SetClientDownsample(self, ep, downsample):
        r"""

        Set the downsample for the specified client

        :param ep: The endpoint ID of the client
        :type ep: int
        :param downsample: The desired downsample
        :type downsample: int

        """
        return _RobotRaconteurPython.BroadcastDownsampler_SetClientDownsample(self, ep, downsample)

    def BeginStep(self):
        r"""

        Begin the update loop step

        Use BroadcastDownsamplerStep for automatic stepping

        """
        return _RobotRaconteurPython.BroadcastDownsampler_BeginStep(self)

    def EndStep(self):
        r"""

        End the update loop step

        Use BroadcastDownsamplerStep for automatic stepping

        """
        return _RobotRaconteurPython.BroadcastDownsampler_EndStep(self)

    def _AddPipeBroadcaster(self, broadcaster):
        return _RobotRaconteurPython.BroadcastDownsampler__AddPipeBroadcaster(self, broadcaster)

    def _AddWireBroadcaster(self, broadcaster):
        return _RobotRaconteurPython.BroadcastDownsampler__AddWireBroadcaster(self, broadcaster)


    def AddPipeBroadcaster(self, broadcaster):
        """
        Add a PipeBroadcaster to the downsampler

        Sets the predicate of the broadcaster to this downsampler

        :param broadcaster: The pipe broadcaster to add
        :type broadcaster: PipeBroadcaster
        """
        self._AddPipeBroadcaster(broadcaster._innerpipe)

    def AddWireBroadcaster(self, broadcaster):
        """
        Add a WireBroadcaster to the downsampler

        Sets the predicate of the broadcaster to this downsampler

        :param broadcaster: The pipe broadcaster to add
        :type broadcaster: PipeBroadcaster
        """
        self._AddWireBroadcaster(broadcaster._innerpipe)


    __swig_destroy__ = _RobotRaconteurPython.delete_BroadcastDownsampler

# Register BroadcastDownsampler in _RobotRaconteurPython:
_RobotRaconteurPython.BroadcastDownsampler_swigregister(BroadcastDownsampler)

class RRNativeDirectorSupport(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Start():
        return _RobotRaconteurPython.RRNativeDirectorSupport_Start()

    @staticmethod
    def Stop():
        return _RobotRaconteurPython.RRNativeDirectorSupport_Stop()

    @staticmethod
    def IsRunning():
        return _RobotRaconteurPython.RRNativeDirectorSupport_IsRunning()

    def __init__(self):
        _RobotRaconteurPython.RRNativeDirectorSupport_swiginit(self, _RobotRaconteurPython.new_RRNativeDirectorSupport())
    __swig_destroy__ = _RobotRaconteurPython.delete_RRNativeDirectorSupport

# Register RRNativeDirectorSupport in _RobotRaconteurPython:
_RobotRaconteurPython.RRNativeDirectorSupport_swigregister(RRNativeDirectorSupport)

def RRNativeDirectorSupport_Start():
    return _RobotRaconteurPython.RRNativeDirectorSupport_Start()

def RRNativeDirectorSupport_Stop():
    return _RobotRaconteurPython.RRNativeDirectorSupport_Stop()

def RRNativeDirectorSupport_IsRunning():
    return _RobotRaconteurPython.RRNativeDirectorSupport_IsRunning()


def SetPythonTracebackPrintExc(value):
    return _RobotRaconteurPython.SetPythonTracebackPrintExc(value)


import datetime
try:
	import numpy
except:
	pass

import weakref

import atexit
@atexit.register
def RobotRaconteur_cleanup():
    RobotRaconteurNode.s.Shutdown()
    RRNativeDirectorSupport.Stop()

RRNativeDirectorSupport.Start()



