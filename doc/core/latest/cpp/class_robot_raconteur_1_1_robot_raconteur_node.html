<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: RobotRaconteur::RobotRaconteurNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>RobotRaconteur</b></li><li class="navelem"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_robot_raconteur_1_1_robot_raconteur_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RobotRaconteur::RobotRaconteurNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The central node implementation.  
 <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#details">More...</a></p>

<p>Inherits noncopyable, and enable_shared_from_this&lt; RobotRaconteurNode &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node_1_1_scoped_monitor_lock.html">ScopedMonitorLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20f7a8892481899ab761f0169737475e" title="Creates a monitor lock on a specified object.">RobotRaconteurNode::MonitorEnter()</a> and <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#adb28c18c0297ec597596f79586308a83" title="Releases a monitor lock.">RobotRaconteurNode::MonitorExit()</a> to take advantage of RAII scoping.  <a href="class_robot_raconteur_1_1_robot_raconteur_node_1_1_scoped_monitor_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a3bb5b109dd19f327c15a17d0d2df44"><td class="memItemLeft" align="right" valign="top"><a id="a2a3bb5b109dd19f327c15a17d0d2df44"></a>
typedef boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2a3bb5b109dd19f327c15a17d0d2df44">shutdown_listener_connection</a></td></tr>
<tr class="memdesc:a2a3bb5b109dd19f327c15a17d0d2df44"><td class="mdescLeft">&#160;</td><td class="mdescRight">signals2 connection type for <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a077222702f03aa7c62521c532fe7e448" title="Adds a shutdown listener.">AddShutdownListener()</a> <br /></td></tr>
<tr class="separator:a2a3bb5b109dd19f327c15a17d0d2df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7015109cd5ef432d7c8474b31cddce9c"><td class="memItemLeft" align="right" valign="top"><a id="a7015109cd5ef432d7c8474b31cddce9c"></a>
typedef boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a7015109cd5ef432d7c8474b31cddce9c">node_updated_listener_connection</a></td></tr>
<tr class="memdesc:a7015109cd5ef432d7c8474b31cddce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boost::signals2 connection type for AddNodeServicesDetectedListener. <br /></td></tr>
<tr class="separator:a7015109cd5ef432d7c8474b31cddce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b75427787625ce02f9d524a2134b78"><td class="memItemLeft" align="right" valign="top"><a id="a70b75427787625ce02f9d524a2134b78"></a>
typedef boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a70b75427787625ce02f9d524a2134b78">node_lost_listener_connection</a></td></tr>
<tr class="memdesc:a70b75427787625ce02f9d524a2134b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boost::signals2 connection type for AddNodeDetectionLostListener. <br /></td></tr>
<tr class="separator:a70b75427787625ce02f9d524a2134b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9de5d50be75a77ba155e8ebf83987108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9de5d50be75a77ba155e8ebf83987108">Init</a> ()</td></tr>
<tr class="memdesc:a9de5d50be75a77ba155e8ebf83987108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the node. Called automatically for <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b" title="Singleton accessor.">s()</a></code> and <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f" title="Singleton shared_ptr accessor.">sp()</a></code>  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9de5d50be75a77ba155e8ebf83987108">More...</a><br /></td></tr>
<tr class="separator:a9de5d50be75a77ba155e8ebf83987108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564eaed878fa2d978b1a4beaac05636f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a564eaed878fa2d978b1a4beaac05636f">RobotRaconteurNode</a> ()</td></tr>
<tr class="memdesc:a564eaed878fa2d978b1a4beaac05636f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Robot Raconteur Node object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a564eaed878fa2d978b1a4beaac05636f">More...</a><br /></td></tr>
<tr class="separator:a564eaed878fa2d978b1a4beaac05636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6859ecf8c0069d81083f24658152ea4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6859ecf8c0069d81083f24658152ea4f">NodeID</a> ()</td></tr>
<tr class="memdesc:a6859ecf8c0069d81083f24658152ea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6859ecf8c0069d81083f24658152ea4f">More...</a><br /></td></tr>
<tr class="separator:a6859ecf8c0069d81083f24658152ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816484b0722841071cbfe222e6918630"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a816484b0722841071cbfe222e6918630">NodeName</a> ()</td></tr>
<tr class="memdesc:a816484b0722841071cbfe222e6918630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current NodeName.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a816484b0722841071cbfe222e6918630">More...</a><br /></td></tr>
<tr class="separator:a816484b0722841071cbfe222e6918630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fb2f14aaa470a4b2f08b752bcb5d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ab5fb2f14aaa470a4b2f08b752bcb5d8d">SetNodeID</a> (const <a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;id)</td></tr>
<tr class="memdesc:ab5fb2f14aaa470a4b2f08b752bcb5d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ab5fb2f14aaa470a4b2f08b752bcb5d8d">More...</a><br /></td></tr>
<tr class="separator:ab5fb2f14aaa470a4b2f08b752bcb5d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad736626db2dede0ed836a787ba59f1ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ad736626db2dede0ed836a787ba59f1ca">SetNodeName</a> (boost::string_ref name)</td></tr>
<tr class="memdesc:ad736626db2dede0ed836a787ba59f1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the NodeName.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ad736626db2dede0ed836a787ba59f1ca">More...</a><br /></td></tr>
<tr class="separator:ad736626db2dede0ed836a787ba59f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff40f8f3efd9e75f28d36ac429f7b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9ff40f8f3efd9e75f28d36ac429f7b76">TryGetNodeID</a> (<a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;id)</td></tr>
<tr class="memdesc:a9ff40f8f3efd9e75f28d36ac429f7b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries getting the current <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9ff40f8f3efd9e75f28d36ac429f7b76">More...</a><br /></td></tr>
<tr class="separator:a9ff40f8f3efd9e75f28d36ac429f7b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343fba84bcca2c7e1b0554b4f610344b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a343fba84bcca2c7e1b0554b4f610344b">TryGetNodeName</a> (std::string &amp;node_name)</td></tr>
<tr class="memdesc:a343fba84bcca2c7e1b0554b4f610344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries getting the current NodeName.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a343fba84bcca2c7e1b0554b4f610344b">More...</a><br /></td></tr>
<tr class="separator:a343fba84bcca2c7e1b0554b4f610344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf5a2f28e1ce280f60fef3f889ea7de"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_factory.html">ServiceFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#abbf5a2f28e1ce280f60fef3f889ea7de">GetServiceType</a> (boost::string_ref type)</td></tr>
<tr class="memdesc:abbf5a2f28e1ce280f60fef3f889ea7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previously registered service type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#abbf5a2f28e1ce280f60fef3f889ea7de">More...</a><br /></td></tr>
<tr class="separator:abbf5a2f28e1ce280f60fef3f889ea7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f178a29f83f0b99c6a73dd41a1546"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a942f178a29f83f0b99c6a73dd41a1546">IsServiceTypeRegistered</a> (boost::string_ref type)</td></tr>
<tr class="memdesc:a942f178a29f83f0b99c6a73dd41a1546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a service type has been registered.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a942f178a29f83f0b99c6a73dd41a1546">More...</a><br /></td></tr>
<tr class="separator:a942f178a29f83f0b99c6a73dd41a1546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52825328ff0b987d49f6212bfc5d47b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac52825328ff0b987d49f6212bfc5d47b">RegisterServiceType</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_factory.html">ServiceFactory</a> &gt; factory)</td></tr>
<tr class="memdesc:ac52825328ff0b987d49f6212bfc5d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a service type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac52825328ff0b987d49f6212bfc5d47b">More...</a><br /></td></tr>
<tr class="separator:ac52825328ff0b987d49f6212bfc5d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa024d6ce47e6c1cae050df28e6924ca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa024d6ce47e6c1cae050df28e6924ca4">UnregisterServiceType</a> (boost::string_ref type)</td></tr>
<tr class="memdesc:aa024d6ce47e6c1cae050df28e6924ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a previously registered service type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa024d6ce47e6c1cae050df28e6924ca4">More...</a><br /></td></tr>
<tr class="separator:aa024d6ce47e6c1cae050df28e6924ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8359f231c043cfce989d11f216bc3c0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8359f231c043cfce989d11f216bc3c0d">GetRegisteredServiceTypes</a> ()</td></tr>
<tr class="memdesc:a8359f231c043cfce989d11f216bc3c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return names of registered service types.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8359f231c043cfce989d11f216bc3c0d">More...</a><br /></td></tr>
<tr class="separator:a8359f231c043cfce989d11f216bc3c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd1a28c207e9b2b5a5363394f355b7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3fd1a28c207e9b2b5a5363394f355b7a">Shutdown</a> ()</td></tr>
<tr class="memdesc:a3fd1a28c207e9b2b5a5363394f355b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the node. Called automatically by <a class="el" href="class_robot_raconteur_1_1_client_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a client only node.">ClientNodeSetup</a> and <a class="el" href="class_robot_raconteur_1_1_server_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a server and client node.">ServerNodeSetup</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3fd1a28c207e9b2b5a5363394f355b7a">More...</a><br /></td></tr>
<tr class="separator:a3fd1a28c207e9b2b5a5363394f355b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077222702f03aa7c62521c532fe7e448"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:a077222702f03aa7c62521c532fe7e448"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2a3bb5b109dd19f327c15a17d0d2df44">shutdown_listener_connection</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a077222702f03aa7c62521c532fe7e448">AddShutdownListener</a> (BOOST_ASIO_MOVE_ARG(Handler) h)</td></tr>
<tr class="memdesc:a077222702f03aa7c62521c532fe7e448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a shutdown listener.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a077222702f03aa7c62521c532fe7e448">More...</a><br /></td></tr>
<tr class="separator:a077222702f03aa7c62521c532fe7e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb14a50a990168d4fbb9e629f1f802a2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#abb14a50a990168d4fbb9e629f1f802a2">RegisterTransport</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_transport.html">Transport</a> &gt; transport)</td></tr>
<tr class="memdesc:abb14a50a990168d4fbb9e629f1f802a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a transport for use by the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#abb14a50a990168d4fbb9e629f1f802a2">More...</a><br /></td></tr>
<tr class="separator:abb14a50a990168d4fbb9e629f1f802a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f4ed2c1b2cd3362a3e34b403cb909a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac5f4ed2c1b2cd3362a3e34b403cb909a">GetRequestTimeout</a> ()</td></tr>
<tr class="memdesc:ac5f4ed2c1b2cd3362a3e34b403cb909a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the timeout for requests in milliseconds.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac5f4ed2c1b2cd3362a3e34b403cb909a">More...</a><br /></td></tr>
<tr class="separator:ac5f4ed2c1b2cd3362a3e34b403cb909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c9e8c321a2ce28c8e0212bbf9fdf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a016c9e8c321a2ce28c8e0212bbf9fdf0">SetRequestTimeout</a> (uint32_t timeout)</td></tr>
<tr class="memdesc:a016c9e8c321a2ce28c8e0212bbf9fdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for requests in milliseconds.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a016c9e8c321a2ce28c8e0212bbf9fdf0">More...</a><br /></td></tr>
<tr class="separator:a016c9e8c321a2ce28c8e0212bbf9fdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2c3826df32cf422541e8c1d543c44"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1ba2c3826df32cf422541e8c1d543c44">GetTransportInactivityTimeout</a> ()</td></tr>
<tr class="memdesc:a1ba2c3826df32cf422541e8c1d543c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the timeout for transport activity in milliseconds.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1ba2c3826df32cf422541e8c1d543c44">More...</a><br /></td></tr>
<tr class="separator:a1ba2c3826df32cf422541e8c1d543c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c21bba9af0e777dcb08b2824d6c6bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9c21bba9af0e777dcb08b2824d6c6bef">SetTransportInactivityTimeout</a> (uint32_t timeout)</td></tr>
<tr class="memdesc:a9c21bba9af0e777dcb08b2824d6c6bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for transport activity in milliseconds.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9c21bba9af0e777dcb08b2824d6c6bef">More...</a><br /></td></tr>
<tr class="separator:a9c21bba9af0e777dcb08b2824d6c6bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6d3fa0284f0e644ef0eb6744717c83"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1d6d3fa0284f0e644ef0eb6744717c83">GetEndpointInactivityTimeout</a> ()</td></tr>
<tr class="memdesc:a1d6d3fa0284f0e644ef0eb6744717c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the timeout for endpoint activity in milliseconds.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1d6d3fa0284f0e644ef0eb6744717c83">More...</a><br /></td></tr>
<tr class="separator:a1d6d3fa0284f0e644ef0eb6744717c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62113027c9775e1345423e6e8d3b1cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa62113027c9775e1345423e6e8d3b1cd">SetEndpointInactivityTimeout</a> (uint32_t timeout)</td></tr>
<tr class="memdesc:aa62113027c9775e1345423e6e8d3b1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for endpoint activity in milliseconds.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa62113027c9775e1345423e6e8d3b1cd">More...</a><br /></td></tr>
<tr class="separator:aa62113027c9775e1345423e6e8d3b1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49aaf2196acab71f7d37c9ce4fdc3c4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac49aaf2196acab71f7d37c9ce4fdc3c4">GetMemoryMaxTransferSize</a> ()</td></tr>
<tr class="memdesc:ac49aaf2196acab71f7d37c9ce4fdc3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum chunk size for memory transfers in bytes.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac49aaf2196acab71f7d37c9ce4fdc3c4">More...</a><br /></td></tr>
<tr class="separator:ac49aaf2196acab71f7d37c9ce4fdc3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6bcc6a147105231ebb671d1bca000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ae1d6bcc6a147105231ebb671d1bca000">SetMemoryMaxTransferSize</a> (uint32_t size)</td></tr>
<tr class="memdesc:ae1d6bcc6a147105231ebb671d1bca000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum chunk size for memory transfers in bytes.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ae1d6bcc6a147105231ebb671d1bca000">More...</a><br /></td></tr>
<tr class="separator:ae1d6bcc6a147105231ebb671d1bca000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109089b84d2ff5057c81752e997bcd74"><td class="memItemLeft" align="right" valign="top">const boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html">RobotRaconteur::DynamicServiceFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a109089b84d2ff5057c81752e997bcd74">GetDynamicServiceFactory</a> ()</td></tr>
<tr class="memdesc:a109089b84d2ff5057c81752e997bcd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html" title="Dynamic service factory base class.">DynamicServiceFactory</a>. May be null.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a109089b84d2ff5057c81752e997bcd74">More...</a><br /></td></tr>
<tr class="separator:a109089b84d2ff5057c81752e997bcd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0b2c4e6bb149334a476e210b38bbc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5d0b2c4e6bb149334a476e210b38bbc2">SetDynamicServiceFactory</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html">RobotRaconteur::DynamicServiceFactory</a> &gt; f)</td></tr>
<tr class="memdesc:a5d0b2c4e6bb149334a476e210b38bbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DynamicServicefactory.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5d0b2c4e6bb149334a476e210b38bbc2">More...</a><br /></td></tr>
<tr class="separator:a5d0b2c4e6bb149334a476e210b38bbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074209e23f46fbdd14dd43aa7773caf7"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a074209e23f46fbdd14dd43aa7773caf7">RegisterService</a> (boost::string_ref name, boost::string_ref servicetype, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_security_policy.html">ServiceSecurityPolicy</a> &gt; securitypolicy=boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_security_policy.html">ServiceSecurityPolicy</a> &gt;())</td></tr>
<tr class="memdesc:a074209e23f46fbdd14dd43aa7773caf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a service for clients to connect.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a074209e23f46fbdd14dd43aa7773caf7">More...</a><br /></td></tr>
<tr class="separator:a074209e23f46fbdd14dd43aa7773caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44e1310015297746420eaec09a58d6"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#acf44e1310015297746420eaec09a58d6">RegisterService</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a> &gt; c)</td></tr>
<tr class="memdesc:acf44e1310015297746420eaec09a58d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a service using a previously instantiated <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#acf44e1310015297746420eaec09a58d6">More...</a><br /></td></tr>
<tr class="separator:acf44e1310015297746420eaec09a58d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8394d64e879ff871aa7d74284d082e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8394d64e879ff871aa7d74284d082e46">CloseService</a> (boost::string_ref sname)</td></tr>
<tr class="memdesc:a8394d64e879ff871aa7d74284d082e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a previously registered service.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8394d64e879ff871aa7d74284d082e46">More...</a><br /></td></tr>
<tr class="separator:a8394d64e879ff871aa7d74284d082e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2024c8688f488b5749ff627b9a834"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa6d2024c8688f488b5749ff627b9a834">GetRegisteredServiceNames</a> ()</td></tr>
<tr class="memdesc:aa6d2024c8688f488b5749ff627b9a834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of registered services.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa6d2024c8688f488b5749ff627b9a834">More...</a><br /></td></tr>
<tr class="separator:aa6d2024c8688f488b5749ff627b9a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb514353f6a8f72a59b797a8698463f3"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#abb514353f6a8f72a59b797a8698463f3">GetService</a> (boost::string_ref name)</td></tr>
<tr class="memdesc:abb514353f6a8f72a59b797a8698463f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a> for a service by name.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#abb514353f6a8f72a59b797a8698463f3">More...</a><br /></td></tr>
<tr class="separator:abb514353f6a8f72a59b797a8698463f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b207bb3fe03ffa925fbe0c63dcac417"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417">ConnectService</a> (boost::string_ref url, boost::string_ref username=&quot;&quot;, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt; credentials=(boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;()), boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt; listener=0, boost::string_ref objecttype=&quot;&quot;)</td></tr>
<tr class="memdesc:a1b207bb3fe03ffa925fbe0c63dcac417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a client connection to a remote service using a URL.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417">More...</a><br /></td></tr>
<tr class="separator:a1b207bb3fe03ffa925fbe0c63dcac417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5331e01f78fc91aee870738c9152c9a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2">AsyncConnectService</a> (boost::string_ref url, boost::string_ref username, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt; credentials, boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt; listener, boost::string_ref objecttype, boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a5331e01f78fc91aee870738c9152c9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously create a client connection to a remote service using a URL.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2">More...</a><br /></td></tr>
<tr class="separator:a5331e01f78fc91aee870738c9152c9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39572d25f9369f56545e4c6768e7d1e"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac39572d25f9369f56545e4c6768e7d1e">ConnectService</a> (const std::vector&lt; std::string &gt; &amp;urls, boost::string_ref username=&quot;&quot;, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt; credentials=(boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;()), boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt; listener=0, boost::string_ref objecttype=&quot;&quot;)</td></tr>
<tr class="memdesc:ac39572d25f9369f56545e4c6768e7d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a>, but accepts a vector of candidate URLs.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac39572d25f9369f56545e4c6768e7d1e">More...</a><br /></td></tr>
<tr class="separator:ac39572d25f9369f56545e4c6768e7d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292cd7265408d8095fe16eb12844b45f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a292cd7265408d8095fe16eb12844b45f">AsyncConnectService</a> (const std::vector&lt; std::string &gt; &amp;url, boost::string_ref username, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt; credentials, boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt; listener, boost::string_ref objecttype, boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a292cd7265408d8095fe16eb12844b45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">AsyncConnectService()</a>, but accepts a vector of candidate URLs.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a292cd7265408d8095fe16eb12844b45f">More...</a><br /></td></tr>
<tr class="separator:a292cd7265408d8095fe16eb12844b45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e5d8265fcc8b01caa9634966fcb496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a51e5d8265fcc8b01caa9634966fcb496">DisconnectService</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a51e5d8265fcc8b01caa9634966fcb496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a client connection to a service.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a51e5d8265fcc8b01caa9634966fcb496">More...</a><br /></td></tr>
<tr class="separator:a51e5d8265fcc8b01caa9634966fcb496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a7acc5b238233193a8cc53ac14985c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a55a7acc5b238233193a8cc53ac14985c">AsyncDisconnectService</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::function&lt; void()&gt; handler)</td></tr>
<tr class="memdesc:a55a7acc5b238233193a8cc53ac14985c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously disconnects a client connection to a service.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a55a7acc5b238233193a8cc53ac14985c">More...</a><br /></td></tr>
<tr class="separator:a55a7acc5b238233193a8cc53ac14985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8176cac5031ac966d092ddc5390ee5eb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8176cac5031ac966d092ddc5390ee5eb">GetServiceAttributes</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a8176cac5031ac966d092ddc5390ee5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the service attributes of a client connection.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8176cac5031ac966d092ddc5390ee5eb">More...</a><br /></td></tr>
<tr class="separator:a8176cac5031ac966d092ddc5390ee5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175883840bd94f8ddfa0c5521793f1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a175883840bd94f8ddfa0c5521793f1d6">GetServiceNodeID</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a175883840bd94f8ddfa0c5521793f1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the service <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> of the remote node from a client connection.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a175883840bd94f8ddfa0c5521793f1d6">More...</a><br /></td></tr>
<tr class="separator:a175883840bd94f8ddfa0c5521793f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd28e485bfb087578b06c296630b7cd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2bd28e485bfb087578b06c296630b7cd">GetServiceNodeName</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a2bd28e485bfb087578b06c296630b7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the service NodeName of the remote node from a client connection.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2bd28e485bfb087578b06c296630b7cd">More...</a><br /></td></tr>
<tr class="separator:a2bd28e485bfb087578b06c296630b7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b9afc0a6cbc7d27877c22ba143b01"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3b6b9afc0a6cbc7d27877c22ba143b01">GetServiceName</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a3b6b9afc0a6cbc7d27877c22ba143b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a service from a client connection.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3b6b9afc0a6cbc7d27877c22ba143b01">More...</a><br /></td></tr>
<tr class="separator:a3b6b9afc0a6cbc7d27877c22ba143b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f4273f0f0de7cf5ea3e87352a1a5ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ab4f4273f0f0de7cf5ea3e87352a1a5ff">GetObjectServicePath</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:ab4f4273f0f0de7cf5ea3e87352a1a5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the service path of a client object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ab4f4273f0f0de7cf5ea3e87352a1a5ff">More...</a><br /></td></tr>
<tr class="separator:ab4f4273f0f0de7cf5ea3e87352a1a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caa229cf64b5fa4545cb1c64ebd07d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2caa229cf64b5fa4545cb1c64ebd07d3">CheckConnection</a> (uint32_t endpoint)</td></tr>
<tr class="memdesc:a2caa229cf64b5fa4545cb1c64ebd07d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the TransportConnection associated with an endpoint is connected.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2caa229cf64b5fa4545cb1c64ebd07d3">More...</a><br /></td></tr>
<tr class="separator:a2caa229cf64b5fa4545cb1c64ebd07d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac002d45651eccda8dd8ce0af2d953f09"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_discovery_info.html">NodeDiscoveryInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac002d45651eccda8dd8ce0af2d953f09">GetDetectedNodes</a> ()</td></tr>
<tr class="memdesc:ac002d45651eccda8dd8ce0af2d953f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes currently detected by Transports.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac002d45651eccda8dd8ce0af2d953f09">More...</a><br /></td></tr>
<tr class="separator:ac002d45651eccda8dd8ce0af2d953f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261aaf116637c02a4160205692f27781"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:a261aaf116637c02a4160205692f27781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a7015109cd5ef432d7c8474b31cddce9c">node_updated_listener_connection</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a261aaf116637c02a4160205692f27781">AddNodeServicesDetectedListener</a> (BOOST_ASIO_MOVE_ARG(Handler) h)</td></tr>
<tr class="memdesc:a261aaf116637c02a4160205692f27781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to be called when detected services are updated.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a261aaf116637c02a4160205692f27781">More...</a><br /></td></tr>
<tr class="separator:a261aaf116637c02a4160205692f27781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd314e7388872e6b1d3483731c95941"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:abdd314e7388872e6b1d3483731c95941"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a70b75427787625ce02f9d524a2134b78">node_lost_listener_connection</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#abdd314e7388872e6b1d3483731c95941">AddNodeDetectionLostListener</a> (BOOST_ASIO_MOVE_ARG(Handler) h)</td></tr>
<tr class="memdesc:abdd314e7388872e6b1d3483731c95941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to be called when a node is no longer detected.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#abdd314e7388872e6b1d3483731c95941">More...</a><br /></td></tr>
<tr class="separator:abdd314e7388872e6b1d3483731c95941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5c9142ccb18ad1f55937c9d63ce743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b5c9142ccb18ad1f55937c9d63ce743">UpdateDetectedNodes</a> (const std::vector&lt; std::string &gt; &amp;schemes)</td></tr>
<tr class="memdesc:a1b5c9142ccb18ad1f55937c9d63ce743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the detected nodes cache.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b5c9142ccb18ad1f55937c9d63ce743">More...</a><br /></td></tr>
<tr class="separator:a1b5c9142ccb18ad1f55937c9d63ce743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7ae332a0c67fea7f74463ed405a3a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5d7ae332a0c67fea7f74463ed405a3a7">AsyncUpdateDetectedNodes</a> (const std::vector&lt; std::string &gt; &amp;schemes, boost::function&lt; void()&gt; handler, int32_t timeout=5000)</td></tr>
<tr class="memdesc:a5d7ae332a0c67fea7f74463ed405a3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously update the detected nodes cache.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5d7ae332a0c67fea7f74463ed405a3a7">More...</a><br /></td></tr>
<tr class="separator:a5d7ae332a0c67fea7f74463ed405a3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a067c797b846fdabc381afa23a6d973"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0a067c797b846fdabc381afa23a6d973">GetNodeDiscoveryMaxCacheCount</a> ()</td></tr>
<tr class="memdesc:a0a067c797b846fdabc381afa23a6d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of detected nodes that will be cached.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0a067c797b846fdabc381afa23a6d973">More...</a><br /></td></tr>
<tr class="separator:a0a067c797b846fdabc381afa23a6d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71e24cca00eb15c7cde46cdd171e649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#af71e24cca00eb15c7cde46cdd171e649">SetNodeDiscoveryMaxCacheCount</a> (uint32_t count)</td></tr>
<tr class="memdesc:af71e24cca00eb15c7cde46cdd171e649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of detected nodes that will be cached.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#af71e24cca00eb15c7cde46cdd171e649">More...</a><br /></td></tr>
<tr class="separator:af71e24cca00eb15c7cde46cdd171e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8dfa95723e02f603e5583a96ff11b4"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_info2_subscription.html">ServiceInfo2Subscription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9b8dfa95723e02f603e5583a96ff11b4">SubscribeServiceInfo2</a> (const std::vector&lt; std::string &gt; &amp;service_types, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a> &gt; filter=boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a> &gt;())</td></tr>
<tr class="memdesc:a9b8dfa95723e02f603e5583a96ff11b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to listen for available services information.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9b8dfa95723e02f603e5583a96ff11b4">More...</a><br /></td></tr>
<tr class="separator:a9b8dfa95723e02f603e5583a96ff11b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8639a0c1e88b6a23bcce13cdf37dd055"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription.html">ServiceSubscription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8639a0c1e88b6a23bcce13cdf37dd055">SubscribeServiceByType</a> (const std::vector&lt; std::string &gt; &amp;service_types, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a> &gt; filter=boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a> &gt;())</td></tr>
<tr class="memdesc:a8639a0c1e88b6a23bcce13cdf37dd055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to listen for available services and automatically connect.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8639a0c1e88b6a23bcce13cdf37dd055">More...</a><br /></td></tr>
<tr class="separator:a8639a0c1e88b6a23bcce13cdf37dd055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073f6638ab7a4db125de1125ad0e6f90"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription.html">ServiceSubscription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a073f6638ab7a4db125de1125ad0e6f90">SubscribeService</a> (const std::vector&lt; std::string &gt; &amp;url, boost::string_ref username=&quot;&quot;, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt; credentials=(boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;()), boost::string_ref objecttype=&quot;&quot;)</td></tr>
<tr class="memdesc:a073f6638ab7a4db125de1125ad0e6f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to a service using one or more URL. Used to create robust connections to services.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a073f6638ab7a4db125de1125ad0e6f90">More...</a><br /></td></tr>
<tr class="separator:a073f6638ab7a4db125de1125ad0e6f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5946e947d7c5bc5fac008dde8e2bc1"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription.html">ServiceSubscription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c5946e947d7c5bc5fac008dde8e2bc1">SubscribeService</a> (const std::string &amp;url, boost::string_ref username=&quot;&quot;, boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt; credentials=(boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;()), boost::string_ref objecttype=&quot;&quot;)</td></tr>
<tr class="memdesc:a5c5946e947d7c5bc5fac008dde8e2bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to a service using a URL. Used to create robust connections to services.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c5946e947d7c5bc5fac008dde8e2bc1">More...</a><br /></td></tr>
<tr class="separator:a5c5946e947d7c5bc5fac008dde8e2bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6a843097e6f17aee2b8660e58a3f48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_service_info2.html">ServiceInfo2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5e6a843097e6f17aee2b8660e58a3f48">FindServiceByType</a> (boost::string_ref servicetype, const std::vector&lt; std::string &gt; &amp;transportschemes)</td></tr>
<tr class="memdesc:a5e6a843097e6f17aee2b8660e58a3f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use discovery to find available services by service type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5e6a843097e6f17aee2b8660e58a3f48">More...</a><br /></td></tr>
<tr class="separator:a5e6a843097e6f17aee2b8660e58a3f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9adc2c77f3fcb7df3de563cb33a8d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ae9adc2c77f3fcb7df3de563cb33a8d36">AsyncFindServiceByType</a> (boost::string_ref servicetype, const std::vector&lt; std::string &gt; &amp;transportschemes, boost::function&lt; void(boost::shared_ptr&lt; std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_service_info2.html">ServiceInfo2</a> &gt; &gt;) &gt; handler, int32_t timeout=5000)</td></tr>
<tr class="memdesc:ae9adc2c77f3fcb7df3de563cb33a8d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously use discovery to find availabe services by service type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ae9adc2c77f3fcb7df3de563cb33a8d36">More...</a><br /></td></tr>
<tr class="separator:ae9adc2c77f3fcb7df3de563cb33a8d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f71bf3c96ed4e9a3cd4f953190ef9be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6f71bf3c96ed4e9a3cd4f953190ef9be">FindNodeByID</a> (const <a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;id, const std::vector&lt; std::string &gt; &amp;transportschemes)</td></tr>
<tr class="memdesc:a6f71bf3c96ed4e9a3cd4f953190ef9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds nodes on the network with a specified <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6f71bf3c96ed4e9a3cd4f953190ef9be">More...</a><br /></td></tr>
<tr class="separator:a6f71bf3c96ed4e9a3cd4f953190ef9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63105e3219469c78aad8569a65b5629e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a63105e3219469c78aad8569a65b5629e">AsyncFindNodeByID</a> (const <a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;id, const std::vector&lt; std::string &gt; &amp;transportschemes, boost::function&lt; void(boost::shared_ptr&lt; std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a> &gt; &gt;) &gt; handler, int32_t timeout=5000)</td></tr>
<tr class="memdesc:a63105e3219469c78aad8569a65b5629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously finds nodes on the network with the specified <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a63105e3219469c78aad8569a65b5629e">More...</a><br /></td></tr>
<tr class="separator:a63105e3219469c78aad8569a65b5629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683a1c228cbfb70bcc08430f49e52a5a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a683a1c228cbfb70bcc08430f49e52a5a">FindNodeByName</a> (boost::string_ref name, const std::vector&lt; std::string &gt; &amp;transportschemes)</td></tr>
<tr class="memdesc:a683a1c228cbfb70bcc08430f49e52a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds nodes on the network with a specified NodeName.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a683a1c228cbfb70bcc08430f49e52a5a">More...</a><br /></td></tr>
<tr class="separator:a683a1c228cbfb70bcc08430f49e52a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfec4072b487cde383788633d47ac8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9bfec4072b487cde383788633d47ac8b">AsyncFindNodeByName</a> (boost::string_ref name, const std::vector&lt; std::string &gt; &amp;transportschemes, boost::function&lt; void(boost::shared_ptr&lt; std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a> &gt; &gt;) &gt; handler, int32_t timeout=5000)</td></tr>
<tr class="memdesc:a9bfec4072b487cde383788633d47ac8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously finds nodes on the network with the specified NodeName.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9bfec4072b487cde383788633d47ac8b">More...</a><br /></td></tr>
<tr class="separator:a9bfec4072b487cde383788633d47ac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b19ab712aa7a96f7dfb7b3bfbf8673"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673">RequestObjectLock</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, <a class="el" href="_robot_raconteur_node_8h.html#acd5d4086935257f7b0aaac15cf805a58">RobotRaconteurObjectLockFlags</a> flags)</td></tr>
<tr class="memdesc:a92b19ab712aa7a96f7dfb7b3bfbf8673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an exclusive access lock to a service object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673">More...</a><br /></td></tr>
<tr class="separator:a92b19ab712aa7a96f7dfb7b3bfbf8673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1353a400015fe9d4e50ae35cff927b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a">AsyncRequestObjectLock</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, <a class="el" href="_robot_raconteur_node_8h.html#acd5d4086935257f7b0aaac15cf805a58">RobotRaconteurObjectLockFlags</a> flags, boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a1353a400015fe9d4e50ae35cff927b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously request an exclusive access lock to a service object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a">More...</a><br /></td></tr>
<tr class="separator:a1353a400015fe9d4e50ae35cff927b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fb5b31209ac66cd1b7a51ab9e3c622"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a52fb5b31209ac66cd1b7a51ab9e3c622">ReleaseObjectLock</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a52fb5b31209ac66cd1b7a51ab9e3c622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an excluse access lock previously locked with <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RequestObjectLock()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a" title="Asynchronously request an exclusive access lock to a service object.">AsyncRequestObjectLock()</a>  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a52fb5b31209ac66cd1b7a51ab9e3c622">More...</a><br /></td></tr>
<tr class="separator:a52fb5b31209ac66cd1b7a51ab9e3c622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95071780ea9e0c8e5efb09c8bda0e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4a95071780ea9e0c8e5efb09c8bda0e4">AsyncReleaseObjectLock</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a4a95071780ea9e0c8e5efb09c8bda0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously release an excluse access lock previously locked with <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RequestObjectLock()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a" title="Asynchronously request an exclusive access lock to a service object.">AsyncRequestObjectLock()</a>  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4a95071780ea9e0c8e5efb09c8bda0e4">More...</a><br /></td></tr>
<tr class="separator:a4a95071780ea9e0c8e5efb09c8bda0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f7a8892481899ab761f0169737475e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20f7a8892481899ab761f0169737475e">MonitorEnter</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a20f7a8892481899ab761f0169737475e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a monitor lock on a specified object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20f7a8892481899ab761f0169737475e">More...</a><br /></td></tr>
<tr class="separator:a20f7a8892481899ab761f0169737475e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb28c18c0297ec597596f79586308a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#adb28c18c0297ec597596f79586308a83">MonitorExit</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:adb28c18c0297ec597596f79586308a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a monitor lock.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#adb28c18c0297ec597596f79586308a83">More...</a><br /></td></tr>
<tr class="separator:adb28c18c0297ec597596f79586308a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f78b0932edf7f514939bf1049daf91b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5f78b0932edf7f514939bf1049daf91b">AddPeriodicCleanupTask</a> (boost::shared_ptr&lt; IPeriodicCleanupTask &gt; task)</td></tr>
<tr class="memdesc:a5f78b0932edf7f514939bf1049daf91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a periodic cleanup task.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5f78b0932edf7f514939bf1049daf91b">More...</a><br /></td></tr>
<tr class="separator:a5f78b0932edf7f514939bf1049daf91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017a1a72e885b41741a513aa1cfb4057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a017a1a72e885b41741a513aa1cfb4057">RemovePeriodicCleanupTask</a> (boost::shared_ptr&lt; IPeriodicCleanupTask &gt; task)</td></tr>
<tr class="memdesc:a017a1a72e885b41741a513aa1cfb4057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a task previously registered with <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5f78b0932edf7f514939bf1049daf91b" title="Add a periodic cleanup task.">AddPeriodicCleanupTask()</a>  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a017a1a72e885b41741a513aa1cfb4057">More...</a><br /></td></tr>
<tr class="separator:a017a1a72e885b41741a513aa1cfb4057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef3676c1fb9f6f1201a14b3f3b39c5"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#adbef3676c1fb9f6f1201a14b3f3b39c5">FindObjRefTyped</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::string_ref objecttype)</td></tr>
<tr class="memdesc:adbef3676c1fb9f6f1201a14b3f3b39c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an objref as a specific type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#adbef3676c1fb9f6f1201a14b3f3b39c5">More...</a><br /></td></tr>
<tr class="separator:adbef3676c1fb9f6f1201a14b3f3b39c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8835d6ca099f6726a17ae6da36d21af3"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8835d6ca099f6726a17ae6da36d21af3">FindObjRefTyped</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::string_ref index, boost::string_ref objecttype)</td></tr>
<tr class="memdesc:a8835d6ca099f6726a17ae6da36d21af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an indexed objref as a specified type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8835d6ca099f6726a17ae6da36d21af3">More...</a><br /></td></tr>
<tr class="separator:a8835d6ca099f6726a17ae6da36d21af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f1dd4a258f34fa0c0ee6ed9764e03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a33f1dd4a258f34fa0c0ee6ed9764e03c">AsyncFindObjRefTyped</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::string_ref objecttype, boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a33f1dd4a258f34fa0c0ee6ed9764e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously returns an objref as a specific type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a33f1dd4a258f34fa0c0ee6ed9764e03c">More...</a><br /></td></tr>
<tr class="separator:a33f1dd4a258f34fa0c0ee6ed9764e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5f91f872899af241eceddcbefe3c6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0d5f91f872899af241eceddcbefe3c6f">AsyncFindObjRefTyped</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::string_ref index, boost::string_ref objecttype, boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a0d5f91f872899af241eceddcbefe3c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously returns an objref as a specific type.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0d5f91f872899af241eceddcbefe3c6f">More...</a><br /></td></tr>
<tr class="separator:a0d5f91f872899af241eceddcbefe3c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c10bf7ed0082fd0395d7d5ad35cbbae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c10bf7ed0082fd0395d7d5ad35cbbae">FindObjectType</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref)</td></tr>
<tr class="memdesc:a5c10bf7ed0082fd0395d7d5ad35cbbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of a service object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c10bf7ed0082fd0395d7d5ad35cbbae">More...</a><br /></td></tr>
<tr class="separator:a5c10bf7ed0082fd0395d7d5ad35cbbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bf08c7dd8f01858675db558b5f4336"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a23bf08c7dd8f01858675db558b5f4336">FindObjectType</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::string_ref index)</td></tr>
<tr class="memdesc:a23bf08c7dd8f01858675db558b5f4336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of a service object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a23bf08c7dd8f01858675db558b5f4336">More...</a><br /></td></tr>
<tr class="separator:a23bf08c7dd8f01858675db558b5f4336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b63b166acd227a77273d64bb2d54029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2b63b166acd227a77273d64bb2d54029">AsyncFindObjectType</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a2b63b166acd227a77273d64bb2d54029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously returns the type of a service object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2b63b166acd227a77273d64bb2d54029">More...</a><br /></td></tr>
<tr class="separator:a2b63b166acd227a77273d64bb2d54029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9287ea2a5c9ec5c08b267e8f2af3669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#af9287ea2a5c9ec5c08b267e8f2af3669">AsyncFindObjectType</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref objref, boost::string_ref index, boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:af9287ea2a5c9ec5c08b267e8f2af3669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously returns the type of a service object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#af9287ea2a5c9ec5c08b267e8f2af3669">More...</a><br /></td></tr>
<tr class="separator:af9287ea2a5c9ec5c08b267e8f2af3669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1cbe435fd92fe82849fc77a8cc9f92"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3a1cbe435fd92fe82849fc77a8cc9f92">GetThreadPool</a> ()</td></tr>
<tr class="memdesc:a3a1cbe435fd92fe82849fc77a8cc9f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3a1cbe435fd92fe82849fc77a8cc9f92">More...</a><br /></td></tr>
<tr class="separator:a3a1cbe435fd92fe82849fc77a8cc9f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a2b3e2120198e12573bce3f819b727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac3a2b3e2120198e12573bce3f819b727">TryGetThreadPool</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool.html">ThreadPool</a> &gt; &amp;pool)</td></tr>
<tr class="memdesc:ac3a2b3e2120198e12573bce3f819b727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to get the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a>, returns false if the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> is not available.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac3a2b3e2120198e12573bce3f819b727">More...</a><br /></td></tr>
<tr class="separator:ac3a2b3e2120198e12573bce3f819b727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591e63518e7f0b77d5bd098934908a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3591e63518e7f0b77d5bd098934908a2">SetThreadPool</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool.html">ThreadPool</a> &gt; pool)</td></tr>
<tr class="memdesc:a3591e63518e7f0b77d5bd098934908a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3591e63518e7f0b77d5bd098934908a2">More...</a><br /></td></tr>
<tr class="separator:a3591e63518e7f0b77d5bd098934908a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e0634dc13045f599e3853c5386f9af"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html">ThreadPoolFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac1e0634dc13045f599e3853c5386f9af">GetThreadPoolFactory</a> ()</td></tr>
<tr class="memdesc:ac1e0634dc13045f599e3853c5386f9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> for the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac1e0634dc13045f599e3853c5386f9af">More...</a><br /></td></tr>
<tr class="separator:ac1e0634dc13045f599e3853c5386f9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771f99464b199a1c9b1ab855769c63f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a771f99464b199a1c9b1ab855769c63f6">SetThreadPoolFactory</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html">ThreadPoolFactory</a> &gt; factory)</td></tr>
<tr class="memdesc:a771f99464b199a1c9b1ab855769c63f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> for the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a771f99464b199a1c9b1ab855769c63f6">More...</a><br /></td></tr>
<tr class="separator:a771f99464b199a1c9b1ab855769c63f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba87d18ff28dd49212c2adeffb5b56"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3cba87d18ff28dd49212c2adeffb5b56">GetThreadPoolCount</a> ()</td></tr>
<tr class="memdesc:a3cba87d18ff28dd49212c2adeffb5b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads for the node <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3cba87d18ff28dd49212c2adeffb5b56">More...</a><br /></td></tr>
<tr class="separator:a3cba87d18ff28dd49212c2adeffb5b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac446b9e8f12ad138e996ae0b68cb4cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac446b9e8f12ad138e996ae0b68cb4cb7">SetThreadPoolCount</a> (int32_t count)</td></tr>
<tr class="memdesc:ac446b9e8f12ad138e996ae0b68cb4cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads for the node <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac446b9e8f12ad138e996ae0b68cb4cb7">More...</a><br /></td></tr>
<tr class="separator:ac446b9e8f12ad138e996ae0b68cb4cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc11b4d956bd826f310d98b1da4947f"><td class="memItemLeft" align="right" valign="top"><a id="a6fc11b4d956bd826f310d98b1da4947f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6fc11b4d956bd826f310d98b1da4947f">ReleaseThreadPool</a> ()</td></tr>
<tr class="memdesc:a6fc11b4d956bd826f310d98b1da4947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down and releases the node thred pool Do not call ReleaseThreadPool unless you really know what you are doing. In most cases it will be destroyed automatically. <br /></td></tr>
<tr class="separator:a6fc11b4d956bd826f310d98b1da4947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309d7f493693a2305390131a0b46aeec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a309d7f493693a2305390131a0b46aeec">GetPulledServiceTypes</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a309d7f493693a2305390131a0b46aeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of service types pulled by a client.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a309d7f493693a2305390131a0b46aeec">More...</a><br /></td></tr>
<tr class="separator:a309d7f493693a2305390131a0b46aeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ef9b51c9278a2765c772a731bb4887"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_factory.html">ServiceFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac4ef9b51c9278a2765c772a731bb4887">GetPulledServiceType</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj, boost::string_ref type)</td></tr>
<tr class="memdesc:ac4ef9b51c9278a2765c772a731bb4887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_robot_raconteur_1_1_service_factory.html" title="Base class for service factories.">ServiceFactory</a> created from a service type pulled by a client.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac4ef9b51c9278a2765c772a731bb4887">More...</a><br /></td></tr>
<tr class="separator:ac4ef9b51c9278a2765c772a731bb4887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ea4d70fe2d27b14346c34b22b2167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a374ea4d70fe2d27b14346c34b22b2167">SetExceptionHandler</a> (boost::function&lt; void(const std::exception *)&gt; handler)</td></tr>
<tr class="memdesc:a374ea4d70fe2d27b14346c34b22b2167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an exception handler function.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a374ea4d70fe2d27b14346c34b22b2167">More...</a><br /></td></tr>
<tr class="separator:a374ea4d70fe2d27b14346c34b22b2167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99aa666ca513e8c2a22f95c3640dc907"><td class="memItemLeft" align="right" valign="top">boost::function&lt; void(const std::exception *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a99aa666ca513e8c2a22f95c3640dc907">GetExceptionHandler</a> ()</td></tr>
<tr class="memdesc:a99aa666ca513e8c2a22f95c3640dc907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node's current exception handler, or null.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a99aa666ca513e8c2a22f95c3640dc907">More...</a><br /></td></tr>
<tr class="separator:a99aa666ca513e8c2a22f95c3640dc907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a1f42017d61835bf615deabd2659d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a805a1f42017d61835bf615deabd2659d">HandleException</a> (const std::exception *exp)</td></tr>
<tr class="memdesc:a805a1f42017d61835bf615deabd2659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle exceptino by passing the current exception to the handler function.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a805a1f42017d61835bf615deabd2659d">More...</a><br /></td></tr>
<tr class="separator:a805a1f42017d61835bf615deabd2659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae3d8577ba4e95dd2a7626d094923ca"><td class="memItemLeft" align="right" valign="top">virtual boost::posix_time::ptime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0ae3d8577ba4e95dd2a7626d094923ca">NowUTC</a> ()</td></tr>
<tr class="memdesc:a0ae3d8577ba4e95dd2a7626d094923ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current time in UTC time zone.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0ae3d8577ba4e95dd2a7626d094923ca">More...</a><br /></td></tr>
<tr class="separator:a0ae3d8577ba4e95dd2a7626d094923ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb437079a0be88a4ca78834d781b1492"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#abb437079a0be88a4ca78834d781b1492">NowTimeSpec</a> ()</td></tr>
<tr class="memdesc:abb437079a0be88a4ca78834d781b1492"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current node time as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#abb437079a0be88a4ca78834d781b1492">More...</a><br /></td></tr>
<tr class="separator:abb437079a0be88a4ca78834d781b1492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded9736b6e52cdecaefcac88bc7994b5"><td class="memItemLeft" align="right" valign="top">virtual boost::posix_time::ptime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aded9736b6e52cdecaefcac88bc7994b5">NowNodeTime</a> ()</td></tr>
<tr class="memdesc:aded9736b6e52cdecaefcac88bc7994b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current node time.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aded9736b6e52cdecaefcac88bc7994b5">More...</a><br /></td></tr>
<tr class="separator:aded9736b6e52cdecaefcac88bc7994b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d9e4722cbe9be1c05e30bd52f18134"><td class="memItemLeft" align="right" valign="top">virtual boost::posix_time::ptime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a96d9e4722cbe9be1c05e30bd52f18134">NodeSyncTimeUTC</a> ()</td></tr>
<tr class="memdesc:a96d9e4722cbe9be1c05e30bd52f18134"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sync time of the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a96d9e4722cbe9be1c05e30bd52f18134">More...</a><br /></td></tr>
<tr class="separator:a96d9e4722cbe9be1c05e30bd52f18134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e8e730b74dc3e97733a795d2e89c7e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a90e8e730b74dc3e97733a795d2e89c7e">NodeSyncTimeSpec</a> ()</td></tr>
<tr class="memdesc:a90e8e730b74dc3e97733a795d2e89c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sync time of the node as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a90e8e730b74dc3e97733a795d2e89c7e">More...</a><br /></td></tr>
<tr class="separator:a90e8e730b74dc3e97733a795d2e89c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479aed0cdfdb1d7b7b822f989687f078"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_timer.html">Timer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a479aed0cdfdb1d7b7b822f989687f078">CreateTimer</a> (const boost::posix_time::time_duration &amp;period, boost::function&lt; void(const <a class="el" href="struct_robot_raconteur_1_1_timer_event.html">TimerEvent</a> &amp;)&gt; handler, bool oneshot=false)</td></tr>
<tr class="memdesc:a479aed0cdfdb1d7b7b822f989687f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_robot_raconteur_1_1_timer.html" title="A timer to invoke a callback.">Timer</a> object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a479aed0cdfdb1d7b7b822f989687f078">More...</a><br /></td></tr>
<tr class="separator:a479aed0cdfdb1d7b7b822f989687f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e65d602fa9f202f79d2ecdf4d33235"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_rate.html">Rate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa0e65d602fa9f202f79d2ecdf4d33235">CreateRate</a> (double frequency)</td></tr>
<tr class="memdesc:aa0e65d602fa9f202f79d2ecdf4d33235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_robot_raconteur_1_1_rate.html" title="Rate to stabilize a loop.">Rate</a> object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa0e65d602fa9f202f79d2ecdf4d33235">More...</a><br /></td></tr>
<tr class="separator:aa0e65d602fa9f202f79d2ecdf4d33235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787bdba5f06a44c591595a7ba21cf6a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a787bdba5f06a44c591595a7ba21cf6a7">Sleep</a> (const boost::posix_time::time_duration &amp;duration)</td></tr>
<tr class="memdesc:a787bdba5f06a44c591595a7ba21cf6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps for a specified duration.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a787bdba5f06a44c591595a7ba21cf6a7">More...</a><br /></td></tr>
<tr class="separator:a787bdba5f06a44c591595a7ba21cf6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f55e2c6762e541b66a22a6d2e4ecbf"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_auto_reset_event.html">AutoResetEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a78f55e2c6762e541b66a22a6d2e4ecbf">CreateAutoResetEvent</a> ()</td></tr>
<tr class="memdesc:a78f55e2c6762e541b66a22a6d2e4ecbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_robot_raconteur_1_1_auto_reset_event.html" title="Synchronization event for thread synchronization. Resets automatically after being triggered.">AutoResetEvent</a> object.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a78f55e2c6762e541b66a22a6d2e4ecbf">More...</a><br /></td></tr>
<tr class="separator:a78f55e2c6762e541b66a22a6d2e4ecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29985b7e5c7970e7d431218340cb94c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a29985b7e5c7970e7d431218340cb94c9">DownCastAndThrowException</a> (<a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &amp;exp)</td></tr>
<tr class="memdesc:a29985b7e5c7970e7d431218340cb94c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcasts a <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a> and throws it.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a29985b7e5c7970e7d431218340cb94c9">More...</a><br /></td></tr>
<tr class="separator:a29985b7e5c7970e7d431218340cb94c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19cc6aee381e86a11ae20704b6ee857"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa19cc6aee381e86a11ae20704b6ee857">DownCastException</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt; exp)</td></tr>
<tr class="memdesc:aa19cc6aee381e86a11ae20704b6ee857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcasts a <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a>.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa19cc6aee381e86a11ae20704b6ee857">More...</a><br /></td></tr>
<tr class="separator:aa19cc6aee381e86a11ae20704b6ee857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed67033a2f45631dc9078045e0f8097"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4ed67033a2f45631dc9078045e0f8097">GetServicePath</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt; obj)</td></tr>
<tr class="memdesc:a4ed67033a2f45631dc9078045e0f8097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ServicePath of a client object reference obj must be returned by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a>, <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">AsyncConnectService()</a>, or an <code>objref</code>  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4ed67033a2f45631dc9078045e0f8097">More...</a><br /></td></tr>
<tr class="separator:a4ed67033a2f45631dc9078045e0f8097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8add3c8947edf91261eee6c897920a5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8add3c8947edf91261eee6c897920a5b">IsEndpointLargeTransferAuthorized</a> (uint32_t endpoint)</td></tr>
<tr class="memdesc:a8add3c8947edf91261eee6c897920a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint is authorized for large message transfer.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8add3c8947edf91261eee6c897920a5b">More...</a><br /></td></tr>
<tr class="separator:a8add3c8947edf91261eee6c897920a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f131f37ed85e52a98f0e5c74f81a7e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#af3f131f37ed85e52a98f0e5c74f81a7e">GetRobotRaconteurVersion</a> ()</td></tr>
<tr class="memdesc:af3f131f37ed85e52a98f0e5c74f81a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_version.html" title="Robot Raconteur Version storage class.">RobotRaconteurVersion</a> as a string.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#af3f131f37ed85e52a98f0e5c74f81a7e">More...</a><br /></td></tr>
<tr class="separator:af3f131f37ed85e52a98f0e5c74f81a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1a8ce8bde3c446cb521f2c8eb56233"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e1a8ce8bde3c446cb521f2c8eb56233"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9e1a8ce8bde3c446cb521f2c8eb56233">GetRandomInt</a> (T min, T max)</td></tr>
<tr class="memdesc:a9e1a8ce8bde3c446cb521f2c8eb56233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random integer using the node's random number generator.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9e1a8ce8bde3c446cb521f2c8eb56233">More...</a><br /></td></tr>
<tr class="separator:a9e1a8ce8bde3c446cb521f2c8eb56233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a052b43f1d98ca83405b059da5e9de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20a052b43f1d98ca83405b059da5e9de"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20a052b43f1d98ca83405b059da5e9de">GetRandomInts</a> (size_t count, T min, T max)</td></tr>
<tr class="memdesc:a20a052b43f1d98ca83405b059da5e9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of random integer using the node's random number generator.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20a052b43f1d98ca83405b059da5e9de">More...</a><br /></td></tr>
<tr class="separator:a20a052b43f1d98ca83405b059da5e9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49a6a8fefefa201ed3627c290e805ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#af49a6a8fefefa201ed3627c290e805ee">GetRandomString</a> (size_t count)</td></tr>
<tr class="memdesc:af49a6a8fefefa201ed3627c290e805ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random string with the specified character count using the node's random number generator.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#af49a6a8fefefa201ed3627c290e805ee">More...</a><br /></td></tr>
<tr class="separator:af49a6a8fefefa201ed3627c290e805ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef516cc8f4056a06dea648cff26d5aff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aef516cc8f4056a06dea648cff26d5aff">CompareLogLevel</a> (<a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a> log_level)</td></tr>
<tr class="memdesc:aef516cc8f4056a06dea648cff26d5aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the specified log level would be accepted.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aef516cc8f4056a06dea648cff26d5aff">More...</a><br /></td></tr>
<tr class="separator:aef516cc8f4056a06dea648cff26d5aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d97b13d2110d6d0f9573dedce1a048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a99d97b13d2110d6d0f9573dedce1a048">LogMessage</a> (<a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a> level, const std::string &amp;message)</td></tr>
<tr class="memdesc:a99d97b13d2110d6d0f9573dedce1a048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log a simple message using the current node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a99d97b13d2110d6d0f9573dedce1a048">More...</a><br /></td></tr>
<tr class="separator:a99d97b13d2110d6d0f9573dedce1a048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7521777a9bf735970c094e45735ccdef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a7521777a9bf735970c094e45735ccdef">LogRecord</a> (const <a class="el" href="class_robot_raconteur_1_1_r_r_log_record.html">RRLogRecord</a> &amp;record)</td></tr>
<tr class="memdesc:a7521777a9bf735970c094e45735ccdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log a record to the node. Use the macros specified in <a class="el" href="_logging_8h.html">Logging.h</a> instead of this function directly.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a7521777a9bf735970c094e45735ccdef">More...</a><br /></td></tr>
<tr class="separator:a7521777a9bf735970c094e45735ccdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e690ec314171a42ff064bbbe0909de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a98e690ec314171a42ff064bbbe0909de">GetLogLevel</a> ()</td></tr>
<tr class="memdesc:a98e690ec314171a42ff064bbbe0909de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current log level for the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a98e690ec314171a42ff064bbbe0909de">More...</a><br /></td></tr>
<tr class="separator:a98e690ec314171a42ff064bbbe0909de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd9bb2d6c8463dcc9e888e7b7391472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9bd9bb2d6c8463dcc9e888e7b7391472">SetLogLevel</a> (<a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a> level)</td></tr>
<tr class="memdesc:a9bd9bb2d6c8463dcc9e888e7b7391472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the log level for the node.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9bd9bb2d6c8463dcc9e888e7b7391472">More...</a><br /></td></tr>
<tr class="separator:a9bd9bb2d6c8463dcc9e888e7b7391472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345dda51aba49435c2082f4daa394de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a345dda51aba49435c2082f4daa394de0">SetLogLevelFromString</a> (boost::string_ref level)</td></tr>
<tr class="memdesc:a345dda51aba49435c2082f4daa394de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the log level for the node from a string.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a345dda51aba49435c2082f4daa394de0">More...</a><br /></td></tr>
<tr class="separator:a345dda51aba49435c2082f4daa394de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c34d302ad11cc9a72898a8ada87ce14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4c34d302ad11cc9a72898a8ada87ce14">SetLogLevelFromEnvVariable</a> (const std::string &amp;env_variable_name=&quot;ROBOTRACONTEUR_LOG_LEVEL&quot;)</td></tr>
<tr class="memdesc:a4c34d302ad11cc9a72898a8ada87ce14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the log level for the node from specified environmental variable.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4c34d302ad11cc9a72898a8ada87ce14">More...</a><br /></td></tr>
<tr class="separator:a4c34d302ad11cc9a72898a8ada87ce14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82516eb743186e09a7389f3e1b0088f9"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_log_record_handler.html">LogRecordHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a82516eb743186e09a7389f3e1b0088f9">GetLogRecordHandler</a> ()</td></tr>
<tr class="memdesc:a82516eb743186e09a7389f3e1b0088f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently configured log record handler.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a82516eb743186e09a7389f3e1b0088f9">More...</a><br /></td></tr>
<tr class="separator:a82516eb743186e09a7389f3e1b0088f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68ff720b5a49f7fe8af09cbb7826702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa68ff720b5a49f7fe8af09cbb7826702">SetLogRecordHandler</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_log_record_handler.html">LogRecordHandler</a> &gt; handler)</td></tr>
<tr class="memdesc:aa68ff720b5a49f7fe8af09cbb7826702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the handler for log records.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aa68ff720b5a49f7fe8af09cbb7826702">More...</a><br /></td></tr>
<tr class="separator:aa68ff720b5a49f7fe8af09cbb7826702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff7faebe554e1feb9804211dd44e7ca"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_message_tap.html">MessageTap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#acff7faebe554e1feb9804211dd44e7ca">GetMessageTap</a> ()</td></tr>
<tr class="memdesc:acff7faebe554e1feb9804211dd44e7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active message tap.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#acff7faebe554e1feb9804211dd44e7ca">More...</a><br /></td></tr>
<tr class="separator:acff7faebe554e1feb9804211dd44e7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8ca65366a184c7c025e40032a81f72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2d8ca65366a184c7c025e40032a81f72">SetMessageTap</a> (boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_message_tap.html">MessageTap</a> &gt; message_tap)</td></tr>
<tr class="memdesc:a2d8ca65366a184c7c025e40032a81f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the a message tap to record log records and messages.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2d8ca65366a184c7c025e40032a81f72">More...</a><br /></td></tr>
<tr class="separator:a2d8ca65366a184c7c025e40032a81f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2376f20076c4e0015d86f15948ff1b8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b">s</a> ()</td></tr>
<tr class="memdesc:a2376f20076c4e0015d86f15948ff1b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton accessor.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b">More...</a><br /></td></tr>
<tr class="separator:a2376f20076c4e0015d86f15948ff1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948364d2308bdb464413f1ec356cca1f"><td class="memItemLeft" align="right" valign="top">static boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f">sp</a> ()</td></tr>
<tr class="memdesc:a948364d2308bdb464413f1ec356cca1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton shared_ptr accessor.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f">More...</a><br /></td></tr>
<tr class="separator:a948364d2308bdb464413f1ec356cca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da0778099f48499324a76dbe098bb48"><td class="memItemLeft" align="right" valign="top">static RR_WEAK_PTR&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2da0778099f48499324a76dbe098bb48">weak_sp</a> ()</td></tr>
<tr class="memdesc:a2da0778099f48499324a76dbe098bb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton weak_ptr accessor.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2da0778099f48499324a76dbe098bb48">More...</a><br /></td></tr>
<tr class="separator:a2da0778099f48499324a76dbe098bb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba469ef8ecb119f0f99abcb754a98119"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aba469ef8ecb119f0f99abcb754a98119">SelectRemoteNodeURL</a> (const std::vector&lt; std::string &gt; &amp;urls)</td></tr>
<tr class="memdesc:aba469ef8ecb119f0f99abcb754a98119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the "best" URL from a std::vector of candidates.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#aba469ef8ecb119f0f99abcb754a98119">More...</a><br /></td></tr>
<tr class="separator:aba469ef8ecb119f0f99abcb754a98119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59668fcbb6c900e53f147c3e2cacd22"><td class="memTemplParams" colspan="2">template&lt;typename HandlerType &gt; </td></tr>
<tr class="memitem:ad59668fcbb6c900e53f147c3e2cacd22"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ad59668fcbb6c900e53f147c3e2cacd22">TryPostToThreadPool</a> (RR_WEAK_PTR&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> &gt; node, BOOST_ASIO_MOVE_ARG(HandlerType) h, bool shutdown_op=false)</td></tr>
<tr class="memdesc:ad59668fcbb6c900e53f147c3e2cacd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to post a handler function to be called by a thread in the thread pool. Returns immediately.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ad59668fcbb6c900e53f147c3e2cacd22">More...</a><br /></td></tr>
<tr class="separator:ad59668fcbb6c900e53f147c3e2cacd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128e4a5bada609ddaeb88232a937cdf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac128e4a5bada609ddaeb88232a937cdf">TryHandleException</a> (RR_WEAK_PTR&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> &gt; node, const std::exception *exp)</td></tr>
<tr class="memdesc:ac128e4a5bada609ddaeb88232a937cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to pass an exception to the exception handler.  <a href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac128e4a5bada609ddaeb88232a937cdf">More...</a><br /></td></tr>
<tr class="separator:ac128e4a5bada609ddaeb88232a937cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The central node implementation. </p>
<p><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html" title="The central node implementation.">RobotRaconteurNode</a> implements the current Robot Raconteur instance and acts as the central switchpoint for the instance. The user registers types, connects clients, registers services, and registers transports through this class.</p>
<p>If the current program only needs one instance of <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html" title="The central node implementation.">RobotRaconteurNode</a>, the singleton can be used. The singleton is accessed using:</p>
<p><code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b" title="Singleton accessor.">RobotRaconteurNode::s()</a></code></p>
<p>or</p>
<p><code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f" title="Singleton shared_ptr accessor.">RobotRaconteurNode::sp()</a></code></p>
<p>The node must be shut down before existing the program, or a memory leak/hard crash will occur. This can either be accomplished manually using the <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3fd1a28c207e9b2b5a5363394f355b7a" title="Shuts down the node. Called automatically by ClientNodeSetup and ServerNodeSetup.">Shutdown()</a></code> function, or automatically by using the <a class="el" href="class_robot_raconteur_1_1_client_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a client only node.">ClientNodeSetup</a> or <a class="el" href="class_robot_raconteur_1_1_server_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a server and client node.">ServerNodeSetup</a> classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a564eaed878fa2d978b1a4beaac05636f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564eaed878fa2d978b1a4beaac05636f">&#9670;&nbsp;</a></span>RobotRaconteurNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RobotRaconteur::RobotRaconteurNode::RobotRaconteurNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Robot Raconteur Node object. </p>
<p>Must be called using RR_MAKE_SHARED&lt;RobotRaconteurNode&gt;. Call <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9de5d50be75a77ba155e8ebf83987108" title="Initialize the node. Called automatically for s() and sp()">Init()</a></code> after construction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abdd314e7388872e6b1d3483731c95941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd314e7388872e6b1d3483731c95941">&#9670;&nbsp;</a></span>AddNodeDetectionLostListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a70b75427787625ce02f9d524a2134b78">node_lost_listener_connection</a> RobotRaconteur::RobotRaconteurNode::AddNodeDetectionLostListener </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(Handler)&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a handler to be called when a node is no longer detected. </p>
<p>Nodes are considered no longer detected when the cached detected node information expires, usually after one minute. The cache must constantly be refreshed with new detection information to prevent expiration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handler to call. Must have signature <code>void my_handler(const NodeDiscoveryInfo&amp;)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node_lost_listener_connection </dd></dl>

</div>
</div>
<a id="a261aaf116637c02a4160205692f27781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261aaf116637c02a4160205692f27781">&#9670;&nbsp;</a></span>AddNodeServicesDetectedListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a7015109cd5ef432d7c8474b31cddce9c">node_updated_listener_connection</a> RobotRaconteur::RobotRaconteurNode::AddNodeServicesDetectedListener </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(Handler)&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a handler to be called when detected services are updated. </p>
<p>The specified handler is called when the internal cache of available services is updated. The cache is only active when a subscription is in use, or is updated when FindServiceByType is called.</p>
<p>Subscriptions should be used instead of this function to detect and connect to services.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handler to call. Must have signature <code>void my_handler(const <a class="el" href="class_robot_raconteur_1_1_node_discovery_info.html" title="Raw information used to announce and detect nodes.">NodeDiscoveryInfo</a>&amp; node_info , const std::vector&lt;<a class="el" href="class_robot_raconteur_1_1_service_info2.html" title="Contains information about a service found using discovery.">ServiceInfo2</a>&gt;&amp; service_info)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node_updated_listener_connection boost::signals2 connection object </dd></dl>

</div>
</div>
<a id="a5f78b0932edf7f514939bf1049daf91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f78b0932edf7f514939bf1049daf91b">&#9670;&nbsp;</a></span>AddPeriodicCleanupTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AddPeriodicCleanupTask </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; IPeriodicCleanupTask &gt;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a periodic cleanup task. </p>
<p>The node will call periodic cleanup tasks every 5-15 seconds. Use these tasks instead of timers for cleanup operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to call periodically </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a077222702f03aa7c62521c532fe7e448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077222702f03aa7c62521c532fe7e448">&#9670;&nbsp;</a></span>AddShutdownListener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2a3bb5b109dd19f327c15a17d0d2df44">shutdown_listener_connection</a> RobotRaconteur::RobotRaconteurNode::AddShutdownListener </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(Handler)&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a shutdown listener. </p>
<p>Adds a listener handler function that will be called when the node is shutting down.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shutdown_listener_connection </dd></dl>

</div>
</div>
<a id="a5331e01f78fc91aee870738c9152c9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5331e01f78fc91aee870738c9152c9a2">&#9670;&nbsp;</a></span>AsyncConnectService() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncConnectService </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>credentials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously create a client connection to a remote service using a URL. </p>
<p>Same as ConnectService but returns asynchronously. See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a> for more details on client connections.</p>
<p>handler is called after the client connection succeeds are fails. On success, the <a class="el" href="class_robot_raconteur_1_1_r_r_object.html" title="Base class for all Robot Raconteur objects.">RRObject</a> is returned and the exception is null. On failure, the <a class="el" href="class_robot_raconteur_1_1_r_r_object.html" title="Base class for all Robot Raconteur objects.">RRObject</a> is null and the exception contains a subclass of <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL of the service to connect </td></tr>
    <tr><td class="paramname">username</td><td>An optional username for authentication </td></tr>
    <tr><td class="paramname">credentials</td><td>Optional credentials for authentication </td></tr>
    <tr><td class="paramname">listener</td><td>An optional listener callback function </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired root object proxy type. Optional but highly recommended. </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the object reference or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout is milliseconds, or RR_TIMEOUT_INFINITE for no timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a292cd7265408d8095fe16eb12844b45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292cd7265408d8095fe16eb12844b45f">&#9670;&nbsp;</a></span>AsyncConnectService() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncConnectService </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>credentials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">AsyncConnectService()</a>, but accepts a vector of candidate URLs. </p>
<p>Frequently during discovery, multiple candidate URLs will be discovered. This function will attempt each of the candidate URLs kind-of-the-hill style to find the best one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Vector of candidate URLs to attempt </td></tr>
    <tr><td class="paramname">username</td><td>An optional username for authentication </td></tr>
    <tr><td class="paramname">credentials</td><td>Optional credentials for authentication </td></tr>
    <tr><td class="paramname">listener</td><td>An optional listener callback function </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired root object proxy type. Optional but highly recommended. </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the object reference or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout is milliseconds, or RR_TIMEOUT_INFINITE for no timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55a7acc5b238233193a8cc53ac14985c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a7acc5b238233193a8cc53ac14985c">&#9670;&nbsp;</a></span>AsyncDisconnectService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncDisconnectService </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously disconnects a client connection to a service. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a51e5d8265fcc8b01caa9634966fcb496" title="Disconnects a client connection to a service.">DisconnectService()</a> but returns asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The root object of the client to disconnect </td></tr>
    <tr><td class="paramname">handler</td><td>The handler to call when complete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63105e3219469c78aad8569a65b5629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63105e3219469c78aad8569a65b5629e">&#9670;&nbsp;</a></span>AsyncFindNodeByID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindNodeByID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transportschemes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a> &gt; &gt;) &gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously finds nodes on the network with the specified <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6f71bf3c96ed4e9a3cd4f953190ef9be" title="Finds nodes on the network with a specified NodeID.">FindNodeByID()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> to find </td></tr>
    <tr><td class="paramname">transportschemes</td><td>A list of transport types to search, ie <code>rr+tcp</code>, <code>rr+local</code>, <code>rrs+tcp</code>, etc </td></tr>
    <tr><td class="paramname">handler</td><td>Handler to call on completion </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. Using a timeout greater than 5 seconds is not recommended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bfec4072b487cde383788633d47ac8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfec4072b487cde383788633d47ac8b">&#9670;&nbsp;</a></span>AsyncFindNodeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindNodeByName </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transportschemes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a> &gt; &gt;) &gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously finds nodes on the network with the specified NodeName. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a683a1c228cbfb70bcc08430f49e52a5a" title="Finds nodes on the network with a specified NodeName.">FindNodeByName()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The NodeName to find </td></tr>
    <tr><td class="paramname">transportschemes</td><td>A list of transport types to search, ie <code>rr+tcp</code>, <code>rr+local</code>, <code>rrs+tcp</code>, etc </td></tr>
    <tr><td class="paramname">handler</td><td>Handler to call on completion </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. Using a timeout greater than 5 seconds is not recommended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b63b166acd227a77273d64bb2d54029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b63b166acd227a77273d64bb2d54029">&#9670;&nbsp;</a></span>AsyncFindObjectType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindObjectType </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously returns the type of a service object. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c10bf7ed0082fd0395d7d5ad35cbbae" title="Returns the type of a service object.">FindObjectType()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the object type or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout is milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9287ea2a5c9ec5c08b267e8f2af3669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9287ea2a5c9ec5c08b267e8f2af3669">&#9670;&nbsp;</a></span>AsyncFindObjectType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindObjectType </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously returns the type of a service object. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c10bf7ed0082fd0395d7d5ad35cbbae" title="Returns the type of a service object.">FindObjectType()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">index</td><td>The index for the <code>objref</code>, convert int to string for int32 index type </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the object type or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout is milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d5f91f872899af241eceddcbefe3c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5f91f872899af241eceddcbefe3c6f">&#9670;&nbsp;</a></span>AsyncFindObjRefTyped() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindObjRefTyped </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously returns an objref as a specific type. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c10bf7ed0082fd0395d7d5ad35cbbae" title="Returns the type of a service object.">FindObjectType()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">index</td><td>The index for the <code>objref</code>, convert int to string for int32 index type </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired service object type </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the object reference or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33f1dd4a258f34fa0c0ee6ed9764e03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f1dd4a258f34fa0c0ee6ed9764e03c">&#9670;&nbsp;</a></span>AsyncFindObjRefTyped() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindObjRefTyped </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously returns an objref as a specific type. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5c10bf7ed0082fd0395d7d5ad35cbbae" title="Returns the type of a service object.">FindObjectType()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired service object type </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the object reference or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9adc2c77f3fcb7df3de563cb33a8d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9adc2c77f3fcb7df3de563cb33a8d36">&#9670;&nbsp;</a></span>AsyncFindServiceByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncFindServiceByType </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>servicetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transportschemes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::vector&lt; <a class="el" href="class_robot_raconteur_1_1_service_info2.html">ServiceInfo2</a> &gt; &gt;) &gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously use discovery to find availabe services by service type. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5e6a843097e6f17aee2b8660e58a3f48" title="Use discovery to find available services by service type.">FindServiceByType()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">servicetype</td><td>The service type to find, ie <code>com.robotraconteur.robotics.robot.Robot</code> </td></tr>
    <tr><td class="paramname">transportschemes</td><td>A list of transport types to search, ie <code>rr+tcp</code>, <code>rr+local</code>, <code>rrs+tcp</code>, etc </td></tr>
    <tr><td class="paramname">handler</td><td>Handler to call on completion </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. Using a timeout greater than 5 seconds is not recommended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a95071780ea9e0c8e5efb09c8bda0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95071780ea9e0c8e5efb09c8bda0e4">&#9670;&nbsp;</a></span>AsyncReleaseObjectLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncReleaseObjectLock </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously release an excluse access lock previously locked with <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RequestObjectLock()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a" title="Asynchronously request an exclusive access lock to a service object.">AsyncRequestObjectLock()</a> </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a52fb5b31209ac66cd1b7a51ab9e3c622" title="Release an excluse access lock previously locked with RequestObjectLock() or AsyncRequestObjectLock()">ReleaseObjectLock()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object previously locked </td></tr>
    <tr><td class="paramname">handler</td><td>Handler to call on completion </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1353a400015fe9d4e50ae35cff927b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1353a400015fe9d4e50ae35cff927b3a">&#9670;&nbsp;</a></span>AsyncRequestObjectLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncRequestObjectLock </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_robot_raconteur_node_8h.html#acd5d4086935257f7b0aaac15cf805a58">RobotRaconteurObjectLockFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; std::string &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously request an exclusive access lock to a service object. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RequestObjectLock()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to lock. Must be returned by ConnectService or returned by an <code>objref</code> </td></tr>
    <tr><td class="paramname">flags</td><td>Select either a "User" or "Session" lock </td></tr>
    <tr><td class="paramname">handler</td><td>Handler to call on completion </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d7ae332a0c67fea7f74463ed405a3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7ae332a0c67fea7f74463ed405a3a7">&#9670;&nbsp;</a></span>AsyncUpdateDetectedNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::AsyncUpdateDetectedNodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>schemes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously update the detected nodes cache. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b5c9142ccb18ad1f55937c9d63ce743" title="Update the detected nodes cache.">UpdateDetectedNodes()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemes</td><td>A vector of transport schemes, ie "rr+tcp", "rr+local", etc. to update. </td></tr>
    <tr><td class="paramname">handler</td><td>The handler to call on completion </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout for the operation in milliseconds. This function will often run for the full timeout, so values less than 5 seconds are recommended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2caa229cf64b5fa4545cb1c64ebd07d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caa229cf64b5fa4545cb1c64ebd07d3">&#9670;&nbsp;</a></span>CheckConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::CheckConnection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the TransportConnection associated with an endpoint is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>The LocalEndpoint identifier to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8394d64e879ff871aa7d74284d082e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8394d64e879ff871aa7d74284d082e46">&#9670;&nbsp;</a></span>CloseService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::CloseService </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>sname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a previously registered service. </p>
<p>Services are automatically closed by Shutdown, so this function is rarely used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sname</td><td>The name of the service to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef516cc8f4056a06dea648cff26d5aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef516cc8f4056a06dea648cff26d5aff">&#9670;&nbsp;</a></span>CompareLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::RobotRaconteurNode::CompareLogLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a>&#160;</td>
          <td class="paramname"><em>log_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the specified log level would be accepted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_level</td><td>Log level to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The log would be accepted </dd>
<dd>
false The log would be ignored </dd></dl>

</div>
</div>
<a id="a1b207bb3fe03ffa925fbe0c63dcac417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b207bb3fe03ffa925fbe0c63dcac417">&#9670;&nbsp;</a></span>ConnectService() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a>&gt; RobotRaconteur::RobotRaconteurNode::ConnectService </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>username</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>credentials</em> = <code>(boost::intrusive_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt;&#160;std::string,&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a>&#160;&gt;&#160;&gt;())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt;&#160;</td>
          <td class="paramname"><em>listener</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a client connection to a remote service using a URL. </p>
<p>Synchronously creates a connection to a remote service using a URL. URLs are either provided by the service, or are determined using discovery functions such as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5e6a843097e6f17aee2b8660e58a3f48" title="Use discovery to find available services by service type.">FindServiceByType()</a>. This function is the primary way to create client connections.</p>
<p>username and credentials can be used to specify authentication information. Credentials will often contain a "password" or token entry.</p>
<p>The listener is a function that is called during various events. See ClientServiceListenerEventType for a description of the possible events.</p>
<p>ConnectService will attempt to instantiate a client object reference (proxy) based on the type information provided by the service. The type information will contain the type of the object, and all the implemented types. The client will normally want a specific one of the implement types. Specify this desired type in objecttype to avoid future compatibility issues.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL of the service to connect </td></tr>
    <tr><td class="paramname">username</td><td>An optional username for authentication </td></tr>
    <tr><td class="paramname">credentials</td><td>Optional credentials for authentication </td></tr>
    <tr><td class="paramname">listener</td><td>An optional listener callback function </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired root object proxy type. Optional but highly recommended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;RRObject&gt; The client object reference (proxy). Must be cast to expected type. </dd></dl>

</div>
</div>
<a id="ac39572d25f9369f56545e4c6768e7d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39572d25f9369f56545e4c6768e7d1e">&#9670;&nbsp;</a></span>ConnectService() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a>&gt; RobotRaconteur::RobotRaconteurNode::ConnectService </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>urls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>username</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>credentials</em> = <code>(boost::intrusive_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt;&#160;std::string,&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a>&#160;&gt;&#160;&gt;())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; ClientContext &gt;, <a class="el" href="_robot_raconteur_constants_8h.html#a049c1e9d05e8fcb56990ebc4bf92e704">ClientServiceListenerEventType</a>, boost::shared_ptr&lt; void &gt;)&gt;&#160;</td>
          <td class="paramname"><em>listener</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a>, but accepts a vector of candidate URLs. </p>
<p>Frequently during discovery, multiple candidate URLs will be discovered. This function will attempt each of the candidate URLs kind-of-the-hill style to find the best one.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urls</td><td>Vector of candidate URLs to attempt </td></tr>
    <tr><td class="paramname">username</td><td>An optional username for authentication </td></tr>
    <tr><td class="paramname">credentials</td><td>Optional credentials for authentication </td></tr>
    <tr><td class="paramname">listener</td><td>An optional listener callback function </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired root object proxy type. Optional but highly recommended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;RRObject&gt; The client object reference (proxy). Must be cast to expected type. </dd></dl>

</div>
</div>
<a id="a78f55e2c6762e541b66a22a6d2e4ecbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f55e2c6762e541b66a22a6d2e4ecbf">&#9670;&nbsp;</a></span>CreateAutoResetEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_auto_reset_event.html">AutoResetEvent</a>&gt; RobotRaconteur::RobotRaconteurNode::CreateAutoResetEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_robot_raconteur_1_1_auto_reset_event.html" title="Synchronization event for thread synchronization. Resets automatically after being triggered.">AutoResetEvent</a> object. </p>
<p>Normally the <a class="el" href="class_robot_raconteur_1_1_auto_reset_event.html" title="Synchronization event for thread synchronization. Resets automatically after being triggered.">AutoResetEvent</a> will use the system clock for timeouts, but in certain circumstances will use simulation time</p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;AutoResetEvent&gt; The new <a class="el" href="class_robot_raconteur_1_1_auto_reset_event.html" title="Synchronization event for thread synchronization. Resets automatically after being triggered.">AutoResetEvent</a> object </dd></dl>

</div>
</div>
<a id="aa0e65d602fa9f202f79d2ecdf4d33235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e65d602fa9f202f79d2ecdf4d33235">&#9670;&nbsp;</a></span>CreateRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_rate.html">Rate</a>&gt; RobotRaconteur::RobotRaconteurNode::CreateRate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_robot_raconteur_1_1_rate.html" title="Rate to stabilize a loop.">Rate</a> object. </p>
<p><a class="el" href="class_robot_raconteur_1_1_rate.html" title="Rate to stabilize a loop.">Rate</a> is used to stabilize periodic loops to a specified frequency</p>
<p>This function will normally return a WallRate instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>Frequency of loop in Hz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;Rate&gt; The new <a class="el" href="class_robot_raconteur_1_1_rate.html" title="Rate to stabilize a loop.">Rate</a> object </dd></dl>

</div>
</div>
<a id="a479aed0cdfdb1d7b7b822f989687f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479aed0cdfdb1d7b7b822f989687f078">&#9670;&nbsp;</a></span>CreateTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_timer.html">Timer</a>&gt; RobotRaconteur::RobotRaconteurNode::CreateTimer </td>
          <td>(</td>
          <td class="paramtype">const boost::posix_time::time_duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(const <a class="el" href="struct_robot_raconteur_1_1_timer_event.html">TimerEvent</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneshot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_robot_raconteur_1_1_timer.html" title="A timer to invoke a callback.">Timer</a> object. </p>
<p>This function will normally return a WallTimer instance</p>
<p>Start() must be called after timer creation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The period of the timer </td></tr>
    <tr><td class="paramname">handler</td><td>The handler function to call when timer times out </td></tr>
    <tr><td class="paramname">oneshot</td><td>True if timer is a one-shot timer, false for repeated timer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;Timer&gt; The new <a class="el" href="class_robot_raconteur_1_1_timer.html" title="A timer to invoke a callback.">Timer</a> object. Must call Start() </dd></dl>

</div>
</div>
<a id="a51e5d8265fcc8b01caa9634966fcb496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e5d8265fcc8b01caa9634966fcb496">&#9670;&nbsp;</a></span>DisconnectService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::DisconnectService </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects a client connection to a service. </p>
<p>Synchronously disconnects a client connection. Client connections are automatically closed by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3fd1a28c207e9b2b5a5363394f355b7a" title="Shuts down the node. Called automatically by ClientNodeSetup and ServerNodeSetup.">Shutdown()</a>, so this function is optional.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The root object of the service to disconnect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29985b7e5c7970e7d431218340cb94c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29985b7e5c7970e7d431218340cb94c9">&#9670;&nbsp;</a></span>DownCastAndThrowException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::DownCastAndThrowException </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &amp;&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downcasts a <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a> and throws it. </p>
<p>Serialized <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a> may not be correctly downcast when deserialized. DownCastAndThrowException will find the correct type, downcast the exception, and throw the correctly typed exception</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>The <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a> to downcast and throw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa19cc6aee381e86a11ae20704b6ee857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19cc6aee381e86a11ae20704b6ee857">&#9670;&nbsp;</a></span>DownCastException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a>&gt; RobotRaconteur::RobotRaconteurNode::DownCastException </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downcasts a <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a>. </p>
<p>Serialized <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a> may not be correctly downcast when deserialized. DownCastException will find the correct type, downcast the exception, and return the correctly typed exception</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>The <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html" title="Base class for Robot Raconteur exceptions.">RobotRaconteurException</a> to downcast </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f71bf3c96ed4e9a3cd4f953190ef9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f71bf3c96ed4e9a3cd4f953190ef9be">&#9670;&nbsp;</a></span>FindNodeByID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a>&gt; RobotRaconteur::RobotRaconteurNode::FindNodeByID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transportschemes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds nodes on the network with a specified <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. </p>
<p>Updates the discovery cache and find nodes with the specified <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. This function returns unverified cache information.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> to find </td></tr>
    <tr><td class="paramname">transportschemes</td><td>A list of transport types to search, ie <code>rr+tcp</code>, <code>rr+local</code>, <code>rrs+tcp</code>, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;NodeInfo2&gt; </dd></dl>

</div>
</div>
<a id="a683a1c228cbfb70bcc08430f49e52a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683a1c228cbfb70bcc08430f49e52a5a">&#9670;&nbsp;</a></span>FindNodeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_robot_raconteur_1_1_node_info2.html">NodeInfo2</a>&gt; RobotRaconteur::RobotRaconteurNode::FindNodeByName </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transportschemes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds nodes on the network with a specified NodeName. </p>
<p>Updates the discovery cache and find nodes with the specified NodeName. This function returns unverified cache information.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The NodeName to find </td></tr>
    <tr><td class="paramname">transportschemes</td><td>A list of transport types to search, ie <code>rr+tcp</code>, <code>rr+local</code>, <code>rrs+tcp</code>, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;NodeInfo2&gt; </dd></dl>

</div>
</div>
<a id="a5c10bf7ed0082fd0395d7d5ad35cbbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c10bf7ed0082fd0395d7d5ad35cbbae">&#9670;&nbsp;</a></span>FindObjectType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::FindObjectType </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of a service object. </p>
<p>Returns the fully qualified object type that would be returned by an <code>objref</code> member</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The fully qaulified object type </dd></dl>

</div>
</div>
<a id="a23bf08c7dd8f01858675db558b5f4336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bf08c7dd8f01858675db558b5f4336">&#9670;&nbsp;</a></span>FindObjectType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::FindObjectType </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of a service object. </p>
<p>Returns the fully qualified object type that would be returned by an indexed <code>objref</code> member</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">index</td><td>The index for the <code>objref</code>, convert int to string for int32 index type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The fully qaulified object type </dd></dl>

</div>
</div>
<a id="a8835d6ca099f6726a17ae6da36d21af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8835d6ca099f6726a17ae6da36d21af3">&#9670;&nbsp;</a></span>FindObjRefTyped() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a>&gt; RobotRaconteur::RobotRaconteurNode::FindObjRefTyped </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an indexed objref as a specified type. </p>
<p>Same as FindObjectTyped() but includes an <code>objref</code> index</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">index</td><td>The index for the <code>objref</code>, convert int to string for int32 index type </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired service object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;RRObject&gt; The object with the specified interface type. Must be cast to the desired type </dd></dl>

</div>
</div>
<a id="adbef3676c1fb9f6f1201a14b3f3b39c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbef3676c1fb9f6f1201a14b3f3b39c5">&#9670;&nbsp;</a></span>FindObjRefTyped() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a>&gt; RobotRaconteur::RobotRaconteurNode::FindObjRefTyped </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an objref as a specific type. </p>
<p>Robot Raconteur service object types are polymorphic using inheritence, meaning that an object may be represented using multiple object types. <code>objref</code> will attempt to return the relevant type, but it is sometimes necessary to request a specific type for an objref.</p>
<p>This function will return the object from an <code>objref</code> as the specified type, or throw an error if the type is invalid.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object with the desired <code>objref</code> </td></tr>
    <tr><td class="paramname">objref</td><td>The name of the <code>objref</code> member </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired service object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;RRObject&gt; The object with the specified interface type. Must be cast to the desired type </dd></dl>

</div>
</div>
<a id="a5e6a843097e6f17aee2b8660e58a3f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6a843097e6f17aee2b8660e58a3f48">&#9670;&nbsp;</a></span>FindServiceByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_robot_raconteur_1_1_service_info2.html">ServiceInfo2</a>&gt; RobotRaconteur::RobotRaconteurNode::FindServiceByType </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>servicetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transportschemes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use discovery to find available services by service type. </p>
<p>Uses discovery to find available services based on a service type. This service type is the type of the root object, ie <code>com.robotraconteur.robotics.robot.Robot</code>. This process will update the detected node cache.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">servicetype</td><td>The service type to find, ie <code>com.robotraconteur.robotics.robot.Robot</code> </td></tr>
    <tr><td class="paramname">transportschemes</td><td>A list of transport types to search, ie <code>rr+tcp</code>, <code>rr+local</code>, <code>rrs+tcp</code>, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;ServiceInfo2&gt; The detected services </dd></dl>

</div>
</div>
<a id="ac002d45651eccda8dd8ce0af2d953f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac002d45651eccda8dd8ce0af2d953f09">&#9670;&nbsp;</a></span>GetDetectedNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_robot_raconteur_1_1_node_discovery_info.html">NodeDiscoveryInfo</a>&gt; RobotRaconteur::RobotRaconteurNode::GetDetectedNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes currently detected by Transports. </p>
<p>Transports configured to listen for node discovery send detected node information to the parent node, where it is stored. Normally this information will expire after one minute, and needs to be constantly refreshed.</p>
<p>This node information is not verified. It is the raw discovery information received by the transports. Verification is done when the node is interrogated for service information.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;NodeDiscoveryInfo&gt; </dd></dl>

</div>
</div>
<a id="a109089b84d2ff5057c81752e997bcd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109089b84d2ff5057c81752e997bcd74">&#9670;&nbsp;</a></span>GetDynamicServiceFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html">RobotRaconteur::DynamicServiceFactory</a>&gt; RobotRaconteur::RobotRaconteurNode::GetDynamicServiceFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html" title="Dynamic service factory base class.">DynamicServiceFactory</a>. May be null. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5d0b2c4e6bb149334a476e210b38bbc2" title="Set the DynamicServicefactory.">SetDynamicServiceFactory()</a></p>
<dl class="section return"><dt>Returns</dt><dd>const RR_SHARED_PTR&lt;RobotRaconteur::DynamicServiceFactory&gt; </dd></dl>

</div>
</div>
<a id="a1d6d3fa0284f0e644ef0eb6744717c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6d3fa0284f0e644ef0eb6744717c83">&#9670;&nbsp;</a></span>GetEndpointInactivityTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RobotRaconteur::RobotRaconteurNode::GetEndpointInactivityTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the timeout for endpoint activity in milliseconds. </p>
<p>Sets a timeout for endpoint inactivity. If no message is sent or received by the endpoint for the specified time, the endpoint is closed. Default timeout is 10 minutes.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Timeout in milliseconds </dd></dl>

</div>
</div>
<a id="a99aa666ca513e8c2a22f95c3640dc907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99aa666ca513e8c2a22f95c3640dc907">&#9670;&nbsp;</a></span>GetExceptionHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void (const std::exception*)&gt; RobotRaconteur::RobotRaconteurNode::GetExceptionHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node's current exception handler, or null. </p>
<p>Returns the exception handler previously set using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a374ea4d70fe2d27b14346c34b22b2167" title="Set an exception handler function.">SetExceptionHandler()</a></p>
<dl class="section return"><dt>Returns</dt><dd>boost::function&lt;void (const std::exception*)&gt; The current exception handler, or null </dd></dl>

</div>
</div>
<a id="a98e690ec314171a42ff064bbbe0909de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e690ec314171a42ff064bbbe0909de">&#9670;&nbsp;</a></span>GetLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a> RobotRaconteur::RobotRaconteurNode::GetLogLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current log level for the node. </p>
<p>Default level is "info"</p>
<dl class="section return"><dt>Returns</dt><dd>RobotRaconteur_LogLevel </dd></dl>

</div>
</div>
<a id="a82516eb743186e09a7389f3e1b0088f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82516eb743186e09a7389f3e1b0088f9">&#9670;&nbsp;</a></span>GetLogRecordHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_log_record_handler.html">LogRecordHandler</a>&gt; RobotRaconteur::RobotRaconteurNode::GetLogRecordHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently configured log record handler. </p>
<p>If NULL, records are sent to std::cerr</p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;LogRecordHandler&gt; </dd></dl>

</div>
</div>
<a id="ac49aaf2196acab71f7d37c9ce4fdc3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49aaf2196acab71f7d37c9ce4fdc3c4">&#9670;&nbsp;</a></span>GetMemoryMaxTransferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RobotRaconteur::RobotRaconteurNode::GetMemoryMaxTransferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum chunk size for memory transfers in bytes. </p>
<p><code>memory</code> members break up large transfers into chunks to avoid sending messages larger than the transport maximum, which is normally approximately 10 MB. The memory max transfer size is the largest data chunk the memory will send, in bytes. Default is 100 kB.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The max memory transfer size in bytes </dd></dl>

</div>
</div>
<a id="acff7faebe554e1feb9804211dd44e7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff7faebe554e1feb9804211dd44e7ca">&#9670;&nbsp;</a></span>GetMessageTap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_message_tap.html">MessageTap</a>&gt; RobotRaconteur::RobotRaconteurNode::GetMessageTap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active message tap. </p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;MessageTap&gt; </dd></dl>

</div>
</div>
<a id="a0a067c797b846fdabc381afa23a6d973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a067c797b846fdabc381afa23a6d973">&#9670;&nbsp;</a></span>GetNodeDiscoveryMaxCacheCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RobotRaconteur::RobotRaconteurNode::GetNodeDiscoveryMaxCacheCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of detected nodes that will be cached. </p>
<p>The node keeps a cache of detected nodes. The NodeDiscoveryMaxCacheCount sets an upper limit to how many detected nodes are cached. By default set to 4096</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t </dd></dl>

</div>
</div>
<a id="ab4f4273f0f0de7cf5ea3e87352a1a5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f4273f0f0de7cf5ea3e87352a1a5ff">&#9670;&nbsp;</a></span>GetObjectServicePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::GetObjectServicePath </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the service path of a client object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to get the service path for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The object's service path </dd></dl>

</div>
</div>
<a id="ac4ef9b51c9278a2765c772a731bb4887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ef9b51c9278a2765c772a731bb4887">&#9670;&nbsp;</a></span>GetPulledServiceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_service_factory.html">ServiceFactory</a>&gt; RobotRaconteur::RobotRaconteurNode::GetPulledServiceType </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_robot_raconteur_1_1_service_factory.html" title="Base class for service factories.">ServiceFactory</a> created from a service type pulled by a client. </p>
<p>Clients pull service definitions from services and create instances of <a class="el" href="class_robot_raconteur_1_1_service_factory.html" title="Base class for service factories.">ServiceFactory</a> if a <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html" title="Dynamic service factory base class.">DynamicServiceFactory</a> has been configured. <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac4ef9b51c9278a2765c772a731bb4887" title="Get a ServiceFactory created from a service type pulled by a client.">GetPulledServiceType()</a> returns a generated <a class="el" href="class_robot_raconteur_1_1_service_factory.html" title="Base class for service factories.">ServiceFactory</a>. Use <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a309d7f493693a2305390131a0b46aeec" title="Get the names of service types pulled by a client.">GetPulledServiceTypes()</a> to return a list of available service types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Client object referenece returned by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">AsyncConnectService()</a> </td></tr>
    <tr><td class="paramname">type</td><td>The name of the service type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServiceFactory&gt; The pulled service factory </dd></dl>

</div>
</div>
<a id="a309d7f493693a2305390131a0b46aeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309d7f493693a2305390131a0b46aeec">&#9670;&nbsp;</a></span>GetPulledServiceTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; RobotRaconteur::RobotRaconteurNode::GetPulledServiceTypes </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of service types pulled by a client. </p>
<p>Clients pull service definitions from services and create instances of <a class="el" href="class_robot_raconteur_1_1_service_factory.html" title="Base class for service factories.">ServiceFactory</a> if a <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html" title="Dynamic service factory base class.">DynamicServiceFactory</a> has been configured. GetPulledServiceTypes returns a list of the names of these pulled service types. Use <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac4ef9b51c9278a2765c772a731bb4887" title="Get a ServiceFactory created from a service type pulled by a client.">GetPulledServiceType()</a> to retrieve the <a class="el" href="class_robot_raconteur_1_1_service_factory.html" title="Base class for service factories.">ServiceFactory</a> for a specific type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Client object referenece returned by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">AsyncConnectService()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; The names of the pulled service types </dd></dl>

</div>
</div>
<a id="a9e1a8ce8bde3c446cb521f2c8eb56233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1a8ce8bde3c446cb521f2c8eb56233">&#9670;&nbsp;</a></span>GetRandomInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T RobotRaconteur::RobotRaconteurNode::GetRandomInt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random integer using the node's random number generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integer type, ie int32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum value for the returned integer </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value for the returned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The generated random integer </dd></dl>

</div>
</div>
<a id="a20a052b43f1d98ca83405b059da5e9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a052b43f1d98ca83405b059da5e9de">&#9670;&nbsp;</a></span>GetRandomInts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; RobotRaconteur::RobotRaconteurNode::GetRandomInts </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of random integer using the node's random number generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integer type, ie int32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of random integers to generate </td></tr>
    <tr><td class="paramname">min</td><td>The minimum value for the returned integers </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value for the returned integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; The generated random integer vector </dd></dl>

</div>
</div>
<a id="af49a6a8fefefa201ed3627c290e805ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49a6a8fefefa201ed3627c290e805ee">&#9670;&nbsp;</a></span>GetRandomString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::GetRandomString </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random string with the specified character count using the node's random number generator. </p>
<p>The returned string will consist of letters and numbers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The random string </dd></dl>

</div>
</div>
<a id="aa6d2024c8688f488b5749ff627b9a834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d2024c8688f488b5749ff627b9a834">&#9670;&nbsp;</a></span>GetRegisteredServiceNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; RobotRaconteur::RobotRaconteurNode::GetRegisteredServiceNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of registered services. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; The registered service names </dd></dl>

</div>
</div>
<a id="a8359f231c043cfce989d11f216bc3c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8359f231c043cfce989d11f216bc3c0d">&#9670;&nbsp;</a></span>GetRegisteredServiceTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; RobotRaconteur::RobotRaconteurNode::GetRegisteredServiceTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return names of registered service types. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; </dd></dl>

</div>
</div>
<a id="ac5f4ed2c1b2cd3362a3e34b403cb909a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f4ed2c1b2cd3362a3e34b403cb909a">&#9670;&nbsp;</a></span>GetRequestTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RobotRaconteur::RobotRaconteurNode::GetRequestTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the timeout for requests in milliseconds. </p>
<p>Requests are calls to a remote node that expect a response. <code>function</code>, <code>property</code>, <code>callback</code>, <code>memory</code>, and setup calls in <code>pipe</code> and <code>wire</code> are all requests. All other Robot Raconteur functions that call the remote node and expect a response are requests. Default timeout is 15 seconds.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Timeout in milliseconds </dd></dl>

</div>
</div>
<a id="af3f131f37ed85e52a98f0e5c74f81a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f131f37ed85e52a98f0e5c74f81a7e">&#9670;&nbsp;</a></span>GetRobotRaconteurVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::GetRobotRaconteurVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_version.html" title="Robot Raconteur Version storage class.">RobotRaconteurVersion</a> as a string. </p>
<p>Version is three numbers separated by dots, ie "0.9.2"</p>
<dl class="section return"><dt>Returns</dt><dd>std::string The current version </dd></dl>

</div>
</div>
<a id="abb514353f6a8f72a59b797a8698463f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb514353f6a8f72a59b797a8698463f3">&#9670;&nbsp;</a></span>GetService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a>&gt; RobotRaconteur::RobotRaconteurNode::GetService </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a> for a service by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the service </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServerContext&gt; The <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a> for a registered service </dd></dl>

</div>
</div>
<a id="a8176cac5031ac966d092ddc5390ee5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8176cac5031ac966d092ddc5390ee5eb">&#9670;&nbsp;</a></span>GetServiceAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, boost::intrusive_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a>&gt; &gt; RobotRaconteur::RobotRaconteurNode::GetServiceAttributes </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the service attributes of a client connection. </p>
<p>Returns the service attributes of a client connected using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The root object of the client to use to retrieve service attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;std::string, RR_INTRUSIVE_PTR&lt;RRValue&gt; &gt; The service attributes </dd></dl>

</div>
</div>
<a id="a3b6b9afc0a6cbc7d27877c22ba143b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6b9afc0a6cbc7d27877c22ba143b01">&#9670;&nbsp;</a></span>GetServiceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::GetServiceName </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a service from a client connection. </p>
<p>Returns the service name of the remote service that a client is connected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The root object of the client to use to retrieve service attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The service name </dd></dl>

</div>
</div>
<a id="a175883840bd94f8ddfa0c5521793f1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175883840bd94f8ddfa0c5521793f1d6">&#9670;&nbsp;</a></span>GetServiceNodeID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> RobotRaconteur::RobotRaconteurNode::GetServiceNodeID </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the service <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> of the remote node from a client connection. </p>
<p>Returns the <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> of the remote node that a client is connected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The root object of the client to use to retrieve service attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> The <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> </dd></dl>

</div>
</div>
<a id="a2bd28e485bfb087578b06c296630b7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd28e485bfb087578b06c296630b7cd">&#9670;&nbsp;</a></span>GetServiceNodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::GetServiceNodeName </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the service NodeName of the remote node from a client connection. </p>
<p>Returns the NodeName of the remote node that a client is connected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The root object of the client to use to retrieve service attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The NodeName </dd></dl>

</div>
</div>
<a id="a4ed67033a2f45631dc9078045e0f8097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed67033a2f45631dc9078045e0f8097">&#9670;&nbsp;</a></span>GetServicePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string RobotRaconteur::RobotRaconteurNode::GetServicePath </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ServicePath of a client object reference obj must be returned by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">ConnectService()</a>, <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">AsyncConnectService()</a>, or an <code>objref</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The servicepath of the object </dd></dl>

</div>
</div>
<a id="abbf5a2f28e1ce280f60fef3f889ea7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf5a2f28e1ce280f60fef3f889ea7de">&#9670;&nbsp;</a></span>GetServiceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_service_factory.html">ServiceFactory</a>&gt; RobotRaconteur::RobotRaconteurNode::GetServiceType </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previously registered service type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The name of the service type to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServiceFactory&gt; </dd></dl>

</div>
</div>
<a id="a3a1cbe435fd92fe82849fc77a8cc9f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1cbe435fd92fe82849fc77a8cc9f92">&#9670;&nbsp;</a></span>GetThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_thread_pool.html">ThreadPool</a>&gt; RobotRaconteur::RobotRaconteurNode::GetThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node. </p>
<p>Returns the current <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> in use by the node. If no <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> has been configured, a <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> is created using the <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a>. By default a <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> is created with 20 threads</p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ThreadPool&gt; The current thread pool </dd></dl>

</div>
</div>
<a id="a3cba87d18ff28dd49212c2adeffb5b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba87d18ff28dd49212c2adeffb5b56">&#9670;&nbsp;</a></span>GetThreadPoolCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t RobotRaconteur::RobotRaconteurNode::GetThreadPoolCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of threads for the node <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>int32_t </dd></dl>

</div>
</div>
<a id="ac1e0634dc13045f599e3853c5386f9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e0634dc13045f599e3853c5386f9af">&#9670;&nbsp;</a></span>GetThreadPoolFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html">ThreadPoolFactory</a>&gt; RobotRaconteur::RobotRaconteurNode::GetThreadPoolFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> for the node. </p>
<p><a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> is used to create a <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node if one is not already set. By default uses <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a></p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ThreadPoolFactory&gt; </dd></dl>

</div>
</div>
<a id="a1ba2c3826df32cf422541e8c1d543c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba2c3826df32cf422541e8c1d543c44">&#9670;&nbsp;</a></span>GetTransportInactivityTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RobotRaconteur::RobotRaconteurNode::GetTransportInactivityTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the timeout for transport activity in milliseconds. </p>
<p>Sets a timeout for transport inactivity. If no message is sent or received on the transport for the specified time, the transport is closed. Default timeout is 10 minutes.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Timeout in milliseconds </dd></dl>

</div>
</div>
<a id="a805a1f42017d61835bf615deabd2659d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a1f42017d61835bf615deabd2659d">&#9670;&nbsp;</a></span>HandleException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::HandleException </td>
          <td>(</td>
          <td class="paramtype">const std::exception *&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle exceptino by passing the current exception to the handler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>The exception to pass to the handler function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9de5d50be75a77ba155e8ebf83987108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de5d50be75a77ba155e8ebf83987108">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the node. Called automatically for <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b" title="Singleton accessor.">s()</a></code> and <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f" title="Singleton shared_ptr accessor.">sp()</a></code> </p>
<p>This function must be called to initialize background tasks before using the node. It is called automatically by the <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b" title="Singleton accessor.">s()</a></code> and <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f" title="Singleton shared_ptr accessor.">sp()</a></code> singleton accesors, so the user only needs to call this function when not using the singleton. If a custom thread pool is being used, the thread pool factory must be specified before calling init. </p>

</div>
</div>
<a id="a8add3c8947edf91261eee6c897920a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8add3c8947edf91261eee6c897920a5b">&#9670;&nbsp;</a></span>IsEndpointLargeTransferAuthorized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::RobotRaconteurNode::IsEndpointLargeTransferAuthorized </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the endpoint is authorized for large message transfer. </p>
<p>Saturating a transport with large messages to cause memory exhaustion is a potential attack vector for unauthorized clients. Limit transfers by unauthorized clients to small messages to prevent this</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>The LocalEndpoint id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Large transfer authorized </dd>
<dd>
false Large transfer is not authorized </dd></dl>

</div>
</div>
<a id="a942f178a29f83f0b99c6a73dd41a1546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942f178a29f83f0b99c6a73dd41a1546">&#9670;&nbsp;</a></span>IsServiceTypeRegistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::RobotRaconteurNode::IsServiceTypeRegistered </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a service type has been registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The name of the service to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a99d97b13d2110d6d0f9573dedce1a048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d97b13d2110d6d0f9573dedce1a048">&#9670;&nbsp;</a></span>LogMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::LogMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log a simple message using the current node. </p>
<p>The record will be sent to the configured log handler, or sent to std::cerr if none is configured</p>
<p>If the level of the message is below the current log level for the node, the record will be ignored</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level for the log message </td></tr>
    <tr><td class="paramname">message</td><td>The log message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7521777a9bf735970c094e45735ccdef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7521777a9bf735970c094e45735ccdef">&#9670;&nbsp;</a></span>LogRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::LogRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_robot_raconteur_1_1_r_r_log_record.html">RRLogRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log a record to the node. Use the macros specified in <a class="el" href="_logging_8h.html">Logging.h</a> instead of this function directly. </p>
<p>The record will be sent to the configured log handler, or sent to std::cerr if none is configured</p>
<p>If the level of the message is below the current log level for the node, it will be ignored</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>The record to log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20f7a8892481899ab761f0169737475e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f7a8892481899ab761f0169737475e">&#9670;&nbsp;</a></span>MonitorEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::MonitorEnter </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a monitor lock on a specified object. </p>
<p>Monitor locks are intendended for short operations that require guarding to prevent races, corruption, or other concurrency problems. Monitors emulate a single thread locking the service object.</p>
<p>Use of <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node_1_1_scoped_monitor_lock.html" title="Wrapper for RobotRaconteurNode::MonitorEnter() and RobotRaconteurNode::MonitorExit() to take advantag...">ScopedMonitorLock</a> instead of this function is highly recommended to take advantage of RAII scoping</p>
<p>Monitor locks do not lock any sub-objects (objref)</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to lock </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds to acquire the monitor lock, or RR_TIMEOUT_INFINITE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb28c18c0297ec597596f79586308a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb28c18c0297ec597596f79586308a83">&#9670;&nbsp;</a></span>MonitorExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::MonitorExit </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a monitor lock. </p>
<p>Use of <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node_1_1_scoped_monitor_lock.html" title="Wrapper for RobotRaconteurNode::MonitorEnter() and RobotRaconteurNode::MonitorExit() to take advantag...">ScopedMonitorLock</a> instead of this function is highly recommended to take advantage of RAII scoping</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object previously locked by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20f7a8892481899ab761f0169737475e" title="Creates a monitor lock on a specified object.">MonitorEnter()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6859ecf8c0069d81083f24658152ea4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6859ecf8c0069d81083f24658152ea4f">&#9670;&nbsp;</a></span>NodeID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> RobotRaconteur::RobotRaconteurNode::NodeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. </p>
<p>Gets the current <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. If one has not been set using <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ab5fb2f14aaa470a4b2f08b752bcb5d8d" title="Set the NodeID.">SetNodeID()</a></code>, one will be automatically generated.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> </dd></dl>

</div>
</div>
<a id="a816484b0722841071cbfe222e6918630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816484b0722841071cbfe222e6918630">&#9670;&nbsp;</a></span>NodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::NodeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current NodeName. </p>
<p>Gets the current NodeName. If one has not been set using <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ad736626db2dede0ed836a787ba59f1ca" title="Set the NodeName.">SetNodeName()</a></code>, it will be an empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

</div>
</div>
<a id="a90e8e730b74dc3e97733a795d2e89c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e8e730b74dc3e97733a795d2e89c7e">&#9670;&nbsp;</a></span>NodeSyncTimeSpec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> RobotRaconteur::RobotRaconteurNode::NodeSyncTimeSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sync time of the node as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a>. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a96d9e4722cbe9be1c05e30bd52f18134" title="The sync time of the node.">NodeSyncTimeUTC()</a></p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a> The node sync time as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a> </dd></dl>

</div>
</div>
<a id="a96d9e4722cbe9be1c05e30bd52f18134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d9e4722cbe9be1c05e30bd52f18134">&#9670;&nbsp;</a></span>NodeSyncTimeUTC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::posix_time::ptime RobotRaconteur::RobotRaconteurNode::NodeSyncTimeUTC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sync time of the node. </p>
<p>The node synchronizes it's clock with the system time in UTC when the node is initialized. After this time, a steady clock is used. This prevents the clock from jumping forward and back in time. It will no longer be updated by changes in the system time.</p>
<p>If an external high precision clock source like PTP is available, that clock will be used in place of the system and steady clock.</p>
<dl class="section return"><dt>Returns</dt><dd>boost::posix_time::ptime The node sync time in UTC </dd></dl>

</div>
</div>
<a id="aded9736b6e52cdecaefcac88bc7994b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded9736b6e52cdecaefcac88bc7994b5">&#9670;&nbsp;</a></span>NowNodeTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::posix_time::ptime RobotRaconteur::RobotRaconteurNode::NowNodeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current node time. </p>
<p>UTC time is not monotonic, due to the introduction of leap-seconds, and the possibility of the system clock being updated by the user. For a real-time systems, this is unaccetpable and can lead to system instability. The "node time" used by Robot Raconteur is synchronized to UTC at startup, and is then steadily increasing from that initial time. It will ignore changes to the system clock, and will also ignore corrections like leap seconds.</p>
<dl class="section return"><dt>Returns</dt><dd>boost::posix_time::ptime The current node time </dd></dl>

</div>
</div>
<a id="abb437079a0be88a4ca78834d781b1492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb437079a0be88a4ca78834d781b1492">&#9670;&nbsp;</a></span>NowTimeSpec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> RobotRaconteur::RobotRaconteurNode::NowTimeSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current node time as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a>. </p>
<p>The current node time as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a>. See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#aded9736b6e52cdecaefcac88bc7994b5" title="The current node time.">NowNodeTime()</a></p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a> The current node time as a <a class="el" href="class_robot_raconteur_1_1_time_spec.html" title="Represents. a point in time. Used by wire members to timestamp packets.">TimeSpec</a> </dd></dl>

</div>
</div>
<a id="a0ae3d8577ba4e95dd2a7626d094923ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae3d8577ba4e95dd2a7626d094923ca">&#9670;&nbsp;</a></span>NowUTC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::posix_time::ptime RobotRaconteur::RobotRaconteurNode::NowUTC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current time in UTC time zone. </p>
<p>Uses the internal node clock to get the current time in UTC. While this will normally use the system clock, this may use simulation time in certain circumstances</p>
<dl class="section return"><dt>Returns</dt><dd>boost::posix_time::ptime The current time in UTC </dd></dl>

</div>
</div>
<a id="acf44e1310015297746420eaec09a58d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf44e1310015297746420eaec09a58d6">&#9670;&nbsp;</a></span>RegisterService() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a>&gt; RobotRaconteur::RobotRaconteurNode::RegisterService </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a> &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a service using a previously instantiated <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a>. </p>
<p>The node will store a reference to the provided <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a> and manage its lifecycle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a> to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServerContext&gt; </dd></dl>

</div>
</div>
<a id="a074209e23f46fbdd14dd43aa7773caf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074209e23f46fbdd14dd43aa7773caf7">&#9670;&nbsp;</a></span>RegisterService() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_server_context.html">ServerContext</a>&gt; RobotRaconteur::RobotRaconteurNode::RegisterService </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>servicetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_security_policy.html">ServiceSecurityPolicy</a> &gt;&#160;</td>
          <td class="paramname"><em>securitypolicy</em> = <code>boost::shared_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_service_security_policy.html">ServiceSecurityPolicy</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a service for clients to connect. </p>
<p>The supplied object becomes the root object in the service. Other objects may be accessed by clients using <code>objref</code> members. The name of the service must conform to the naming rules of Robot Raconteur member names. A service is closed using either <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a8394d64e879ff871aa7d74284d082e46" title="Closes a previously registered service.">CloseService()</a> or when <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3fd1a28c207e9b2b5a5363394f355b7a" title="Shuts down the node. Called automatically by ClientNodeSetup and ServerNodeSetup.">Shutdown()</a> is called.</p>
<p>Multiple services can be registered within the same node. Service names within a single node must be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the service, must follow member naming rules </td></tr>
    <tr><td class="paramname">servicetype</td><td>The name of the service definition containing the object type. Do not include the object type. </td></tr>
    <tr><td class="paramname">obj</td><td>The root object of the service </td></tr>
    <tr><td class="paramname">securitypolicy</td><td>An optional security policy for the service to control authentication and other security functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServerContext&gt; The instantiated <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">ServerContext</a>. This object is owned by the node and the return can be safely ignored. </dd></dl>

</div>
</div>
<a id="ac52825328ff0b987d49f6212bfc5d47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52825328ff0b987d49f6212bfc5d47b">&#9670;&nbsp;</a></span>RegisterServiceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::RegisterServiceType </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_factory.html">ServiceFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a service type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The service factory implementing the type to register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb14a50a990168d4fbb9e629f1f802a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb14a50a990168d4fbb9e629f1f802a2">&#9670;&nbsp;</a></span>RegisterTransport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RobotRaconteur::RobotRaconteurNode::RegisterTransport </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_transport.html">Transport</a> &gt;&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a transport for use by the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The transport internal id </dd></dl>

</div>
</div>
<a id="a52fb5b31209ac66cd1b7a51ab9e3c622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fb5b31209ac66cd1b7a51ab9e3c622">&#9670;&nbsp;</a></span>ReleaseObjectLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::ReleaseObjectLock </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an excluse access lock previously locked with <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RequestObjectLock()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a" title="Asynchronously request an exclusive access lock to a service object.">AsyncRequestObjectLock()</a> </p>
<p>Object must have previously been locked using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RequestObjectLock()</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1353a400015fe9d4e50ae35cff927b3a" title="Asynchronously request an exclusive access lock to a service object.">AsyncRequestObjectLock()</a></p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object previously locked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string "OK" on success </dd></dl>

</div>
</div>
<a id="a017a1a72e885b41741a513aa1cfb4057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017a1a72e885b41741a513aa1cfb4057">&#9670;&nbsp;</a></span>RemovePeriodicCleanupTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::RemovePeriodicCleanupTask </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; IPeriodicCleanupTask &gt;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a task previously registered with <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5f78b0932edf7f514939bf1049daf91b" title="Add a periodic cleanup task.">AddPeriodicCleanupTask()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92b19ab712aa7a96f7dfb7b3bfbf8673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b19ab712aa7a96f7dfb7b3bfbf8673">&#9670;&nbsp;</a></span>RequestObjectLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RobotRaconteur::RobotRaconteurNode::RequestObjectLock </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_object.html">RRObject</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_robot_raconteur_node_8h.html#acd5d4086935257f7b0aaac15cf805a58">RobotRaconteurObjectLockFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request an exclusive access lock to a service object. </p>
<p>Called by clients to request an exclusive lock on a service object and all subobjects (<code>objrefs</code>) in the service. The exclusive access lock will prevent other users ("User" lock) or client connections ("Session" lock) from interacting with the objects.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to lock. Must be returned by ConnectService or returned by an <code>objref</code> </td></tr>
    <tr><td class="paramname">flags</td><td>Select either a "User" or "Session" lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string "OK" on success </dd></dl>

</div>
</div>
<a id="a2376f20076c4e0015d86f15948ff1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2376f20076c4e0015d86f15948ff1b8b">&#9670;&nbsp;</a></span>s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a>* RobotRaconteur::RobotRaconteurNode::s </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singleton accessor. </p>
<p>The <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html" title="The central node implementation.">RobotRaconteurNode</a> singleton can be used when only one instance of Robot Raconteur is required in a program. The singleton must be shut down when the program exits.</p>
<p>This function returns a pointer to the singleton node. Using <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f" title="Singleton shared_ptr accessor.">sp()</a></code> if a shared_ptr is required.</p>
<dl class="section return"><dt>Returns</dt><dd>RobotRaconteurNode* </dd></dl>

</div>
</div>
<a id="aba469ef8ecb119f0f99abcb754a98119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba469ef8ecb119f0f99abcb754a98119">&#9670;&nbsp;</a></span>SelectRemoteNodeURL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string RobotRaconteur::RobotRaconteurNode::SelectRemoteNodeURL </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>urls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the "best" URL from a std::vector of candidates. </p>
<p>Service discovery will often return a list of candidate URLs to use to connect to a node. This function uses hueristics to select the "best" URL to use. The selection criteria ranks URLs in roughly the following order, lower number being better:</p>
<ol type="1">
<li>"rr+intra" for <a class="el" href="class_robot_raconteur_1_1_intra_transport.html" title="Transport for intra-process communication.">IntraTransport</a></li>
<li>"rr+local" for <a class="el" href="class_robot_raconteur_1_1_local_transport.html" title="Transport for communication between processes using UNIX domain sockets.">LocalTransport</a></li>
<li>"rr+pci" or "rr+usb" for <a class="el" href="class_robot_raconteur_1_1_hardware_transport.html" title="Transport for USB, Bluetooth, and PCIe hardware devices.">HardwareTransport</a></li>
<li>"rrs+tcp://127.0.0.1" for secure <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> loopback</li>
<li>"rrs+tcp://[::1]" for secure <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> IPv6 loopback</li>
<li>"rrs+tcp://localhost" for secure <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> loopback</li>
<li>"rrs+tcp://[fe80" for secure <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> link-local IPv6</li>
<li>"rrs+tcp://" for any secure <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a></li>
<li>"rr+tcp://127.0.0.1" for <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> loopback</li>
<li>"rr+tcp://[::1]" for <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> IPv6 loopback</li>
<li>"rr+tcp://localhost" for <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> loopback</li>
<li>"rr+tcp://[fe80" for <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a> link-local IPv6</li>
<li>"rr+tcp://" for any <a class="el" href="class_robot_raconteur_1_1_tcp_transport.html" title="Transport for Transport Control Protocol Internet Protocol (TCP/IP) networks.">TcpTransport</a></li>
</ol>
<p>TODO: "rr+quic" QuicTransport</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urls</td><td>The candidate URLs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The "best" URL out of the candidates </dd></dl>

</div>
</div>
<a id="a5d0b2c4e6bb149334a476e210b38bbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0b2c4e6bb149334a476e210b38bbc2">&#9670;&nbsp;</a></span>SetDynamicServiceFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetDynamicServiceFactory </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html">RobotRaconteur::DynamicServiceFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the DynamicServicefactory. </p>
<p><a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html" title="Dynamic service factory base class.">DynamicServiceFactory</a> is used by language wrappers to dynamically generate ServiceFactories based on ServiceDefinitions. DynamicServiceFactories allow Robot Raconteur to provide dynamic type handling at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The <a class="el" href="class_robot_raconteur_1_1_dynamic_service_factory.html" title="Dynamic service factory base class.">DynamicServiceFactory</a> instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa62113027c9775e1345423e6e8d3b1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62113027c9775e1345423e6e8d3b1cd">&#9670;&nbsp;</a></span>SetEndpointInactivityTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetEndpointInactivityTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timeout for endpoint activity in milliseconds. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1d6d3fa0284f0e644ef0eb6744717c83" title="Get the timeout for endpoint activity in milliseconds.">GetEndpointInactivityTimeout()</a> for explanation of endpoint inactivity timeouts. Default value is 10 minutes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374ea4d70fe2d27b14346c34b22b2167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374ea4d70fe2d27b14346c34b22b2167">&#9670;&nbsp;</a></span>SetExceptionHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetExceptionHandler </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(const std::exception *)&gt;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an exception handler function. </p>
<p>The <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> will catch exceptions that are uncaught by other logic and pass the exception to the specified exception handler. User handler functions that throw exceptions will also be caught and passed to the specified handler function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler function for uncaught exceptions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bd9bb2d6c8463dcc9e888e7b7391472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd9bb2d6c8463dcc9e888e7b7391472">&#9670;&nbsp;</a></span>SetLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the log level for the node. </p>
<p>Set RobotRaconteur_LogLevel_Disable to disable logging</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The desired log level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c34d302ad11cc9a72898a8ada87ce14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c34d302ad11cc9a72898a8ada87ce14">&#9670;&nbsp;</a></span>SetLogLevelFromEnvVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a> RobotRaconteur::RobotRaconteurNode::SetLogLevelFromEnvVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>env_variable_name</em> = <code>&quot;ROBOTRACONTEUR_LOG_LEVEL&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the log level for the node from specified environmental variable. </p>
<p>Retrieves the specified environmental variable and sets the log level based on one of the following values: DISABLE, FATAL, ERROR, WARNING, INFO, DEBUG, TRACE</p>
<p>If an invalid value or the variable does not exist, the log level is left unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env_variable_name</td><td>The environmental variable to use. Defaults to <code>ROBOTRACONTEUR_LOG_LEVEL</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RobotRaconteur_LogLevel The log level </dd></dl>

</div>
</div>
<a id="a345dda51aba49435c2082f4daa394de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345dda51aba49435c2082f4daa394de0">&#9670;&nbsp;</a></span>SetLogLevelFromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_robot_raconteur_constants_8h.html#a22bd9afe88530132144b5809c24ce622">RobotRaconteur_LogLevel</a> RobotRaconteur::RobotRaconteurNode::SetLogLevelFromString </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the log level for the node from a string. </p>
<p>Must be one of the following values: DISABLE, FATAL, ERROR, WARNING, INFO, DEBUG, TRACE</p>
<p>Defaults to WARNING</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The desired log level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RobotRaconteur_LogLevel The log level </dd></dl>

</div>
</div>
<a id="aa68ff720b5a49f7fe8af09cbb7826702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68ff720b5a49f7fe8af09cbb7826702">&#9670;&nbsp;</a></span>SetLogRecordHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetLogRecordHandler </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_log_record_handler.html">LogRecordHandler</a> &gt;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the handler for log records. </p>
<p>If handler is NULL, records are sent to std::cerr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The log record handler function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1d6bcc6a147105231ebb671d1bca000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d6bcc6a147105231ebb671d1bca000">&#9670;&nbsp;</a></span>SetMemoryMaxTransferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetMemoryMaxTransferSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum chunk size for memory transfers in bytes. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac49aaf2196acab71f7d37c9ce4fdc3c4" title="Get the maximum chunk size for memory transfers in bytes.">GetMemoryMaxTransferSize()</a> for an explanation of memory transfer sizes. Be careful not to exceed the message size limitation of the transports in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The max memory transfer size in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d8ca65366a184c7c025e40032a81f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8ca65366a184c7c025e40032a81f72">&#9670;&nbsp;</a></span>SetMessageTap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetMessageTap </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_message_tap.html">MessageTap</a> &gt;&#160;</td>
          <td class="paramname"><em>message_tap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the a message tap to record log records and messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_tap</td><td>The message tap to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af71e24cca00eb15c7cde46cdd171e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71e24cca00eb15c7cde46cdd171e649">&#9670;&nbsp;</a></span>SetNodeDiscoveryMaxCacheCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetNodeDiscoveryMaxCacheCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set maximum number of detected nodes that will be cached. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a0a067c797b846fdabc381afa23a6d973" title="Get the maximum number of detected nodes that will be cached.">GetNodeDiscoveryMaxCacheCount()</a> for more information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The maximum number of detected nodes to cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5fb2f14aaa470a4b2f08b752bcb5d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fb2f14aaa470a4b2f08b752bcb5d8d">&#9670;&nbsp;</a></span>SetNodeID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetNodeID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. </p>
<p>The <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> must be set before <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6859ecf8c0069d81083f24658152ea4f" title="Get the current NodeID.">NodeID()</a></code> is called. If an attempt to set the <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> after <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6859ecf8c0069d81083f24658152ea4f" title="Get the current NodeID.">NodeID()</a></code> has been called, an <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> will be thrown.</p>
<p>The <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> must not be all zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad736626db2dede0ed836a787ba59f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad736626db2dede0ed836a787ba59f1ca">&#9670;&nbsp;</a></span>SetNodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetNodeName </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the NodeName. </p>
<p>The NodeName must be set before calling <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a816484b0722841071cbfe222e6918630" title="Get the current NodeName.">NodeName()</a></code> If an attempt to set the NodeName after <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a816484b0722841071cbfe222e6918630" title="Get the current NodeName.">NodeName()</a></code> has been called, an <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> will be thrown.</p>
<p>The NodeName must not be empty, and must conform to the following regex:</p>
<p><code>^[a-zA-Z][a-zA-Z0-9_\\.\\-]*$</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016c9e8c321a2ce28c8e0212bbf9fdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c9e8c321a2ce28c8e0212bbf9fdf0">&#9670;&nbsp;</a></span>SetRequestTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetRequestTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timeout for requests in milliseconds. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ac5f4ed2c1b2cd3362a3e34b403cb909a" title="Get the timeout for requests in milliseconds.">GetRequestTimeout()</a> for explanation of request timeouts. Default timeout is 15 seconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3591e63518e7f0b77d5bd098934908a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591e63518e7f0b77d5bd098934908a2">&#9670;&nbsp;</a></span>SetThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetThreadPool </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool.html">ThreadPool</a> &gt;&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node. </p>
<p>This function must be called before a <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> has been set, either through this fuction, or a <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> is created by <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a3a1cbe435fd92fe82849fc77a8cc9f92" title="Get the current ThreadPool for the node.">GetThreadPool()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac446b9e8f12ad138e996ae0b68cb4cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac446b9e8f12ad138e996ae0b68cb4cb7">&#9670;&nbsp;</a></span>SetThreadPoolCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetThreadPoolCount </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads for the node <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a>. </p>
<p>The <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> will use a maximum of count threads. If this number is lower than the current <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> count, the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> will attempt to release threads beyond count as they return to idle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of threads for the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a771f99464b199a1c9b1ab855769c63f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771f99464b199a1c9b1ab855769c63f6">&#9670;&nbsp;</a></span>SetThreadPoolFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetThreadPoolFactory </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html">ThreadPoolFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> for the node. </p>
<p><a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> is used to create a <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> for the node if one is not already set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The <a class="el" href="class_robot_raconteur_1_1_thread_pool_factory.html" title="ThreadPool factory for use with RobotRaconteurNode.">ThreadPoolFactory</a> for the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c21bba9af0e777dcb08b2824d6c6bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c21bba9af0e777dcb08b2824d6c6bef">&#9670;&nbsp;</a></span>SetTransportInactivityTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::SetTransportInactivityTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timeout for transport activity in milliseconds. </p>
<p>See <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1ba2c3826df32cf422541e8c1d543c44" title="Get the timeout for transport activity in milliseconds.">GetTransportInactivityTimeout()</a> for explanation of tranport inactivity timeouts. Default value is 10 minutes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fd1a28c207e9b2b5a5363394f355b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd1a28c207e9b2b5a5363394f355b7a">&#9670;&nbsp;</a></span>Shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RobotRaconteur::RobotRaconteurNode::Shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuts down the node. Called automatically by <a class="el" href="class_robot_raconteur_1_1_client_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a client only node.">ClientNodeSetup</a> and <a class="el" href="class_robot_raconteur_1_1_server_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a server and client node.">ServerNodeSetup</a>. </p>
<p>Shutdown must be called before program exit to avoid segfaults and other undefined behavior. The use of <a class="el" href="class_robot_raconteur_1_1_client_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a client only node.">ClientNodeSetup</a> and <a class="el" href="class_robot_raconteur_1_1_server_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a server and client node.">ServerNodeSetup</a> is recommended to automate the node lifecycle. Calling this function does the following:</p><ol type="1">
<li>Closes all services and releases all service objects</li>
<li>Closes all client connections</li>
<li>Shuts down discovery</li>
<li>Shuts down all transports</li>
<li>Notifies all shutdown listeners</li>
<li>Releases all periodic cleanup task listeners</li>
<li>Shuts down and releases the thread pool</li>
</ol>
<p>Requires Multithreading </p>

</div>
</div>
<a id="a787bdba5f06a44c591595a7ba21cf6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787bdba5f06a44c591595a7ba21cf6a7">&#9670;&nbsp;</a></span>Sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RobotRaconteur::RobotRaconteurNode::Sleep </td>
          <td>(</td>
          <td class="paramtype">const boost::posix_time::time_duration &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sleeps for a specified duration. </p>
<p>Normally will sleep based on the system clock, but in certain circumstances will use simulation time</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The duration to sleep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a948364d2308bdb464413f1ec356cca1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948364d2308bdb464413f1ec356cca1f">&#9670;&nbsp;</a></span>sp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a>&gt; RobotRaconteur::RobotRaconteurNode::sp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singleton shared_ptr accessor. </p>
<p>Same as <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a2376f20076c4e0015d86f15948ff1b8b" title="Singleton accessor.">s()</a></code>, but returns a shared_ptr instead of a plain pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;RobotRaconteurNode&gt; </dd></dl>

</div>
</div>
<a id="a5c5946e947d7c5bc5fac008dde8e2bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5946e947d7c5bc5fac008dde8e2bc1">&#9670;&nbsp;</a></span>SubscribeService() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_service_subscription.html">ServiceSubscription</a>&gt; RobotRaconteur::RobotRaconteurNode::SubscribeService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>username</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>credentials</em> = <code>(boost::intrusive_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt;&#160;std::string,&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a>&#160;&gt;&#160;&gt;())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to a service using a URL. Used to create robust connections to services. </p>
<p>Creates a <a class="el" href="class_robot_raconteur_1_1_service_subscription.html" title="Subscription that automatically connects services and manages lifecycle of connected services.">ServiceSubscription</a> assigned to a service with a URL. The subscription will attempt to maintain a peristent connection, reconnecting if the connection is lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The connection URL </td></tr>
    <tr><td class="paramname">username</td><td>An optional username for authentication </td></tr>
    <tr><td class="paramname">credentials</td><td>Optional credentials for authentication </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired root object proxy type. Optional but highly recommended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServiceSubscription&gt; The subscription object </dd></dl>

</div>
</div>
<a id="a073f6638ab7a4db125de1125ad0e6f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073f6638ab7a4db125de1125ad0e6f90">&#9670;&nbsp;</a></span>SubscribeService() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_service_subscription.html">ServiceSubscription</a>&gt; RobotRaconteur::RobotRaconteurNode::SubscribeService </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>username</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::intrusive_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt; std::string, <a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>credentials</em> = <code>(boost::intrusive_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_map.html">RRMap</a>&lt;&#160;std::string,&#160;<a class="el" href="class_robot_raconteur_1_1_r_r_value.html">RRValue</a>&#160;&gt;&#160;&gt;())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>objecttype</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to a service using one or more URL. Used to create robust connections to services. </p>
<p>Creates a <a class="el" href="class_robot_raconteur_1_1_service_subscription.html" title="Subscription that automatically connects services and manages lifecycle of connected services.">ServiceSubscription</a> assigned to a service with one or more candidate connection URLs. The subscription will attempt to maintain a peristent connection, reconnecting if the connection is lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>One or more candidate connection urls </td></tr>
    <tr><td class="paramname">username</td><td>An optional username for authentication </td></tr>
    <tr><td class="paramname">credentials</td><td>Optional credentials for authentication </td></tr>
    <tr><td class="paramname">objecttype</td><td>The desired root object proxy type. Optional but highly recommended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServiceSubscription&gt; The subscription object </dd></dl>

</div>
</div>
<a id="a8639a0c1e88b6a23bcce13cdf37dd055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8639a0c1e88b6a23bcce13cdf37dd055">&#9670;&nbsp;</a></span>SubscribeServiceByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_service_subscription.html">ServiceSubscription</a>&gt; RobotRaconteur::RobotRaconteurNode::SubscribeServiceByType </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>service_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a> &gt;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>boost::shared_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to listen for available services and automatically connect. </p>
<p>A <a class="el" href="class_robot_raconteur_1_1_service_subscription.html" title="Subscription that automatically connects services and manages lifecycle of connected services.">ServiceSubscription</a> will track the availability of service types and create connections when available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_types</td><td>A std::vector of service types to listen for, ie <code>com.robotraconteur.robotics.robot.Robot</code> </td></tr>
    <tr><td class="paramname">filter</td><td>A filter to select individual services based on specified criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServiceSubscription&gt; The active subscription </dd></dl>

</div>
</div>
<a id="a9b8dfa95723e02f603e5583a96ff11b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8dfa95723e02f603e5583a96ff11b4">&#9670;&nbsp;</a></span>SubscribeServiceInfo2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_service_info2_subscription.html">ServiceInfo2Subscription</a>&gt; RobotRaconteur::RobotRaconteurNode::SubscribeServiceInfo2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>service_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a> &gt;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>boost::shared_ptr&lt;&#160;<a class="el" href="class_robot_raconteur_1_1_service_subscription_filter.html">ServiceSubscriptionFilter</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to listen for available services information. </p>
<p>A <a class="el" href="class_robot_raconteur_1_1_service_info2_subscription.html" title="Subscription for information about detected services.">ServiceInfo2Subscription</a> will track the availability of service types and inform when services become available or are lost. If connections to available services are also required, <a class="el" href="class_robot_raconteur_1_1_service_subscription.html" title="Subscription that automatically connects services and manages lifecycle of connected services.">ServiceSubscription</a> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_types</td><td>A std::vector of service types to listen for, ie <code>com.robotraconteur.robotics.robot.Robot</code> </td></tr>
    <tr><td class="paramname">filter</td><td>A filter to select individual services based on specified criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;ServiceInfo2Subscription&gt; The active subscription </dd></dl>

</div>
</div>
<a id="a9ff40f8f3efd9e75f28d36ac429f7b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff40f8f3efd9e75f28d36ac429f7b76">&#9670;&nbsp;</a></span>TryGetNodeID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::RobotRaconteurNode::TryGetNodeID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot_raconteur_1_1_node_i_d.html">RobotRaconteur::NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries getting the current <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. </p>
<p>Tries to get the <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a>. Returns false if no <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> has been configured</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the <a class="el" href="class_robot_raconteur_1_1_node_i_d.html" title="NodeID UUID storage and generation.">NodeID</a> if set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a343fba84bcca2c7e1b0554b4f610344b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343fba84bcca2c7e1b0554b4f610344b">&#9670;&nbsp;</a></span>TryGetNodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::RobotRaconteurNode::TryGetNodeName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries getting the current NodeName. </p>
<p>Gets the current NodeName. Returns false if NodeName is empty</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>the NodeName if not empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="ac3a2b3e2120198e12573bce3f819b727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a2b3e2120198e12573bce3f819b727">&#9670;&nbsp;</a></span>TryGetThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::RobotRaconteurNode::TryGetThreadPool </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_thread_pool.html">ThreadPool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to get the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a>, returns false if the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> is not available. </p>
<p>This function will normally only return false if the node has been shut down</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Out parameter to receive <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> shared_ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true pool contains shared_ptr to the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> </dd>
<dd>
false Threadpool is not available </dd></dl>

</div>
</div>
<a id="ac128e4a5bada609ddaeb88232a937cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac128e4a5bada609ddaeb88232a937cdf">&#9670;&nbsp;</a></span>TryHandleException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool RobotRaconteur::RobotRaconteurNode::TryHandleException </td>
          <td>(</td>
          <td class="paramtype">RR_WEAK_PTR&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::exception *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to pass an exception to the exception handler. </p>
<p>Attempts to pass an exception to the handler function. Will fail and return false if node is null or the exception handler has not been set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to handle the exception </td></tr>
    <tr><td class="paramname">exp</td><td>The exception to pass to the handler function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The handler function was called </dd>
<dd>
false The handler function was not called </dd></dl>

</div>
</div>
<a id="ad59668fcbb6c900e53f147c3e2cacd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59668fcbb6c900e53f147c3e2cacd22">&#9670;&nbsp;</a></span>TryPostToThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool RobotRaconteur::RobotRaconteurNode::TryPostToThreadPool </td>
          <td>(</td>
          <td class="paramtype">RR_WEAK_PTR&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(HandlerType)&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shutdown_op</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to post a handler function to be called by a thread in the thread pool. Returns immediately. </p>
<p>This function will not wait for the handler function to complete.</p>
<p>If node is null or <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> is not available, the handler is not called and false is returned</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HandlerType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">h</td><td>The handler to post </td></tr>
    <tr><td class="paramname">shutdown_op</td><td>True if handler should be called during node shutdown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The function was post to the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> </dd>
<dd>
false The handler could not be post to the <a class="el" href="class_robot_raconteur_1_1_thread_pool.html" title="Thread pool for Robot Raconteur nodes.">ThreadPool</a> </dd></dl>

</div>
</div>
<a id="aa024d6ce47e6c1cae050df28e6924ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa024d6ce47e6c1cae050df28e6924ca4">&#9670;&nbsp;</a></span>UnregisterServiceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::UnregisterServiceType </td>
          <td>(</td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a previously registered service type. </p>
<p>This function is not recommended as the results can be unpredicatle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b5c9142ccb18ad1f55937c9d63ce743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5c9142ccb18ad1f55937c9d63ce743">&#9670;&nbsp;</a></span>UpdateDetectedNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::RobotRaconteurNode::UpdateDetectedNodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>schemes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the detected nodes cache. </p>
<p>The node keeps a cache of detected nodes, but this may become stale if nodes are rapidly added and removed from the network. Call this function to update the detected nodes.</p>
<p>Requires multithreading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemes</td><td>A vector of transport schemes, ie "rr+tcp", "rr+local", etc. to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2da0778099f48499324a76dbe098bb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da0778099f48499324a76dbe098bb48">&#9670;&nbsp;</a></span>weak_sp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static RR_WEAK_PTR&lt;<a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html">RobotRaconteurNode</a>&gt; RobotRaconteur::RobotRaconteurNode::weak_sp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singleton weak_ptr accessor. </p>
<p>Same as <code><a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a948364d2308bdb464413f1ec356cca1f" title="Singleton shared_ptr accessor.">sp()</a></code>, but returns a weak_ptr instead of a shared_ptr.</p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;RobotRaconteurNode&gt; </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/wasonj/Documents/RobotRaconteur2/robotraconteur/RobotRaconteurCore/include/RobotRaconteur/<a class="el" href="_robot_raconteur_node_8h_source.html">RobotRaconteurNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
