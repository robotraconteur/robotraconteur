<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: C++ Value Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Value Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_C__Users_wasonj_Documents_RobotRaconteur2_robotraconteur_docs_cpp_cpp_value_types"></a> Each valid Robot Raconteur type has a corresponding C++ data type. This mapping is similar to Python. The following table shows the mapping between Robot Raconteur and C++ data types:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Robot Raconteur Type  </th><th class="markdownTableHeadNone">C++ Type  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>double</code>  </td><td class="markdownTableBodyNone"><code>double</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>single</code>  </td><td class="markdownTableBodyNone"><code>float</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int8</code>  </td><td class="markdownTableBodyNone"><code>int8_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint8</code>  </td><td class="markdownTableBodyNone"><code>uint8_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int16</code>  </td><td class="markdownTableBodyNone"><code>int16_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16</code>  </td><td class="markdownTableBodyNone"><code>uint16_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int32</code>  </td><td class="markdownTableBodyNone"><code>int32_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32</code>  </td><td class="markdownTableBodyNone"><code>uint32_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int64</code>  </td><td class="markdownTableBodyNone"><code>int64_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint64</code>  </td><td class="markdownTableBodyNone"><code>uint64_t</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>double[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;double&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>single[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;float&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int8[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;int8_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint8[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;uint8_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int16[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;int16_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint16[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;uint16_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int32[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;int32_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint32[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;uint32_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int64[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;int64_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>uint64[]</code>  </td><td class="markdownTableBodyNone"><code>RRArrayPtr&lt;uint64_t&gt;</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>N[*]</code>  </td><td class="markdownTableBodyNone"><code>RRMultiDimArrayPtr&lt;N&gt;</code>  </td><td class="markdownTableBodyNone">Multi-dim array of type numeric type <code>N</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>string</code>  </td><td class="markdownTableBodyNone"><code>std::string</code> or <code>RRArrayPtr&lt;char&gt;</code>  </td><td class="markdownTableBodyNone">Strings are always UTF-8 encoded   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>struct</code>  </td><td class="markdownTableBodyNone"><em>varies</em>  </td><td class="markdownTableBodyNone">Use generated C++ type   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pod</code>  </td><td class="markdownTableBodyNone"><em>varies</em>  </td><td class="markdownTableBodyNone">Use generated C++ type   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>T[]</code> where T is a <code>pod</code>  </td><td class="markdownTableBodyNone"><code>RRPodArrayPtr&lt;T&gt;</code>  </td><td class="markdownTableBodyNone">Pod array with C++ type <code>T</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>T[*]</code> where T is a <code>pod</code>  </td><td class="markdownTableBodyNone"><code>RRPodMultiDimArrayPtr&lt;T&gt;</code>  </td><td class="markdownTableBodyNone">Pod multi-dim array with C++ type <code>T</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>namedarray</code>  </td><td class="markdownTableBodyNone"><em>varies</em>  </td><td class="markdownTableBodyNone">Use generated C++ <code>union</code> type   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>T[]</code> where T is a <code>namedarray</code>  </td><td class="markdownTableBodyNone"><code>RRNamedArrayPtr&lt;T&gt;</code>  </td><td class="markdownTableBodyNone">Named array with C++ type <code>T</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>T[*]</code> where T is a <code>namedarray</code>  </td><td class="markdownTableBodyNone"><code>RRNamedMultiDimArrayPtr&lt;T&gt;</code>  </td><td class="markdownTableBodyNone">Named multi-dim array with C++ type <code>T</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>T{int32}</code>  </td><td class="markdownTableBodyNone"><code>RRMapPtr&lt;int32_t,T&gt;</code>  </td><td class="markdownTableBodyNone">Map type, <code>T</code> is a template   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>T{string}</code>  </td><td class="markdownTableBodyNone"><code>RRMapPtr&lt;std::string,T&gt;</code>  </td><td class="markdownTableBodyNone">Map type, <code>T</code> is a template   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>T{list}</code>  </td><td class="markdownTableBodyNone"><code>RRListPtr&lt;T&gt;</code>  </td><td class="markdownTableBodyNone">List type, <code>T</code> is a template   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>varvalue</code>  </td><td class="markdownTableBodyNone"><code>RRValuePtr</code>  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>varobject</code>  </td><td class="markdownTableBodyNone"><code>RRObjectPtr</code>  </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h1><a class="anchor" id="cpp_stack_and_pointers"></a>
Stack Values and Value Smart Pointers</h1>
<p>C++ data can be <a href="https://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/">"stack" and "heap"</a> allocated. The stack is local contiguous memory allocated when a function is called. "Stack allocated" data is stored in this contiguous memory region. Stack allocation has the advantage of being pre-allocated, and destroyed automatically. Stack data storage needs to have a fixed size known at compile time, and is automatically destroyed when the function exits, meaning that any pointers or references to that data will be invalid once the function exits. Heap allocated memory allocated dynamically using <code>new</code>, and must be freed with <code>delete</code>. A pointer to the allocated memory is returned by <code>new</code>. Smart pointers can be used to determine when the allocated memory should be deleted by keeping an active count of how many pointers exist to the data.</p>
<p>C++ structures and class instances are stored as contiguous memory, with individual fields stored within parts of the contiguous memory. The memory used to store structures and class instances can be allocated on the stack or the heap. Fields which are stack allocated types are stored within this contiguous memory, regardless if the structure/class memory was allocated on the stack or the heap. Pointers are used for fields which are heap allocated.</p>
<p>Robot Raconteur uses both stack and heap allocated memory to store value types. Stack allocation is used to store scalar numbers, scalar <code>pod</code>, scalar <code>namedarray</code>, and fields contained in both <code>pod</code> and <code>namedarray</code>. Heap allocation is used for all other types, using <code>boost::intrusive_ptr</code> (or alias <code>RR_INTRUSIVE_PTR</code>) to track the number of active pointers and delete when the count goes to zero. All heap allocated Robot Raconteur value types inherit from <a class="el" href="class_robot_raconteur_1_1_r_r_value.html" title="Base class for all Robot Raconteur value types (except primitives)">RobotRaconteur::RRValue</a>. RRValue inherits <code>boost::intrusive_ref_counter</code>, implementing the reference counting storage required for <code>boost::intrusive_ptr</code>. Convenience aliases are used to simplify the declarations of types using smart pointers. These convenience alias end with <code>Ptr</code>.</p>
<p><b>Note that value types are passed by value, meaning that the data is copied between nodes. Modifying the local data wil not change the remote data. The modified data must be sent using a member.</b></p>
<h1><a class="anchor" id="cpp_null_pointers"></a>
Null Pointers</h1>
<p>The <code>boost::intrusive_ptr</code> can contain <code>nullptr</code>. An attempt to dereference a <code>nullptr</code> will result in a segmentation fault, which will typically immediately terminate the program. The <a class="el" href="_data_types_8h.html#ad39a4a2e1e88cc92ff0877ca57b54203" title="Checks if a value RR_INTRUSIVE_PTR is null.">RobotRaconteur::rr_null_check()</a> can be used to check if a smart pointer. is null. It will throw RobotRaconteur::NullReferenceException if the pointer is <code>nullptr</code>.</p>
<h1><a class="anchor" id="cpp_boxing"></a>
Boxing</h1>
<p>Container types like <code>map</code> and <code>list</code>, and <code>varvalue</code> can only store types inheritin from <a class="el" href="class_robot_raconteur_1_1_r_r_value.html" title="Base class for all Robot Raconteur value types (except primitives)">RobotRaconteur::RRValue</a> and stored in a <code>boost::intrusive_ptr</code>. Since some value types are stored on the stack instead of in a smart pointer, these types cannot be stored in the container types. These values must be "boxed", meaning they are converted to a form that con be stored in the container. The procedure to box and unbox types when required is discussed for each type.</p>
<h1><a class="anchor" id="cpp_numeric_types"></a>
Numeric Types and Arrays</h1>
<p>Robot Raconteur supports floating point, integer, unsigned integer, complex, and logical types as shown in the table above. Floating point numbers use <code>double</code> and <code>float</code>. Integer types use types defined in <code>&lt;stdint.h&gt;</code>. Complex numbers use <a class="el" href="struct_robot_raconteur_1_1cdouble.html" title="Complex double precision floating point number.">RobotRaconteur::cdouble</a> and RobotRaconteur::csingle. Logical values use <a class="el" href="struct_robot_raconteur_1_1rr__bool.html" title="Logical boolean represented using 8 bits.">RobotRaconteur::rr_bool</a>.</p>
<p>Scalar values use stack allocated, and are not stored using pointers are smart pointers. Some example declarations: </p><pre class="fragment">using namespace RobotRaconteur;
int32_t a = 1;
double b = 1.234;
cdouble c = (1.23,4.56);
</pre><p>Numeric arrays are stored using <a class="el" href="class_robot_raconteur_1_1_r_r_array.html" title="Numeric primitive or character array value type.">RobotRaconteur::RRArray</a>, with smart pointer alias RobotRaconteur::RRArrayPtr. <a class="el" href="class_robot_raconteur_1_1_r_r_array.html" title="Numeric primitive or character array value type.">RobotRaconteur::RRArray</a> must always be stored in a smart pointer. <a class="el" href="class_robot_raconteur_1_1_r_r_array.html" title="Numeric primitive or character array value type.">RobotRaconteur::RRArray</a> is similar to <code>std::array&lt;T&gt;</code>, and implements most of the C++ container concept.</p>
<p>RobotRaconteur::RRArrayPtr is allocated using <a class="el" href="_data_types_8h.html#a4149f98ecc18cb90323cfb15aeb50c1b" title="Allocate a numeric primitive or character array with the specified type and length.">RobotRaconteur::AllocateRRArray()</a>, <a class="el" href="_data_types_8h.html#a9ed83f734de5fbc206a03b0a79efab89" title="Allocates an array object and attaches to existing numeric primitive or character array pointer.">RobotRaconteur::AttachRRArray()</a>, <a class="el" href="_data_types_8h.html#a5e9d0ffb52f459dd1e0b7ea17fcc9e45" title="Allocates an array object and copies existing numeric.">RobotRaconteur::AttachRRArrayCopy()</a>, <a class="el" href="_data_types_8h.html#a4d05366e8f0fdd137216c7f8e205f93c" title="Allocate an RRBaseArray by type code.">RobotRaconteur::AllocateRRArrayByType()</a>, or <a class="el" href="_data_types_8h.html#a13c2c3133bd7d95129d15c9852727356" title="Allocate a numeric primitive or character array with the specified type and length and initialize to ...">AllocateEmptyRRArray()</a>. The most commonly used are <a class="el" href="_data_types_8h.html#a9ed83f734de5fbc206a03b0a79efab89" title="Allocates an array object and attaches to existing numeric primitive or character array pointer.">RobotRaconteur::AttachRRArray()</a> and <a class="el" href="_data_types_8h.html#a5e9d0ffb52f459dd1e0b7ea17fcc9e45" title="Allocates an array object and copies existing numeric.">RobotRaconteur::AttachRRArrayCopy()</a>. A few examples: </p><pre class="fragment">using namespace RobotRaconteur;
RRArrayPtr&lt;double&gt; my_array1 = AllocateRRArray&lt;double&gt;(10);
RRArrayPtr&lt;cdouble&gt; = my_array2 = AllocateRREmptyArray(16);

double existing_data[4] = {1.1, 2.2, 3.3, 4.4};
RRArrayPtr&lt;double&gt; my_array3 = AttachRRArrayCopy(existing_data, 4);
</pre><p>Once the array is allocated, it can be used the same as a <code>std::array&lt;T&gt;*</code> type. </p><pre class="fragment">double v1 = my_array1-&gt;at(0);
double v2 = (*my_array1)[1];
my_array1-&gt;at(2) = 5.5;
(*my_array1)[3] = 6.6;
double* my_array1_raw = my_array1-&gt;data();
</pre><p><a class="el" href="class_robot_raconteur_1_1_r_r_array.html" title="Numeric primitive or character array value type.">RobotRaconteur::RRArray</a> implements <code>begin()</code> and <code>end()</code>, so it can be used as an STL container. </p><pre class="fragment">for (double v : *my_array)
{
    // Use v
}
</pre><p>Becaue RobotRaconteur::RRArrayPtr is a smart pointer, the allocated memory is destroyed automatically.</p>
<p>Multidimensional arrays stored using <a class="el" href="class_robot_raconteur_1_1_r_r_multi_dim_array.html" title="Numeric primitive multidimensional array value type.">RobotRaconteur::RRMultiDimArray</a>. This type has two fields, <code>Dims</code> and <code>Array</code>. The <code>Dims</code> field contains the shape of the array, in column-major order. The <code>Array</code> field contains the array element data, stored in column-major (Fortran) order. RobotRaconteur::RRMultiDimArrayPtr is allocated using <a class="el" href="_data_types_8h.html#a88b8c7525de7c81f26f9f65c6169929a" title="Allocate a multidimensional using existing dimensions and data array.">RobotRaconteur::AllocateRRMultiDimArray()</a> or <a class="el" href="_data_types_8h.html#aea64bf03b419e199f2819c29bbb72da1" title="Allocate an empty multidimensional array with the specified dimensions.">RobotRaconteur::AllocateEmptyRRMultiDimArray()</a>. An examples: </p><pre class="fragment">using namespace RobotRaconteur;
std::vector&lt;uint32_t&gt; dims = {3,3};
RRMultiDimArrayPtr&lt;double&gt; my_multidimarray = AllocateEmptyRRMultiDimArray&lt;double&gt;(dims);
</pre><p>RRArray and RRMultiDimArray are non-nullable, meaning that they cannot be <code>nullptr</code>. If a <code>nullptr</code> of this type is passed to a member, it will result in an error.</p>
<h2>Numeric Types Boxing</h2>
<p>Scalar numbers cannot be stored in containers because they are stack allocated types. The functions <a class="el" href="_data_types_8h.html#a43d3d8aad3e6a133d112e787908aa84b" title="Convert a scalar number into an array with one element.">RobotRaconteur::ScalarToRRArray()</a> and <a class="el" href="_data_types_8h.html#a17314515c5cf80f2835f3fbfcbf0b065" title="Convert an array with one element into a scalar.">RobotRaconteur::RRArrayToScalar()</a> are used to box and unbox scalars. They convert scalars to and from single element arrays.</p>
<h1><a class="anchor" id="cpp_string_types"></a>
Strings</h1>
<p>Strings are stored as <code>std::string</code>. Strings are always UTF-8 formatted. When passed as parameters, <code>const std::string&amp;</code> is used to prevent making a copy.</p>
<p>Strings cannot be stored in an array or multidimarray. They can be stored in <code>list</code> and <code>map</code> when boxed.</p>
<h2>String Boxing</h2>
<p><code>std::string</code> cannot be stored in container types since it does not inheret from <a class="el" href="class_robot_raconteur_1_1_r_r_value.html" title="Base class for all Robot Raconteur value types (except primitives)">RobotRaconteur::RRValue</a>. The boxed type for strings is <code>RobotRaconteur::RRArrayPtr&lt;char&gt;</code>. Use <a class="el" href="_data_types_8h.html#a1bcc38fd0615caff60b1d91c7261e1f0" title="Convert a string to an array of characters.">RobotRaconteur::stringToRRArray()</a> and <a class="el" href="_data_types_8h.html#ab08c02e746aa7a5323c65a9b5374eb06" title="Convert an array of characters into std::string.">RobotRaconteur::RRArrayToString()</a> to box and unbox <code>std::string</code>.</p>
<p>Strings are non-nullable, meaning that <code>RRArrayPtr&lt;char&gt;</code> cannot be <code>nullptr</code>. If a <code>nullptr</code> of this type is passed to a member, it will result in an error.</p>
<h1><a class="anchor" id="cpp_structure_types"></a>
Structure Types</h1>
<p>Structure types are defined in service definitions using the <code>struct</code> keyword. See <a class="el" href="service_definition.html">Service Definitions</a> for more information on <code>struct</code> definitions. The implementation for structure types defined in service definitions are generated by <code>RobotRaconteurGen</code> as part of the thunk source. Structures are always heap allocated, and use <code>boost::intrusive_ptr</code> smart pointer. The thunk source includes a *<code>Ptr</code> convenience aliases for structure types.</p>
<p>Structures can store any valid Robot Raconteur value type, including itself. Structures may not be stored in arrays or multidimarrays, but may be stored in <code>list</code> and <code>map</code> types.</p>
<p>Structure types must be created using <code>new</code> and stored in a smart pointer. Consider the following example structure definition: </p><pre class="fragment">service experimental.struct_example

struct MyStruct
    field double a
    field double[] b
end
</pre><p>To create and use in C++: </p><pre class="fragment">experimental::struct_example::MyStructPtr my_struct(new experimental::struct_example::MyStruct());

my_struct-&gt;a = 10;
my_struct-&gt;b = AllocateRRArray&lt;double&gt;(10);
my_struct-&gt;b-&gt;at(2) = 5.7;
</pre><p>Struct types do not require boxing.</p>
<p>Struture types are nullable. <a class="el" href="_data_types_8h.html#ad39a4a2e1e88cc92ff0877ca57b54203" title="Checks if a value RR_INTRUSIVE_PTR is null.">RobotRaconteur::rr_null_check()</a> should be used to test for a null structure before use if it is being received from a remote node.</p>
<h1><a class="anchor" id="cpp_pod_types"></a>
Pod Types</h1>
<p>Pod types are defined in service definitions using the keyword <code>pod</code>. See <a class="el" href="service_definition.html">Service Definitions</a> for more information an <code>pod</code> definitions. Pods are similar in concept to structures, except that they are stack allocated types, with the memory for all fields local to the pod. Pointers are not used to store field data. Instead, the storage memory is in-line with the pod itself. Pod arrays are stored in a contiguous c-style array, with one pod following the other in memory. In C++, this is referred to as "plain-old-data", hence the keyword <code>pod</code>. Pods are always the same size.</p>
<p>The implementation for pod types defined in service definitions are generated by <code>RobotRaconteurGen</code> as part of the thunk source. Pods may be stored in arrays using <a class="el" href="class_robot_raconteur_1_1_r_r_pod_array.html" title="pod array value type">RobotRaconteur::RRPodArray</a> and <a class="el" href="class_robot_raconteur_1_1_r_r_pod_multi_dim_array.html" title="pod multidimensional array value type">RobotRaconteur::RRPodMultiDimArray</a>. These types operate the same as <a class="el" href="class_robot_raconteur_1_1_r_r_array.html" title="Numeric primitive or character array value type.">RobotRaconteur::RRArray</a> and <a class="el" href="class_robot_raconteur_1_1_r_r_multi_dim_array.html" title="Numeric primitive multidimensional array value type.">RobotRaconteur::RRMultiDimArray</a>, but store pods instead of numeric types. They are allocated using <a class="el" href="_data_types_8h.html#af153b6f6abf6a916f8f33411721ff82a" title="Allocate a pod array with the specified type and length and initialize to zero.">RobotRaconteur::AllocateEmptyRRPodArray()</a> and <a class="el" href="_data_types_8h.html#a2c0c148dd7c77dd58389fb2e4a10112b" title="Allocate an empty multidimensional pod array with the specified dimensions.">RobotRaconteur::AllocateEmptyRRPodMultiDimArray()</a>.</p>
<p>Pods can contain numeric types, numeric arrays with fixed or maximum length, fixed shape numeric multidimarrays, other pods, other pod arrays with fixed or maximum length, fixed shape pod multidimarrays, namedarrays, namedarrays arrays with fixed or maximum length, and fixed shape namedarray multidimarrays.</p>
<p>Array fields for pods are implemented in C++ using the <a class="el" href="class_robot_raconteur_1_1pod__field__array.html" title="Storage for pod array fields.">RobotRaconteur::pod_field_array</a> structure. This structure is stack allocated, keeping the storage memory local to where it is used. It has a fixed length. For variable maximum size arrays, the memory is always allocated for the full size array, and a separate value tracks the current length. <a class="el" href="class_robot_raconteur_1_1pod__field__array.html" title="Storage for pod array fields.">RobotRaconteur::pod_field_array</a> behaves identically to <code>std::array</code> when fixed length, and only changes in having a variable size up to a maximum value when not fixed. <code>resize()</code> and <code>size()</code> is used to change and read the size. Multidimarrays are stored as flattened arrays in column-major order.</p>
<h2>Pod Boxing</h2>
<p>Because scalar pods are stack allocated, they cannot be stored in containers or passed as <code>varvalue</code>. The functions <a class="el" href="_data_types_8h.html#a7e068d5afdfa304c4e5b0d28a97823b4" title="Convert a scalar pod into a pod array with one element.">RobotRaconteur::ScalarToRRPodArray()</a> and <a class="el" href="_data_types_8h.html#aa9d8abfbb9779d1f43ec0ec25f8f4339" title="Convert a pod array with one element into a scalar pod.">RobotRaconteur::RRPodArrayToScalar()</a> are used to box and unbox scalar pods. They convert scalar pods to and from single element pod arrays.</p>
<h1><a class="anchor" id="cpp_namedarray_types"></a>
Namedarray Types</h1>
<p>Pod types are defined in service definitions using the keyword <code>namedarray</code>. See <a class="el" href="service_definition.html">Service Definitions</a> for more information an <code>namedarray</code> definitions. Namedarrays are used when data can be interpreted as either a structure or an array. An example is a three element vector. It can be interpreted as a structure with (x,y,z), or as a three element array. The numeric type in a namedarray must be the same for all fields. In C++, <code>union</code> types to represent namedarray. (Note that <code>union</code> types are stack allocated.) An example of the union type for a three element vector defined in a service definition as: </p><pre class="fragment">namedarray
    field double x
    field double y
    field double z
end
</pre><p>Is implemented as: </p><pre class="fragment">union Vector3
{
    double a[3];
    struct s_type {
        double x;
        double y;
        double z;
    } s;
};
</pre><p>In this example, the union has two fields. Field <code>a</code> is a three element array, while field <code>s</code> is a structure with fields <code>x</code>, <code>y</code>, and <code>z</code>. The union store <code>a</code> and <code>s</code> in the same memory region, meaning that accessing an array element in <code>a</code> is equivalent to accessing a field in <code>s</code>. For example: </p><pre class="fragment">Vector3 my_vector;
my_vector.s.y = 2;
assert(my_vector.a[1] == 2) // true!
</pre><p><code>my_vector.s.y</code> is stored in the same memory location as <code>my_vector.a[1]</code> because of the use of a union.</p>
<p>Namedarray may contain fixed length numeric arrays, other namedarray, and other namedarray fixed length arrays. The numeric type of the other namedarrays must match the namedarray field type. When arrays are used as a field within a named array, a c-style array is used. For example: </p><pre class="fragment">namedarray MyNamedArray1
    field double a
    field double[3] b
end
</pre><p>Will have the implementation: </p><pre class="fragment">union MyNamedArray1
{
    double a[4];
    struct s_type {
        double a;
        double[3] b;
    } s;
};
</pre><p>Arrays of namedarray may be stored in <a class="el" href="class_robot_raconteur_1_1_r_r_named_array.html" title="namedarray array value type">RobotRaconteur::RRNamedArray</a> and <a class="el" href="class_robot_raconteur_1_1_r_r_named_multi_dim_array.html" title="namedarray multidimensional array value type">RobotRaconteur::RRNamedMultiDimArray</a>. They are allocated using <a class="el" href="_data_types_8h.html#a1146ae4cfd198fd000c1480ef8bd87ae" title="Allocate a namedarray array with the specified type and length and initialize to zero.">RobotRaconteur::AllocateEmptyRRNamedArray()</a> and <a class="el" href="_data_types_8h.html#acec122d8495f223cc0e180c4cafa559f" title="Allocate an empty multidimensional namedarray array with the specified dimensions.">RobotRaconteur::AllocateEmptyRRNamedMultiDimArray()</a>. The functions <a class="el" href="class_robot_raconteur_1_1_r_r_named_array.html#a5630256139ab4427a972a04a2156dd80" title="get the underlying numeric RRArray">RobotRaconteur::RRNamedArray::GetNumericArray()</a> can be used to retrieve the entire array as a flattened numeric array. The constructor <a class="el" href="class_robot_raconteur_1_1_r_r_named_array.html#a18a2ef0ab3c9bc44b8dff72bbc5718e5" title="Construct a RRNamedArray object.">RobotRaconteur::RRNamedArray::RRNamedArray()</a> can be used to provide an existing array to store the array data. The <a class="el" href="class_robot_raconteur_1_1_r_r_named_array.html" title="namedarray array value type">RobotRaconteur::RRNamedArray</a> provides a union view to the existing data.</p>
<h2>Namedarray Boxing</h2>
<p>Because unions are stack allocated, they cannot be stored in containers or passed as <code>varvalue</code>. The functions <a class="el" href="_data_types_8h.html#a32ef2c95a6d82cf74f7a206e25f4f4be" title="Convert a scalar namedarray into a namedarray array with one element.">RobotRaconteur::ScalarToRRNamedArray()</a> and <a class="el" href="_data_types_8h.html#ab7db13de3164cec51054563254cbd79d" title="Convert a namedarray array with one element into a namedarray.">RobotRaconteur::RRNamedArrayToScalar()</a> are used to box and unbox namedarray unions. They convert unions to and from single element namedarray arrays.</p>
<h1><a class="anchor" id="cpp_container_types"></a>
Map and List Container Types</h1>
<p>Containers are used to store other values in a map or a list. They can store any valid Robot Raconteur value type, except for other containers. For example, <code>string{list}{list}</code> is invalid because it contains a container of a container. (The exception to this rule is if the container is used as a <code>varvalue</code>, see below.) The value type is always a <code>boost::intrusive_ptr</code> type. Stack allocated scalar types must be "boxed" to convert them to a form that can be stored in containers. See the individual types for more information.</p>
<p>Maps are stored using <a class="el" href="class_robot_raconteur_1_1_r_r_map.html" title="Map container value type.">RobotRaconteur::RRMap</a>. This type must always be stored in a <code>boost::intrusive_ptr</code>, optionally using the convenience alias RobotRaconteur::RRMapPtr. <a class="el" href="class_robot_raconteur_1_1_r_r_map.html" title="Map container value type.">RobotRaconteur::RRMap</a> is a template type, taking a key and a value. The key must be either <code>int32_t</code> or <code>std::string</code>. <a class="el" href="class_robot_raconteur_1_1_r_r_map.html" title="Map container value type.">RobotRaconteur::RRMap</a> is roughly equevalent to <code>std::map</code>. It can be allocated using <a class="el" href="_data_types_8h.html#a2b0f865211eb5fcb0ed65f2e5c098ba7" title="Allocate an empty RRMap.">RobotRaconteur::AllocateEmptyRRMap()</a>.</p>
<p>Lists are stored using <a class="el" href="class_robot_raconteur_1_1_r_r_list.html" title="List container value type.">RobotRaconteur::RRList</a>. This type must always be stored in a <code>boost::intrusive_ptr</code>, optionally using the convenience alias RobotRaconteur::RRListPtr. <a class="el" href="class_robot_raconteur_1_1_r_r_list.html" title="List container value type.">RobotRaconteur::RRList</a> is a template type with a single value type template parameter.RobotRaconteur::RRMap is roughly equevalent to <code>std::list</code>. It can be allocated using <a class="el" href="_data_types_8h.html#a74cc61585f642d80095caf9f4d4d0707" title="Allocate an empty RRList.">RobotRaconteur::AllocateEmptyRRList()</a>.</p>
<h1><a class="anchor" id="cpp_varvalue_type"></a>
Varvalue Type</h1>
<p>The varvalue type is used with service members to declare a "wildcard" parameter or packet type. It uses <a class="el" href="class_robot_raconteur_1_1_r_r_value.html" title="Base class for all Robot Raconteur value types (except primitives)">RobotRaconteur::RRValue</a> for storage. This type must always be stored in <code>boost::intrusive_ptr</code>, optionally using the convenience alias RobotRaconteur::RRValuePtr. Scalar types must be "boxed" to be stored as varvalue. See the individual types for more information.</p>
<p>The <a class="el" href="class_robot_raconteur_1_1_r_r_value.html" title="Base class for all Robot Raconteur value types (except primitives)">RobotRaconteur::RRValue</a> must be downcasted to be used. This can be accomplished using <code>boost::dynamic_pointer_cast</code>. This function will attempt to cast the pointer, returning <code>nullptr</code> if the cast is invalid. For instance, assume that the function <code>get_a()</code> returns a varvalue. Use <code>boost::dynamic_pointer_cast</code> to determine what type it is: </p><pre class="fragment">using namespace RobotRaconteur;
RRValuePtr a = client-&gt;get_a();
RRArrayPtr&lt;double&gt; a_double = boost::dynamic_pointer_cast&lt;RRArray&lt;double&gt; &gt;(a);
if (a_double)
{
    // Do something with a_double
}
RRArrayPtr&lt;char&gt; a_char = boost::dynamic_pointer_cast&lt;RRArray&lt;char&gt; &gt;(a);
if (a_char)
{
    std::string a_string = RRArrayToString(a_char);
    // Do something with a_string
}

// Oops, unexpected type returned!
throw InvalidOperationException("Unexpected varvalue type");
</pre><p><code>varvalue</code> may also be declared as a container type. The following table shows the corresponding C++ type:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Robot Raconteur Type  </th><th class="markdownTableHeadNone">C++ Type   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>varvalue</code>  </td><td class="markdownTableBodyNone"><code>RRValuePtr</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>varvalue{list}</code>  </td><td class="markdownTableBodyNone"><code>RRListPtr&lt;RRValue&gt;</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>varvalue{int32}</code>  </td><td class="markdownTableBodyNone"><code>RRMapPtr&lt;int32_t,RRValue&gt;</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>varvalue{string}</code>  </td><td class="markdownTableBodyNone"><code>RRMapPtr&lt;string,RRValue&gt;</code>   </td></tr>
</table>
<p>Containers passed with <code>varvalue</code> may contain other containers. The prohibiton of containers containing other containers is only for declared types. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
