<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: RobotRaconteur::Wire&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>RobotRaconteur</b></li><li class="navelem"><a class="el" href="class_robot_raconteur_1_1_wire.html">Wire</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_robot_raconteur_1_1_wire-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RobotRaconteur::Wire&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>wire</code> member type interface  
 <a href="class_robot_raconteur_1_1_wire.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for RobotRaconteur::Wire&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_robot_raconteur_1_1_wire.png" usemap="#RobotRaconteur::Wire_3C_20T_20_3E_map" alt=""/>
  <map id="RobotRaconteur::Wire_3C_20T_20_3E_map" name="RobotRaconteur::Wire_3C_20T_20_3E_map">
<area href="class_robot_raconteur_1_1_wire_base.html" title="Base class for Wire." alt="RobotRaconteur::WireBase" shape="rect" coords="0,0,165,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17c46121987ecbcfbc0ebc1c1c5636e5"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a17c46121987ecbcfbc0ebc1c1c5636e5">Connect</a> ()=0</td></tr>
<tr class="memdesc:a17c46121987ecbcfbc0ebc1c1c5636e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the wire.  <a href="class_robot_raconteur_1_1_wire.html#a17c46121987ecbcfbc0ebc1c1c5636e5">More...</a><br /></td></tr>
<tr class="separator:a17c46121987ecbcfbc0ebc1c1c5636e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5660e1ff3c73de101f165e62604788"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a5f5660e1ff3c73de101f165e62604788">AsyncConnect</a> (boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt; T &gt; &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)=0</td></tr>
<tr class="memdesc:a5f5660e1ff3c73de101f165e62604788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously connect the wire.  <a href="class_robot_raconteur_1_1_wire.html#a5f5660e1ff3c73de101f165e62604788">More...</a><br /></td></tr>
<tr class="separator:a5f5660e1ff3c73de101f165e62604788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c25221a14e5f3f0387ac0340ec74e1"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1">PeekInValue</a> (<a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;ts)=0</td></tr>
<tr class="memdesc:a14c25221a14e5f3f0387ac0340ec74e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the current InValue.  <a href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1">More...</a><br /></td></tr>
<tr class="separator:a14c25221a14e5f3f0387ac0340ec74e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc93665e6f76b2644a79abbbbe9c7784"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784">PeekOutValue</a> (<a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;ts)=0</td></tr>
<tr class="memdesc:afc93665e6f76b2644a79abbbbe9c7784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the current OutValue.  <a href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784">More...</a><br /></td></tr>
<tr class="separator:afc93665e6f76b2644a79abbbbe9c7784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecad256fef31978596e8f37cbb7fd06e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e">PokeOutValue</a> (const T &amp;value)=0</td></tr>
<tr class="memdesc:aecad256fef31978596e8f37cbb7fd06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poke the OutValue.  <a href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e">More...</a><br /></td></tr>
<tr class="separator:aecad256fef31978596e8f37cbb7fd06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c2fc09751710f2fb86e723a820aad8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#ad0c2fc09751710f2fb86e723a820aad8">AsyncPeekInValue</a> (boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)=0</td></tr>
<tr class="memdesc:ad0c2fc09751710f2fb86e723a820aad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously peek the current InValue.  <a href="class_robot_raconteur_1_1_wire.html#ad0c2fc09751710f2fb86e723a820aad8">More...</a><br /></td></tr>
<tr class="separator:ad0c2fc09751710f2fb86e723a820aad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed1f7d8613e2241d3376685aa646e27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#aeed1f7d8613e2241d3376685aa646e27">AsyncPeekOutValue</a> (boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)=0</td></tr>
<tr class="memdesc:aeed1f7d8613e2241d3376685aa646e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously peek the current OutValue.  <a href="class_robot_raconteur_1_1_wire.html#aeed1f7d8613e2241d3376685aa646e27">More...</a><br /></td></tr>
<tr class="separator:aeed1f7d8613e2241d3376685aa646e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c05b679ccdb91253648a455b13722cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a6c05b679ccdb91253648a455b13722cf">AsyncPokeOutValue</a> (const T &amp;value, boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;handler, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)=0</td></tr>
<tr class="memdesc:a6c05b679ccdb91253648a455b13722cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously poke the OutValue.  <a href="class_robot_raconteur_1_1_wire.html#a6c05b679ccdb91253648a455b13722cf">More...</a><br /></td></tr>
<tr class="separator:a6c05b679ccdb91253648a455b13722cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e4483ec35f68a82fcc1a3e341fdc2"><td class="memItemLeft" align="right" valign="top">virtual boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt; T &gt; &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a2c3e4483ec35f68a82fcc1a3e341fdc2">GetWireConnectCallback</a> ()=0</td></tr>
<tr class="memdesc:a2c3e4483ec35f68a82fcc1a3e341fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently configured wire connected callback function.  <a href="class_robot_raconteur_1_1_wire.html#a2c3e4483ec35f68a82fcc1a3e341fdc2">More...</a><br /></td></tr>
<tr class="separator:a2c3e4483ec35f68a82fcc1a3e341fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d58b49df1160676ebe362b47d4ff8d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a89d58b49df1160676ebe362b47d4ff8d">SetWireConnectCallback</a> (boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt; T &gt; &gt;)&gt; function)=0</td></tr>
<tr class="memdesc:a89d58b49df1160676ebe362b47d4ff8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set wire connected callback function.  <a href="class_robot_raconteur_1_1_wire.html#a89d58b49df1160676ebe362b47d4ff8d">More...</a><br /></td></tr>
<tr class="separator:a89d58b49df1160676ebe362b47d4ff8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f841187f4297f315ba5ace6ccf42488"><td class="memItemLeft" align="right" valign="top">virtual boost::function&lt; T(const uint32_t &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a6f841187f4297f315ba5ace6ccf42488">GetPeekInValueCallback</a> ()=0</td></tr>
<tr class="memdesc:a6f841187f4297f315ba5ace6ccf42488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently configure PeekInValue callback.  <a href="class_robot_raconteur_1_1_wire.html#a6f841187f4297f315ba5ace6ccf42488">More...</a><br /></td></tr>
<tr class="separator:a6f841187f4297f315ba5ace6ccf42488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cf20b646bcebbdc28a5738b72f95dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a40cf20b646bcebbdc28a5738b72f95dc">SetPeekInValueCallback</a> (boost::function&lt; T(const uint32_t &amp;)&gt; function)=0</td></tr>
<tr class="memdesc:a40cf20b646bcebbdc28a5738b72f95dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PeekInValue callback function.  <a href="class_robot_raconteur_1_1_wire.html#a40cf20b646bcebbdc28a5738b72f95dc">More...</a><br /></td></tr>
<tr class="separator:a40cf20b646bcebbdc28a5738b72f95dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b64d55e1a1ed53f06a967bcb7dedfb"><td class="memItemLeft" align="right" valign="top">virtual boost::function&lt; T(const uint32_t &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a52b64d55e1a1ed53f06a967bcb7dedfb">GetPeekOutValueCallback</a> ()=0</td></tr>
<tr class="memdesc:a52b64d55e1a1ed53f06a967bcb7dedfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently configure PeekOutValue callback.  <a href="class_robot_raconteur_1_1_wire.html#a52b64d55e1a1ed53f06a967bcb7dedfb">More...</a><br /></td></tr>
<tr class="separator:a52b64d55e1a1ed53f06a967bcb7dedfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150ead6b19f631801564c3c854ff335"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#ab150ead6b19f631801564c3c854ff335">SetPeekOutValueCallback</a> (boost::function&lt; T(const uint32_t &amp;)&gt; function)=0</td></tr>
<tr class="memdesc:ab150ead6b19f631801564c3c854ff335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PeekOutValue callback function.  <a href="class_robot_raconteur_1_1_wire.html#ab150ead6b19f631801564c3c854ff335">More...</a><br /></td></tr>
<tr class="separator:ab150ead6b19f631801564c3c854ff335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e926a4fe5fbdfa9b54edd99f5fef6d"><td class="memItemLeft" align="right" valign="top">virtual boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, const uint32_t &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a12e926a4fe5fbdfa9b54edd99f5fef6d">GetPokeOutValueCallback</a> ()=0</td></tr>
<tr class="memdesc:a12e926a4fe5fbdfa9b54edd99f5fef6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently configure PokeOutValue callback.  <a href="class_robot_raconteur_1_1_wire.html#a12e926a4fe5fbdfa9b54edd99f5fef6d">More...</a><br /></td></tr>
<tr class="separator:a12e926a4fe5fbdfa9b54edd99f5fef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ddf6dc449ab7ef31ce0e178dd9c3c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire.html#a91ddf6dc449ab7ef31ce0e178dd9c3c9">SetPokeOutValueCallback</a> (boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, const uint32_t &amp;)&gt; function)=0</td></tr>
<tr class="memdesc:a91ddf6dc449ab7ef31ce0e178dd9c3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PokeOutValue callback function.  <a href="class_robot_raconteur_1_1_wire.html#a91ddf6dc449ab7ef31ce0e178dd9c3c9">More...</a><br /></td></tr>
<tr class="separator:a91ddf6dc449ab7ef31ce0e178dd9c3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1491278d75142b49bba8bc90832f1fa9"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire_base.html#a1491278d75142b49bba8bc90832f1fa9">GetMemberName</a> ()=0</td></tr>
<tr class="memdesc:a1491278d75142b49bba8bc90832f1fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the member name of the wire.  <a href="class_robot_raconteur_1_1_wire_base.html#a1491278d75142b49bba8bc90832f1fa9">More...</a><br /></td></tr>
<tr class="separator:a1491278d75142b49bba8bc90832f1fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dd99dc1f894fb1981006fe6e1c0f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_robot_raconteur_constants_8h.html#a7420bbe1689d74c66948017ba2d27373">MemberDefinition_Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_wire_base.html#a45dd99dc1f894fb1981006fe6e1c0f17">Direction</a> ()</td></tr>
<tr class="memdesc:a45dd99dc1f894fb1981006fe6e1c0f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of the wire.  <a href="class_robot_raconteur_1_1_wire_base.html#a45dd99dc1f894fb1981006fe6e1c0f17">More...</a><br /></td></tr>
<tr class="separator:a45dd99dc1f894fb1981006fe6e1c0f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class RobotRaconteur::Wire&lt; T &gt;</h3>

<p><code>wire</code> member type interface </p>
<p>The <a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">Wire</a> class implements the <code>wire</code> member type. Wires are declared in service definition files using the <code>wire</code> keyword within object declarations. Wires provide "most recent" value streaming between clients and services. They work by creating "connection" pairs between the client and service. The wire streams the current value between the wire connection pairs using packets. Wires are unreliable; only the most recent value is of interest, and any older values will be dropped. <a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">Wire</a> connections have an InValue and an OutValue. Users set the OutValue on the connection. The new OutValue is transmitted to the peer wire connection, and becomes the peer's InValue. The peer can then read the InValue. The client and service have their own InValue and OutValue, meaning that each direction, client to service or service to client, has its own value.</p>
<p><a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">Wire</a> connections are created using the <a class="el" href="class_robot_raconteur_1_1_wire.html#a17c46121987ecbcfbc0ebc1c1c5636e5" title="Connect the wire.">Connect()</a> or <a class="el" href="class_robot_raconteur_1_1_wire.html#a5f5660e1ff3c73de101f165e62604788" title="Asynchronously connect the wire.">AsyncConnect()</a> functions. Services receive incoming connection requests through a callback function. Thes callback is configured using the <a class="el" href="class_robot_raconteur_1_1_wire.html#a89d58b49df1160676ebe362b47d4ff8d" title="Set wire connected callback function.">SetWireConnectCallback()</a> function. Services may also use the <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> class or <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a> class to automate managing wire connection lifecycles. <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> is used to send values to all connected clients. <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a> is used to receive the value from the most recent wire connection. See <a class="el" href="class_robot_raconteur_1_1_wire_connection.html" title="Wire connection used to transmit &quot;most recent&quot; values.">WireConnection</a> for details on sending and receiving streaming values.</p>
<p><a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">Wire</a> clients may also optionally "peek" and "poke" the wire without forming a streaming connection. This is useful if the client needs to read the InValue or set the OutValue instantaniously, but does not need continuous updating. <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a> or <a class="el" href="class_robot_raconteur_1_1_wire.html#ad0c2fc09751710f2fb86e723a820aad8" title="Asynchronously peek the current InValue.">AsyncPeekInValue()</a> will retrieve the client's current InValue. <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a> or <a class="el" href="class_robot_raconteur_1_1_wire.html#a6c05b679ccdb91253648a455b13722cf" title="Asynchronously poke the OutValue.">AsyncPokeOutValue()</a> will send a new client OutValue to the service. <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a> or <a class="el" href="class_robot_raconteur_1_1_wire.html#aeed1f7d8613e2241d3376685aa646e27" title="Asynchronously peek the current OutValue.">AsyncPeekOutValue()</a> will retrieve the last client OutValue received by the service.</p>
<p>"Peek" and "poke" operations initiated by the client are received on the service using callbacks. Use <a class="el" href="class_robot_raconteur_1_1_wire.html#a40cf20b646bcebbdc28a5738b72f95dc" title="Set the PeekInValue callback function.">SetPeekInValueCallback()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#ab150ead6b19f631801564c3c854ff335" title="Set the PeekOutValue callback function.">SetPeekOutValueCallback()</a>, and <a class="el" href="class_robot_raconteur_1_1_wire.html#a91ddf6dc449ab7ef31ce0e178dd9c3c9" title="Set the PokeOutValue callback function.">SetPokeOutValueCallback()</a> to configure the callbacks to handle these requests. <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> and <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a> configure these callbacks automatically, so the user does not need to configure the callbacks when these classes are used.</p>
<p>Wires can be declared <em>readonly</em> or <em>writeonly</em>. If neither is specified, the wire is assumed to be full duplex. <em>readonly</em> pipes may only send values from service to client, ie OutValue on service side and InValue on client side. <em>writeonly</em> pipes may only send values from client to service, ie OutValue on client side and InValue on service side. Use <a class="el" href="class_robot_raconteur_1_1_wire_base.html#a45dd99dc1f894fb1981006fe6e1c0f17" title="The direction of the wire.">Direction()</a> to determine the direction of the wire.</p>
<p>Unlike pipes, wire connections are not indexed, so only one connection pair can be created per client connection.</p>
<p><a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> or <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a> are typically used to simplify using wires. See <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> and <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a> for more information.</p>
<p>This class is instantiated by the node. It should not be instantiated by the user.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value data type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5f5660e1ff3c73de101f165e62604788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5660e1ff3c73de101f165e62604788">&#9670;&nbsp;</a></span>AsyncConnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::AsyncConnect </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt; T &gt; &gt;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously connect the wire. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_wire.html#a17c46121987ecbcfbc0ebc1c1c5636e5" title="Connect the wire.">Connect()</a>, but returns asynchronously</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler function to receive the wire connection, or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0c2fc09751710f2fb86e723a820aad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c2fc09751710f2fb86e723a820aad8">&#9670;&nbsp;</a></span>AsyncPeekInValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::AsyncPeekInValue </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously peek the current InValue. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a>, but returns asynchronously.</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler function to receive the InValue and timestamp, or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed1f7d8613e2241d3376685aa646e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed1f7d8613e2241d3376685aa646e27">&#9670;&nbsp;</a></span>AsyncPeekOutValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::AsyncPeekOutValue </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously peek the current OutValue. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a>, but returns asynchronously.</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler function to receive the OutValue and timestamp, or an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c05b679ccdb91253648a455b13722cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c05b679ccdb91253648a455b13722cf">&#9670;&nbsp;</a></span>AsyncPokeOutValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::AsyncPokeOutValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously poke the OutValue. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a>, but returns asynchronously</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler function to invoke on completion, with possible exception </td></tr>
    <tr><td class="paramname">value</td><td>The new OutValue </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c46121987ecbcfbc0ebc1c1c5636e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c46121987ecbcfbc0ebc1c1c5636e5">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt;T&gt; &gt; <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::Connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the wire. </p>
<p>Creates a connection between the wire, returning the client connection. Used to create a "most recent" value streaming connection to the service.</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<p>Note: If a streaming connection is not required, use <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a>, or <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a> instead of creating a connection.</p>
<dl class="section return"><dt>Returns</dt><dd>RR_SHARED_PTR&lt;WireConnection&lt;T&gt; &gt; The wire connection </dd></dl>

</div>
</div>
<a id="a45dd99dc1f894fb1981006fe6e1c0f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dd99dc1f894fb1981006fe6e1c0f17">&#9670;&nbsp;</a></span>Direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_robot_raconteur_constants_8h.html#a7420bbe1689d74c66948017ba2d27373">MemberDefinition_Direction</a> RobotRaconteur::WireBase::Direction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction of the wire. </p>
<p>Wires may be declared <em>readonly</em> or <em>writeonly</em> in the service definition file. (If neither is specified, the wire is assumed to be full duplex.) <em>readonly</em> wire may only send out values from service to client. <em>writeonly</em> wires may only send out values from client to service.</p>
<dl class="section return"><dt>Returns</dt><dd>MemberDefinition_Direction </dd></dl>

</div>
</div>
<a id="a1491278d75142b49bba8bc90832f1fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1491278d75142b49bba8bc90832f1fa9">&#9670;&nbsp;</a></span>GetMemberName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string RobotRaconteur::WireBase::GetMemberName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the member name of the wire. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

</div>
</div>
<a id="a6f841187f4297f315ba5ace6ccf42488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f841187f4297f315ba5ace6ccf42488">&#9670;&nbsp;</a></span>GetPeekInValueCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::function&lt;T(const uint32_t&amp;)&gt; <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::GetPeekInValueCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently configure PeekInValue callback. </p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="section return"><dt>Returns</dt><dd>boost::function&lt;T(const uint32_t&amp;)&gt; The currently configured callback function </dd></dl>

</div>
</div>
<a id="a52b64d55e1a1ed53f06a967bcb7dedfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b64d55e1a1ed53f06a967bcb7dedfb">&#9670;&nbsp;</a></span>GetPeekOutValueCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::function&lt;T(const uint32_t&amp;)&gt; <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::GetPeekOutValueCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently configure PeekOutValue callback. </p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="section return"><dt>Returns</dt><dd>boost::function&lt;T(const uint32_t&amp;)&gt; The currently configured callback function </dd></dl>

</div>
</div>
<a id="a12e926a4fe5fbdfa9b54edd99f5fef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e926a4fe5fbdfa9b54edd99f5fef6d">&#9670;&nbsp;</a></span>GetPokeOutValueCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::function&lt;void(const T&amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a>&amp;, const uint32_t&amp;)&gt; <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::GetPokeOutValueCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently configure PokeOutValue callback. </p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="section return"><dt>Returns</dt><dd>boost::function&lt;void(const T&amp;, const TimeSpec&amp;, const uint32_t&amp;)&gt; The currently configured callback function </dd></dl>

</div>
</div>
<a id="a2c3e4483ec35f68a82fcc1a3e341fdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3e4483ec35f68a82fcc1a3e341fdc2">&#9670;&nbsp;</a></span>GetWireConnectCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::function&lt;void(boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt;T&gt; &gt;)&gt; <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::GetWireConnectCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently configured wire connected callback function. </p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on client side.</p>
<dl class="section return"><dt>Returns</dt><dd>boost::function&lt;void(RR_SHARED_PTR&lt;WireConnection&lt;T&gt; &gt;)&gt; The currently configured callback function </dd></dl>

</div>
</div>
<a id="a14c25221a14e5f3f0387ac0340ec74e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c25221a14e5f3f0387ac0340ec74e1">&#9670;&nbsp;</a></span>PeekInValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::PeekInValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek the current InValue. </p>
<p>Peeks the current InValue using a "request" instead of a streaming value. Use if only the instantanouse value is required.</p>
<p>Peek and poke are similar to <code>property</code> members. Unlike streaming, peek and poke are reliable operations.</p>
<p>Throws <a class="el" href="class_robot_raconteur_1_1_value_not_set_exception.html" title="Exception thrown if a value has not been set.">ValueNotSetException</a> if InValue is not valid.</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>[out] The timestamp of the current InValue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The current InValue </dd></dl>

</div>
</div>
<a id="afc93665e6f76b2644a79abbbbe9c7784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc93665e6f76b2644a79abbbbe9c7784">&#9670;&nbsp;</a></span>PeekOutValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::PeekOutValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek the current OutValue. </p>
<p>Peeks the current OutValue using a "request" instead of a streaming value. Use if only the instantanouse value is required.</p>
<p>Peek and poke are similar to <code>property</code> members. Unlike streaming, peek and poke are reliable operations.</p>
<p>Throws <a class="el" href="class_robot_raconteur_1_1_value_not_set_exception.html" title="Exception thrown if a value has not been set.">ValueNotSetException</a> if OutValue is not valid.</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>[out] The timestamp of the current OutValue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The current OutValue </dd></dl>

</div>
</div>
<a id="aecad256fef31978596e8f37cbb7fd06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecad256fef31978596e8f37cbb7fd06e">&#9670;&nbsp;</a></span>PokeOutValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::PokeOutValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poke the OutValue. </p>
<p>Pokes the OutValue using a "request" instead of a streaming value. Use to update the OutValue if the value is updated infrequently.</p>
<p>Peek and poke are similar to <code>property</code> members. Unlike streaming, peek and poke are reliable operations.</p>
<p>Only valid on clients. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the service side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new OutValue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40cf20b646bcebbdc28a5738b72f95dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cf20b646bcebbdc28a5738b72f95dc">&#9670;&nbsp;</a></span>SetPeekInValueCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::SetPeekInValueCallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; T(const uint32_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the PeekInValue callback function. </p>
<p>Peek and poke operations are used when a streaming connection of the most recent value is not required. Clients initiate peek and poke operations using <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a>, or their asynchronous equivalents. Services receive the peek and poke requests through callbacks.</p>
<p><a class="el" href="class_robot_raconteur_1_1_wire.html#a40cf20b646bcebbdc28a5738b72f95dc" title="Set the PeekInValue callback function.">SetPeekInValueCallback()</a> configures the service callback for <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a> requests.</p>
<p>The specified callback function should have the following signature: </p><pre class="fragment">T peek_invalue_callback(uint32 client_endpoint);
</pre><p>The function receives the client endpoint ID, and returns the current InValue.</p>
<p>Note: <a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> is configured automatically by <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> or <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a></p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab150ead6b19f631801564c3c854ff335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab150ead6b19f631801564c3c854ff335">&#9670;&nbsp;</a></span>SetPeekOutValueCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::SetPeekOutValueCallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; T(const uint32_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the PeekOutValue callback function. </p>
<p>Peek and poke operations are used when a streaming connection of the most recent value is not required. Clients initiate peek and poke operations using <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a>, or their asynchronous equivalents. Services receive the peek and poke requests through callbacks.</p>
<p><a class="el" href="class_robot_raconteur_1_1_wire.html#ab150ead6b19f631801564c3c854ff335" title="Set the PeekOutValue callback function.">SetPeekOutValueCallback()</a> configures the service callback for <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a> requests.</p>
<p>The specified callback function should have the following signature: </p><pre class="fragment">T peek_outvalue_callback(uint32 client_endpoint);
</pre><p>The function receives the client endpoint ID, and returns the current OutValue.</p>
<p>Note: <a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> is configured automatically by <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> or <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a></p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ddf6dc449ab7ef31ce0e178dd9c3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ddf6dc449ab7ef31ce0e178dd9c3c9">&#9670;&nbsp;</a></span>SetPokeOutValueCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::SetPokeOutValueCallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(const T &amp;, const <a class="el" href="class_robot_raconteur_1_1_time_spec.html">TimeSpec</a> &amp;, const uint32_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the PokeOutValue callback function. </p>
<p>Peek and poke operations are used when a streaming connection of the most recent value is not required. Clients initiate peek and poke operations using <a class="el" href="class_robot_raconteur_1_1_wire.html#a14c25221a14e5f3f0387ac0340ec74e1" title="Peek the current InValue.">PeekInValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#afc93665e6f76b2644a79abbbbe9c7784" title="Peek the current OutValue.">PeekOutValue()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a>, or their asynchronous equivalents. Services receive the peek and poke requests through callbacks.</p>
<p><a class="el" href="class_robot_raconteur_1_1_wire.html#a91ddf6dc449ab7ef31ce0e178dd9c3c9" title="Set the PokeOutValue callback function.">SetPokeOutValueCallback()</a> configures the service callback for <a class="el" href="class_robot_raconteur_1_1_wire.html#aecad256fef31978596e8f37cbb7fd06e" title="Poke the OutValue.">PokeOutValue()</a> requests.</p>
<p>The specified callback function should have the following signature: </p><pre class="fragment">void poke_outvalue_callback(const T&amp; value, const TimeSpec&amp; timestamp, uint32 client_endpoint);
</pre><p>The function receives the new out value, the new out value timestamp in the client's clock, and the client endpoint ID.</p>
<p>Note: <a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> is configured automatically by <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> or <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a></p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89d58b49df1160676ebe362b47d4ff8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d58b49df1160676ebe362b47d4ff8d">&#9670;&nbsp;</a></span>SetWireConnectCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_wire.html">RobotRaconteur::Wire</a>&lt; T &gt;::SetWireConnectCallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_wire_connection.html">WireConnection</a>&lt; T &gt; &gt;)&gt;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set wire connected callback function. </p>
<p><a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> function invoked when a client attempts to connect a the wire. The callback will receive the incoming wire connection as a parameter. The service must maintain a reference to the wire connection, but the wire will retain ownership of the wire connection until it is closed. Using boost::weak_ptr to store the reference to the connection is recommended.</p>
<p>The callback may throw an exception to reject incoming connect request.</p>
<p>Note: Connect callback is configured automatically by <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">WireBroadcaster</a> or <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">WireUnicastReceiver</a></p>
<p>Only valid for services. Will throw <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> on the client side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td><a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> function to receive the incoming connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/wasonj/Documents/RobotRaconteur2/robotraconteur/RobotRaconteurCore/include/RobotRaconteur/<a class="el" href="_wire_member_8h_source.html">WireMember.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
