<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: C++ Clients</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Clients </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Robot Raconteur is an object-oriented client-service RPC framework. Services expose objects, which are made available to clients using "object references", sometimes referred to as "proxies". See <a class="el" href="introduction.html">Introduction</a> for an overview of the Robot Raconteur framework.</p>
<p>The object types and their members are defined in "service definition" files. See <a class="el" href="service_definition.html">Service Definitions</a> for more information on how service objects are defined. C++ uses <code>RobotRaconteurGen</code> to generate "thunk" source that implements the object and value types defined in service definitions. See <a class="el" href="cpp_introduction.html#cpp_intro_cmake_thunk_source_gen">CMake and Robot Raconteur Thunk Source Generation</a>, <a class="el" href="robotraconteurgen.html"><code>RobotRaconteurGen</code> Utility</a>, and <a class="el" href="robotraconteur_generate_thunk.html">CMake <code>ROBOTRACONTEUR_GENERATE_THUNK</code> Macro</a> for more information on thunk source and thunk source generation.</p>
<p>For C++, the thunk source generates an abstract class with pure virtual functions for accessing the members. The client uses this abstract interface class to interact with the service. The client returns a "stub" implementaton of the members, which call the remote node as needed.</p>
<p>Clients can choose between "synchronous" and "asynchronous" version of most member operations. Synchronous operations block the current thread, while asynchronous operations return immediately and invoke a supplied handler function when the operation is complete. See <a class="el" href="cpp_threading_and_async.html">C++ Multithreading and Asynchronous Functions</a> for more information on asynchronous operations.</p>
<h1><a class="anchor" id="cpp_client_connections"></a>
Creating Client Connections</h1>
<p>Creating a client connection requires a node that has been set up. See <a class="el" href="cpp_node_setup.html">C++ Node Setup</a> for details on how to set up a node.</p>
<p>Once a node has been set up, connections can be created to a service on a remote node using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a1b207bb3fe03ffa925fbe0c63dcac417" title="Create a client connection to a remote service using a URL.">RobotRaconteur::RobotRaconteurNode::ConnectService</a> or <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5331e01f78fc91aee870738c9152c9a2" title="Asynchronously create a client connection to a remote service using a URL.">RobotRaconteur::RobotRaconteurNode::AsyncConnectService</a>. These functions take a service URL, optional authentication information, optional client event callback, an optional desired object type, and for the asynchronous version a completion handler function. The connection operations return a RobotRaconteur::RRObjectPtr. This must be cast to the object type using RobotRaconteur::rr_cast.</p>
<p>Consider a simple example, with service definition type <code>example.my_service.MyObject</code> on a localhost node listening on TCP port 62222. </p><pre class="fragment">// Assume that node has been set up
using namespace RobotRaconteur;
std::string url = "rr+tcp://localhost:62222?service=my_service";
example::my_service::MyObjectPtr c = rr_cast&lt;example::my_service::MyObject&gt;(
    RobotRaconteurNode::s()-&gt;ConnectService(url)
);

// The connection "c" is now ready for use
</pre><p>An asynchronous example: </p><pre class="fragment">// Assume that node has been set up
using namespace RobotRaconteur;
std::string url = "rr+tcp://localhost:62222?service=my_service";
RobotRaconteurNode::s()-&gt;AsyncConnectService(
    url, "", nullptr, nullptr, "", 
    [](RRObjectPtr c1, RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            // Handle a connection error
            return;
        }
        example::my_service::MyObjectPtr c = rr_cast&lt;example::my_service::MyObject&gt;(c1);
        // "c" is now ready for use
    }
);

// Continue with other tasks and accept connection on handler invocation
</pre><h2><a class="anchor" id="cpp_client_urls"></a>
Robot Raconteur URLs</h2>
<p>URLs are used to connect to services. See <a class="el" href="nodes_and_communication.html#urls">Robot Raconteur URLs</a> for more information on the URL format.</p>
<h2><a class="anchor" id="cpp_client_auth"></a>
Authentication</h2>
<p>Services may optionally use authentication to protect the service from unauthorized users. Authentication uses a "username" and "credentials". The username is a <code>std::string</code>, and the credentials are an <code>RRMapPtr&lt;std::string,RRValue&gt;</code>. If username is a zero length string and/or credentials is <code>nullptr</code>, authentication is disabled and the connection is anonymous. Typically the credentials map will contain a password entry. The following example uses password authentication: </p><pre class="fragment">// Assume that node has been set up
using namespace RobotRaconteur;
std::string url = "rr+tcp://localhost:62222?service=my_service";
std::string username = "myusername"
std::string password = "password123"
RRMapPtr&lt;std::string,RRValue&gt; credentials = AllocateEmptyRRMap&lt;std::string,RRValue&gt;();
credentials-&gt;insert(std::make_pair("password",stringToRRArray(credentials)))
example::my_service::MyObjectPtr c = rr_cast&lt;example::my_service::MyObject&gt;(
    RobotRaconteurNode::s()-&gt;ConnectService(url,username,credentials)
);

// The connection "c" is now ready for use
</pre><h2><a class="anchor" id="cpp_client_listener"></a>
Client Listener</h2>
<p>The <code>listener</code> parameter is an optional callback function to listen for client events. The signature of the callback function is expected to match: </p><pre class="fragment">void listener(ClientContextPtr, ClientServiceListenerEventType, boost::shared_ptr&lt;void&gt;)
</pre><p>The possible event types can be found in RobotRaconteur::ClientServiceListenerEventType .</p>
<p>An example of using the event listener: </p><pre class="fragment">// Assume that node has been set up
using namespace RobotRaconteur;
std::string url = "rr+tcp://localhost:62222?service=my_service";
example::my_service::MyObjectPtr c = rr_cast&lt;example::my_service::MyObject&gt;(
    RobotRaconteurNode::s()-&gt;ConnectService(
        url, "", nullptr, 
        [](ClientContextPtr ctx, ClientServiceListenerEventType evt, boost::shared_ptr&lt;void&gt; p)
        {
            switch (evt)
            {
                case ClientServiceListenerEventType_ClientClosed:
                    std::cout &lt;&lt; "Client connection has closed" &lt;&lt; std::endl;
                    return;
                case ClientServiceListenerEventType_TransportConnectionClosed:
                    std::cout &lt;&lt; "Client connection has been lost" &lt;&lt; std::endl;
                    return;
                default:
                    return;
            }
        }
    )
);

// The connection "c" is now ready for use
</pre><h2><a class="anchor" id="cpp_client_connect_object_type"></a>
Object Type</h2>
<p>The <code>objecttype</code> optional parameter can be used to specify the fully qualified object type. Use of this parameter is recommended, since services may return a newer subclass of the expected object that the client doesn't understand. If <code>objecttype</code> is specified, the desired object type will always be returned, if the service supports that object type. This parameter is one of the primary ways Robot Raconteur supports forward compatibility with newer devices.</p>
<h1><a class="anchor" id="cpp_client_disconnect"></a>
Disconnecting Clients</h1>
<p>Clients are automatically disconnected when the node is shut down, so it is normally not necessary to disconnect client connections. If closing client connections is necessary, RobotRaconteur::RobotRaconteurNode::DisconnectServiceor <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a55a7acc5b238233193a8cc53ac14985c" title="Asynchronously disconnects a client connection to a service.">RobotRaconteur::RobotRaconteurNode::AsyncDisconnectService</a> can be used.</p>
<h1><a class="anchor" id="cpp_client_subscriptions"></a>
Subscriptions</h1>
<p>Service subscriptions can be used instead of directly connecting and disconnecting client connections. Subscriptions automatically manage the client lifecycle, and are recommended in most situations. See <a class="el" href="cpp_subscriptions.html">C++ Subscriptions</a> for more information.</p>
<h1><a class="anchor" id="cpp_client_members"></a>
Client Members</h1>
<p>The thunk source automatically generates member proxies to access the remote service object members. These proxies make member access nearly seamless, meaning the user can for the most part ignore the fact that these members are running on a remote service. Each member type has its own interface.</p>
<p>More information an object members and the object message protocol can be found in <a class="el" href="service_definition.html">Service Definitions</a> and <a class="el" href="nodes_and_communication.html#message_object_protocol">Object Protocol</a>.</p>
<h2><a class="anchor" id="cpp_client_property"></a>
Property Members</h2>
<p>Property members allow clients to "get" and "set" a property value on the service object. Properties may use any valid Robot Raconteur value type.</p>
<p>Property members are implemented as two access functions in the object, a "get" and "set" function. The "get" function is the name of member prepended with <code>get_</code>. It takes no arguments, and returns the current value. The "set" function is the name of the member prepended with <code>set_</code>. It takes the new property value, and returns void.</p>
<p>For example, the property definition: </p><pre class="fragment">property double my_property
</pre><p>Would generate the two access functions in the C++ abtract interface: </p><pre class="fragment">virtual double get_my_property();
virtual void set_my_property(double val);
</pre><p>Assuming that <code>c</code> is a client connection to an object that has the member <code>my_property</code>, the following example shows getting and setting <code>my_property</code>: </p><pre class="fragment">// Assume "c" is a connected client object reference with property "my_property"

double current_value = c-&gt;get_my_property();
std::cout &lt;&lt; "my_property is currently: " &lt;&lt; current_value &lt;&lt; std::endl;

// Set "my_property" to a new value

c-&gt;set_my_property(1.234);
</pre><p>Properties can be declared <code>readonly</code> or <code>writeonly</code> using member modifiers. If a property is <code>readonly</code>, the <code>set_</code> accessor function is not generated. If a property is <code>writeonly</code>, the <code>get_</code> accessor function is not generated.</p>
<p>The thunk source generates asynchronous accessor functions as well as the above synchronous accessor. These functions are stored in a separate abstract interface with the same name as the standard abstract interface prefixed with <code>async_</code>. The asynchronous property accessor functions are prefixed with <code>async_get_</code> and <code>async_set_</code>. Consider the following example, where <code>c</code> is the synchronous type <code>example.my_service.MyObject</code> that contains the member <code>my_property</code>: </p><pre class="fragment">// Assume "c" is a connected synchronous client object
using namespace example::my_service;
boost::shared_ptr&lt;async_MyObject&gt; c_async = rr_cast&lt;async_MyObject&gt;(c);

c_async-&gt;async_get_my_property(
    [](double val, RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            std::cout &lt;&lt; "Error occurred getting property value: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
        }

        std::cout &lt;&lt; "my_property is currently: " &lt;&lt; val &lt;&lt; std::endl;
    }
);

c_async-&gt;async_set_my_property(
    1.234, [](RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            std::cout &lt;&lt; "Error occurred setting property value: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
        }

        std::cout &lt;&lt; "my_property value set successful" &lt;&lt; std::endl;
    }
);
</pre><p>The <code>async_set_</code> accessor will not be generated if the property is declared <code>readonly</code>. The <code>async_get_</code> accessor will not be generated if the property is declared <code>writeonly</code>.</p>
<h2><a class="anchor" id="cpp_client_function"></a>
Function Members</h2>
<p>Function members allow clients to invoke a function on the service object. Functions may have zero or more value type parameters, and return a value or be declared <code>void</code> for no return. Functions may be "normal", not using a generator, or be "generator functions" which return a generator.</p>
<h3><a class="anchor" id="cpp_client_normal_functions"></a>
Normal Functions</h3>
<p>Normal functions accept zero or more value type parameters, invoke the remote function with these parameters, and return the result, or <code>void</code>. They are implemented in the abstract interface as a C++ function with the same name as the member.</p>
<p>For example, the function definition: </p><pre class="fragment">function double addTwoNumbers(int32 a, double b)
</pre><p>Would generate the C++ function in the abstract interface: </p><pre class="fragment">virtual double addTwoNumbers(int32_t a, double b);
</pre><p>Assuming that <code>c</code> is a client connection to an object that has the member <code>addTwoNumbers</code>, the following example shows invoking the function: </p><pre class="fragment">// Assume "c" is a connected client object reference with function "addTwoNumbers"

double result = c-&gt;addTwoNumbers(10, 1.234);
std::cout &lt;&lt; "addTwoNumbers result: " &lt;&lt; result &lt;&lt; std::endl;
</pre><p>An example function definition with no parameters and void return: </p><pre class="fragment">functon void do_something()
</pre><p>Would generate the C++ function in the abstract interface: </p><pre class="fragment">virtual void do_something();
</pre><p>Functions may also be invoked asynchronously. Like properties, the asynchronous form is in the <code>async_</code> abstract interface. The asynchronous version of the function is the member name prefixed with <code>async_</code>. Examples of asynchronous function invocatons: </p><pre class="fragment">// Assume "c" is a connected synchronous client object
using namespace example::my_service;
boost::shared_ptr&lt;async_MyObject&gt; c_async = rr_cast&lt;async_MyObject&gt;(c);

c_async-&gt;async_addTwoNumbers(10, 1.234
    [](double ret, RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            std::cout &lt;&lt; "Error occurred invoking function: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
        }

        std::cout &lt;&lt; "addTwoNumbers returned: " &lt;&lt; ret &lt;&lt; std::endl;
    }
);

c_async-&gt;async_do_something(
    [](RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            std::cout &lt;&lt; "Error occured invoking function: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
        }

        std::cout &lt;&lt; "do_something() invocation successful" &lt;&lt; std::endl;
    }
);
</pre><h3><a class="anchor" id="cpp_client_generator_functions"></a>
Generator Functions</h3>
<p>Generator functions are similar to normal functions, but instead of returning a value or void, they return a generator. A generator is similar to an iterator, or can implement a coroutine. See <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> and <a class="el" href="service_definition.html#service_definition_function">Functions</a> for more discussion on generators.</p>
<p>Generators operate by calling <code>Next()</code> repeatedly until no more values are available, an exception is thrown, or the client closes/aborts the generator. The generator may be Type 1, 2, or 3, depending on if the generator accepts of parameter for <code>Next()</code>, and/or if it returns a value from <code>Next()</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Generator Type </th><th class="markdownTableHeadNone">Has Return </th><th class="markdownTableHeadNone">Has Parameter </th><th class="markdownTableHeadNone">C++ Template  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Type 1 </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Generator&lt;Return,Param&gt;  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Type 2 </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">No </td><td class="markdownTableBodyNone">Generator&lt;Return,void&gt;  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Type 3 </td><td class="markdownTableBodyNone">No </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Generator&lt;void,Param&gt;  </td></tr>
</table>
<h4>Type 1 Generators</h4>
<p>An example definition of a Type 1 generator: </p><pre class="fragment">function double{generator} addManyNumbers(int32 a, double{generator} b)
</pre><p>This results in the following function being generated in the abstract interface: </p><pre class="fragment">virtual Generator&lt;double,double&gt; addManyNumbers(int32_t a);
</pre><p>The function returns a generator that expects a parameter and returns a value every call to <code>Next()</code>. An example using the generator function: </p><pre class="fragment">// Assume "c" is a connected client object reference with function "addTwoNumbers"

using namespace RobotRaconteur;
Generator&lt;double,double&gt; gen = c-&gt;addManyNumbers(10);
try
{
    for (double i : {1.2,3.4,5.6})
    {
        next_res = gen-&gt;Next(i);
        std::cout &lt;&lt; "addManyNumbers generator result: " &lt;&lt; next_res &lt;&lt; std::endl;
    }
    gen-&gt;Close();
}
catch (StopIterationException&amp;)
{
    std::cout &lt;&lt; "addManyNumbers no more values" &lt;&lt; std::endl;
}
</pre><h4>Type 2 Generators</h4>
<p>An example definition of a Type 2 generator: </p><pre class="fragment">function int32_t getSequence(int32 a, double b)
</pre><p>This results in the following function being generated in the abstract interface: </p><pre class="fragment">virtual Generator&lt;double,void&gt; getSequence(int32_t a, double b);
</pre><p>The function returns a generator that does not expect a parameter and returns a value every call to <code>Next()</code>. An example using the generator function: </p><pre class="fragment">// Assume "c" is a connected client object reference with function "getSequence"

using namespace RobotRaconteur;
Generator&lt;double,void&gt; gen = c-&gt;getSequence(10,1.23);
try
{
    for (size_t i=0; i&lt;max_elems; i++)
    {
        next_res = gen-&gt;Next();
        std::cout &lt;&lt; "getSequence generator result: " &lt;&lt; next_res &lt;&lt; std::endl;
    }
    throw InvalidOperationException("Generator returned too many elements");
}
catch (StopIterationException&amp;)
{
    std::cout &lt;&lt; "getSequence no more values" &lt;&lt; std::endl;
}
</pre><p>This example receives values from <code>Next()</code> until a <a class="el" href="class_robot_raconteur_1_1_stop_iteration_exception.html" title="Exception thrown when a generator has finished sending results.">RobotRaconteur::StopIterationException</a> is thrown, or until it receives more elements than expected.</p>
<h4>Type 3 Generators</h4>
<p>An example definition of a Type 3 generator: </p><pre class="fragment">function void sendSequence(int32 a, double{generator} b)
</pre><p>This results in the following function being generated in the abstract interface: </p><pre class="fragment">virtual Generator&lt;void,double&gt; sendSequence(int32_t a);
</pre><p>The function returns a generator that expects a parameter and does not return a value every call to <code>Next()</code>. An example using the generator function: </p><pre class="fragment">// Assume "c" is a connected client object reference with function "sendSequence"

using namespace RobotRaconteur;
Generator&lt;void,double&gt; gen = c-&gt;sendSequence(10);

for (double i : {1.2,3.4,5.6})
{
    gen-&gt;Next(i);
}
gen-&gt;Close();
</pre><h4>Asynchronous Generator Functions</h4>
<p>Generator functions also have asynchronous C++ functions generated in the <code>async_</code> abstract interace. They follow the same rules as normal functions, but return <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> to the handler function. <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> implements asynchronous <a class="el" href="class_robot_raconteur_1_1_generator.html#a47e6c0c430f1ac3eeb8516702c20e153" title="Asynchronously advance the generator.">RobotRaconteur::Generator::AsyncNext()</a>, RobotRaconteur::AsyncClose(), and RobotRaconteur::AsyncAbort() for use with asynchronous clients.</p>
<h3><a class="anchor" id="cpp_client_generators"></a>
Generator Clients</h3>
<p>See <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> for more information on generator objects. Client generators inherit from <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> and implement communication with the remote generator on the service.</p>
<h2><a class="anchor" id="cpp_client_event"></a>
Event Members</h2>
<p>Events are used by the service to notify all connected clients an event has occurred. Events may have zero or more value type parameters. Events are sent to all connected clients. In C++, events are implemented using <code>boost::signals2::signal</code>. See the documentation for <code>boost::signals2::signal</code> for more information on using Boost.Signals2. An example event definition: </p><pre class="fragment">event somethingHappened(string what, double when)
</pre><p>This event definition results in the following function being generated in the C++ abstract interface: </p><pre class="fragment">virtual boost::signals2::signal&lt;void(std::string, double)&gt;&amp; get_somethingHappened();
</pre><p>An example of using the event: </p><pre class="fragment">// Assume "c" is a connected client object reference with event "somethingHappened"

using namespace RobotRaconteur;
c-&gt;get_somethingHappened().connect(
    [](std::string what, double when)
    {
        std::cout &lt;&lt; "something happened: " &lt;&lt; what &lt;&lt; std::endl;
    }
);
</pre><h2><a class="anchor" id="cpp_client_objref"></a>
ObjRef Members</h2>
<p>ObjRef members are used to access other objects within a service. See <a class="el" href="nodes_and_communication.html#service_paths">Service Paths</a> for more information on objrefs and service paths. An example objref definition:</p>
<p>objref MyOtherObject other_object</p>
<p>This objref definition results in the following function being generated in the C++ abstract interface: </p><pre class="fragment">virtual MyOtherObjectPtr get_other_object();
</pre><p>The function name is the member name prefixed with <code>get_</code>.</p>
<p>An example using this objref: </p><pre class="fragment">// Assume "c" is a connected client object reference with event "somethingHappened"

using namespace RobotRaconteur;
MyOtherObjectPtr obj2 = c-&gt;get_other_object();
obj2-&gt;some_function();
</pre><p>ObjRefs may also be indexed by <code>int32</code> or <code>string</code>. The following are member definitions for <code>int32</code> indexed objref: </p><pre class="fragment">objref MyOtherObject[] other_object1
objref MyOtherObject{int32} other_object2
</pre><p>They result in the following functions being generated in the abstract interface: </p><pre class="fragment">virtual MyOtherObjectPtr get_other_object1(int32_t index);
virtual MyOtherObjectPtr get_other_object2(int32_t index);
</pre><p>The following is an objref definition for a <code>string</code> indexed objref: </p><pre class="fragment">objref MyOtherObject{string} other_object3
</pre><p>It results in the following function being generated in the abstract interface: </p><pre class="fragment">virtual MyOtherObjectPtr get_other_object3(const std::string&amp; index);
</pre><p>ObjRefs may also be invoked asynchronously. Like properties, the asynchronous form is in the <code>async_</code> abstract interface. The asynchronous version of the objref is the member name prefixed with <code>async_get_</code>. An example of invoking an objref asynchronously: </p><pre class="fragment">// Assume "c" is a connected synchronous client object
using namespace example::my_service;
boost::shared_ptr&lt;async_MyObject&gt; c_async = rr_cast&lt;async_MyObject&gt;(c);

c_async-&gt;async_get_other_object2(12345,
    [](MyOtherObjectPtr obj, RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            std::cout &lt;&lt; "Error occured invoking objref: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
            return;
        }

        // Use the objref
        obj-&gt;async_some_function(
            [](RobotRaconteurExceptionPtr err)
            {
                if (err)
                {
                    std::cout &lt;&lt; "Error occured invoking function: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
                }
            }
        )
    }
);
</pre><h2><a class="anchor" id="cpp_client_pipe"></a>
Pipe Members</h2>
<p>Pipe members provide reliable (or optionally unreliable) data streams between clients and service, in either direction. See <a class="el" href="class_robot_raconteur_1_1_pipe.html">RobotRaconteur::Pipe</a> for a discussion of pipes.</p>
<p>An example pipe definition: </p><pre class="fragment">pipe double[] sensordata
</pre><p>Results in the following functions being generated in the abstract interface: </p><pre class="fragment">virtual PipePtr&lt;RRArrayPtr&lt;double&gt;&gt; get_sensordata();
virtual void set_sensordata(PipePtr&lt;RRArrayPtr&lt;double&gt;&gt; pipe);
</pre><p>A get acessor prefixed with <code>get_</code> and a set accesor prefixed with <code>set_</code> are generated. These are used to get and set the pipe member object in the service. For the client, only the get accessor is used.</p>
<p>The <code>get_</code> accessor is used to retrieve the pipe so it can be used. An example of using a pipe client: </p><pre class="fragment">// Assume "c" is a connected client object reference with pipe "sensordata"

using namespace RobotRaconteur;
PipePtr&lt;RRArrayPtr&lt;double&gt;&gt; sensordata = c-&gt;get_sensordata();
PipeEndpointPtr&lt;RRArrayPtr&lt;double&gt;&gt; sensordata_ep = sensordata-&gt;Connect(-1);
double data[] = {1.23, 4.56};
sensordata_ep-&gt;SendPacket(AttachRRArrayCopy(data,2));
RRArrayPtr&lt;double&gt; recv_data = sensordata_ep-&gt;ReceivePacketWait(100);
std::cout &lt;&lt; "Got recv_data len: " &lt;&lt; recv_data-&gt;size() &lt;&lt; std::endl;
</pre><p>Pipes can also be used asynchronously. Retrieving a pipe from the abstract interface never blocks since the pipe client exists locally. An example of using the pipe asynchronously: </p><pre class="fragment">// Assume "c" is a connected client object reference with pipe "sensordata"

using namespace RobotRaconteur;

// Retrieve the pipe client. This never blocks.
PipePtr&lt;RRArrayPtr&lt;double&gt;&gt; sensordata = c-&gt;get_sensordata();

//Connect pipe asynchronously
sensordata-&gt;AsyncConnect(-1, 
    [](PipeEndpointPtr&lt;RRArrayPtr&lt;double&gt;&gt; sensordata_ep, RobotRaconteurExceptionPtr err)
    {
        if (err)
        {
            std::cout &lt;&lt; "Connecting pipe failed: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
            return;
        }

        // Connect to signal to be notified when packets arrive
        sensordata_ep-&gt;PacketReceivedEvent.connect(
            [](PipeEndpointPtr&lt;RRArrayPtr&lt;double&gt;&gt; ep)
            {
                while (ep-&gt;Available() &gt; 0)
                {
                    RRArrayPtr&lt;double&gt; recv_data = sensordata_ep-&gt;ReceivePacket();
                    std::cout &lt;&lt; "Got recv_data len: " &lt;&lt; recv_data-&gt;size() &lt;&lt; std::endl;
                }
            }
        )

        double data[] = {1.23, 4.56};

        // Asynchronously send packet
        sensordata_ep-&gt;AsyncSendPacket(AttachRRArrayCopy(data,2),
            [](RobotRaconteurExceptionPtr err)
            {
                if (err)
                {
                    std::cout &lt;&lt; "Sending pipe packet failed: " &lt;&lt; err-&gt;what() &lt;&lt; std::endl;
                    return;
                }

                // Continue with the tasks
            }
        );

    }
);
</pre><p>These example use only a few of the possible functions in <a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">RobotRaconteur::Pipe</a> and <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html" title="Pipe endpoint used to transmit reliable or unreliable data streams.">RobotRaconteur::PipeEndpoint</a> for the full API.</p>
<p>Pipes declared <code>readonly</code> may only receive packets on the client side. Pipes declared <code>writeonly</code> may only send packets on the client side.</p>
<h2><a class="anchor" id="cpp_client_callback"></a>
Callback Members</h2>
<p>Callbacks allow the service to invoke a function on a specific client. The definition is nearly identical to a <code>function</code> member, except the keyword is <code>callback</code> and generators are not supported. An example callback definition: </p><pre class="fragment">callback double addTwoNumbersOnClient(int32 a, double b)
</pre><p>Results in the following functions being generated in the abstract interface: </p><pre class="fragment">virtual CallbackPtr&lt;boost::function&lt;double (int32_t, double)&gt; &gt; get_addTwoNumbersOnClient();
virtual void set_addTwoNumbersOnClient(CallbackPtr&lt;boost::function&lt;double (int32_t, double)&gt; &gt; callback);
</pre><p>A get acessor prefixed with <code>get_</code> and a set accesor prefixed with <code>set_</code> are generated. These are used to get and set the callback member object in the service. For the client, only the get accessor is used.</p>
<p>The calback member object is a <a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">RobotRaconteur::Callback</a> used to set the callback function on the client, and get the callback proxy on the service.</p>
<p>An example using the callback client: </p><pre class="fragment">// Assume "c" is a connected client object reference with callback "addTwoNumbersOnClient"

using namespace RobotRaconteur;

// Get the callback member object
CallbackPtr&lt;boost::function&lt;double (int32_t, double)&gt; &gt; cb = c-&gt;get_addTwoNumbersOnClient();

// Set the callback function
c-&gt;SetClientFunction([](int32_t a, double b)
    {
        std::cout &lt;&lt; "Service invoke callback with parameters " &lt;&lt; a &lt;&lt; "and" &lt;&lt; b &lt;&lt; std::endl;
        return (double)(a + b);
    }
);
</pre><p>The <a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">RobotRaconteur::Callback</a> object implementation does not support asynchronous operation.</p>
<h2><a class="anchor" id="cpp_client_wire"></a>
Wire Members</h2>
<p>Wire members provide a "most recent" values. They are typically used to communicate a real-time signal, such as a robot joint angle. See <a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">RobotRaconteur::Wire</a> for a discussion of wires.</p>
<p>An example wire definition: </p><pre class="fragment">wire double[2] currentposition
</pre><p>Results in the following functions being generated in the abstract interface: </p><pre class="fragment">virtual WirePtr&lt;RRArrayPtr&lt;double&gt;&gt; get_currentposition();
virtual void set_currentposition(WirePtr&lt;RRArrayPtr&lt;double&gt;&gt; wire);
</pre><p>A get acessor prefixed with <code>get_</code> and a set accesor prefixed with <code>set_</code> are generated. These are used to get and set the wire member object in the service. For the client, only the get accessor is used.</p>
<p>The <code>get_</code> accessor is used to retrieve the wire so it can be used. An example of using a wire client in streaming operation: </p><pre class="fragment">// Assume "c" is a connected client object reference with wire "currentposition"

using namespace RobotRaconteur;
WirePtr&lt;RRArrayPtr&lt;double&gt;&gt; currentposition = c-&gt;currentposition();

// Connect a WireConnection to receive streaming updates
WireConnectionPtr&lt;RRArrayPtr&lt;double&gt;&gt; currentposition_cn = currentposition-&gt;Connect();
double data[] = {1.23, 4.56};
currentposition_cn-&gt;SetOutValue(AttachRRArrayCopy(data,2));
currentposition_cn-&gt;WaitInValueValid(100);
RRArrayPtr&lt;double&gt; in_value = currentposition_cn-&gt;GetInValue();
std::cout &lt;&lt; "Got in_value len: " &lt;&lt; in_value-&gt;size() &lt;&lt; std::endl;

// Get the TimeSpec of the current InValue
TimeSpec in_value_ts = currentposition_cn-&gt;GetLastValueReceivedTime();
</pre><p>Wire function <code>GetInValue()</code>, <code>SetOutValue()</code>, and <code>GetLastValueReceivedTime()</code> are inherently asynchronous, since they are intended to stream real-time data. In purely asynchronous code, <code>WaitInValueValid()</code> cannot be used. <code>TryGetInValue()</code> should be used instead to poll if a value is available.. Asynchronous code should also use <code>AsyncConnect()</code> instead of <code>Connect()</code> to connect the wire.</p>
<p>The above example uses a connected wire for streaming data. Sometimes the client only needs to read the <code>InValue</code> or set the <code>OutValue</code> instantaneously, not requiring a streaming connection. The "peek" and "poke" functions are provided for this purpose. They work like property "get" and "set", sending a request and receiving a response instead of passively sending packets periodically. See <a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">RobotRaconteur::Wire</a> for a discussion on peek and poke.</p>
<p>An example of using peek and poke: </p><pre class="fragment">// Assume "c" is a connected client object reference with wire "currentposition"

using namespace RobotRaconteur;
WirePtr&lt;RRArrayPtr&lt;double&gt;&gt; currentposition = c-&gt;currentposition();

// Connect a WireConnection to receive streaming updates
double data[] = {1.23, 4.56};
currentposition_cn-&gt;PokeOutValue(AttachRRArrayCopy(data,2));
TimeSpec in_value_ts;
RRArrayPtr&lt;double&gt; in_value = currentposition_cn-&gt;PeekInValue(in_value_ts);
std::cout &lt;&lt; "Got in_value len: " &lt;&lt; in_value-&gt;size() &lt;&lt; std::endl;
</pre><p>The above example uses the synchronous functions <code>PeekInValue()</code> and <code>PokeOutValue()</code>. Asynchronous versions of these functions are also available. See <a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">RobotRaconteur::Wire</a>.</p>
<p>Wires may be declared <code>readonly</code> or <code>writeonly</code>. Wires declared <code>readonly</code> wires may only use InValue on the client side. Wires declared <code>writeonly</code> may only use OutValue on the client side.</p>
<h2><a class="anchor" id="cpp_client_memory"></a>
Memory Members</h2>
<p>Memories are used to read and write a memory segment on the service. Memories may be numeric arrays, numeric multidimarrays, pod arrays, pod multidimarrays, namedarray arrays, or namedarray multidimarrays. The following table shows which memory class is used for each value and array type:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">C++ Memory Class  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">numeric array </td><td class="markdownTableBodyNone"><a class="el" href="class_robot_raconteur_1_1_array_memory.html" title="Single dimensional numeric primitive random access memory region.">RobotRaconteur::ArrayMemory</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">numeric multidimarray </td><td class="markdownTableBodyNone"><a class="el" href="class_robot_raconteur_1_1_multi_dim_array_memory.html" title="Multidimensional numeric primitive random access memory region.">RobotRaconteur::MultiDimArrayMemory</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pod array </td><td class="markdownTableBodyNone"><a class="el" href="class_robot_raconteur_1_1_pod_array_memory.html" title="Single dimensional pod random access memory region.">RobotRaconteur::PodArrayMemory</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pod multidimarray </td><td class="markdownTableBodyNone"><a class="el" href="class_robot_raconteur_1_1_pod_multi_dim_array_memory.html" title="Multidimensional pod random access memory region.">RobotRaconteur::PodMultiDimArrayMemory</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">namedarray array </td><td class="markdownTableBodyNone"><a class="el" href="class_robot_raconteur_1_1_named_array_memory.html" title="Single dimensional namedarray random access memory region.">RobotRaconteur::NamedArrayMemory</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">namedarray multidimarray </td><td class="markdownTableBodyNone"><a class="el" href="class_robot_raconteur_1_1_named_multi_dim_array_memory.html" title="Multidimensional namedarray random access memory region.">RobotRaconteur::NamedMultiDimArrayMemory</a>  </td></tr>
</table>
<p>All of the above C++ classes take a template of the scalar type used by the memory. See each individual class for more information.</p>
<p>A numeric array memory client and a numeric multidimarray memory client will be used as examples. Pod and namedarray memories are identical, except for the memory class and the value types being utilized.</p>
<p>Example array memory definition: </p><pre class="fragment">memory double[] datahistory
</pre><p>Results in a single function being generated in the abstract interface: </p><pre class="fragment">virtual ArrayMemoryPtr&lt;double&gt; get_datahistory();
</pre><p>The accessor function name is the member name prefixed with <code>get_</code>. On the client, this returns the array memory client. This accessor never blocks.</p>
<p>An example of using the array memory client: </p><pre class="fragment">// Assume "c" is a connected client object reference with memory "datahistory"

ArrayMemoryPtr&lt;double&gt; datahistory = c-&gt;get_datahistory();

// Get the length of the memory
uint64_t datahistory_len = datahistory-&gt;Length();

// Read a segment of the memory into read_buf
RRArrayPtr&lt;double&gt; read_buf = AllocateRRArray&lt;double&gt;(100);
datahistory-&gt;Read(10, read_buf, 0, 100);

// Write a portion of write_buf to segment of memory
RRArrayPtr&lt;double&gt; write_buf = AllocateRRArray&lt;double&gt;(100);
// TODO: fill write_buf with data
datahistory-&gt;Write(5, write_buf, 15, 20);
</pre><p>Example array memory definition: </p><pre class="fragment">memory double[*] datahistory2
</pre><p>Results in a single function being generated in the abstract interface: </p><pre class="fragment">virtual MultiDimArrayMemoryPtr&lt;double&gt; get_datahistory2();
</pre><p>An example of using the array memory client: </p><pre class="fragment">// Assume "c" is a connected client object reference with memory "datahistory2"

MultiDimArrayMemoryPtr&lt;double&gt; datahistory2 = c-&gt;get_datahistory2();

// Get the length of the memory
std::vector&lt;uint64_t&gt; datahistory2_dims = datahistory2-&gt;Dimensions();

// Read a segment of the memory into read_buf
RRMultiDimArrayPtr&lt;double&gt; read_buf = AllocateEmptyRRMultiDimArray&lt;double&gt;({10,10});
datahistory-&gt;Read({20,5}, read_buf, {0,0}, {10,10});

// Write a portion of write_buf to segment of memory
RRMultiDimArrayPtr&lt;double&gt; write_buf = AllocateEmptyRRMultiDimArray&lt;double&gt;({10,10});
// TODO: fill write_buf with data
datahistory-&gt;Write({5,10}, write_buf, {0,0}, {10,10});
</pre><p>The array memory clients do not support asynchronous operations.</p>
<p>It is recommended that clients aquire a monitor lock before memory operations. See <a class="el" href="cpp_client.html#cpp_client_monitor_locks">Monitor Locks</a>.</p>
<h1><a class="anchor" id="cpp_client_object_locking"></a>
Object Locking</h1>
<p>Robot Raconteur clients can request user, client, and monitor locks. These different lock types are discussed in <a class="el" href="locking.html">Object Locking</a>. These locks are activated and released using functions in <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html" title="The central node implementation.">RobotRaconteur::RobotRaconteurNode</a>.</p>
<p>Locking normally requires the user to be authenticated, and for the user to have locking privileges.</p>
<h2><a class="anchor" id="cpp_client_user_locks"></a>
User Locks</h2>
<p>Users locks are requested using the <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RobotRaconteur::RobotRaconteurNode::RequestObjectLock()</a> function with the <code>RobotRaconteurObjectLockFlags_USER_LOCK</code> flag specified. <a class="el" href="class_robot_raconteur_1_1_object_locked_exception.html" title="Exception thrown when attempting to access a locked service object.">RobotRaconteur::ObjectLockedException</a> will be thrown if the object is already locked. The lock is released using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a52fb5b31209ac66cd1b7a51ab9e3c622" title="Release an excluse access lock previously locked with RequestObjectLock() or AsyncRequestObjectLock()">RobotRaconteur::RobotRaconteurNode::ReleaseObjectLock()</a>. An example of user locks: </p><pre class="fragment">// Assume "c" is a connected client object reference

RobotRaconteurNode::s()-&gt;RequestObjectLock(c, RobotRaconteurObjectLockFlags_USER_LOCK);

// If successful, the object is now locked for any session owned by the current user

// When done with the lock, release it.

RobotRaconteurNode::s()-&gt;ReleaseObjectLock(c);
</pre><p>Asynchronous versions of the lock and unlock functions are available. See RobotRaconteur::RobootRaconteurNode::AsyncRequestObjectLock() and <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4a95071780ea9e0c8e5efb09c8bda0e4" title="Asynchronously release an excluse access lock previously locked with RequestObjectLock() or AsyncRequ...">RobotRaconteur::RobotRaconteurNode::AsyncReleaseObjectLock()</a>.</p>
<h2><a class="anchor" id="cpp_client_client_locks"></a>
Client Locks</h2>
<p>Client locks are requested using the <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a92b19ab712aa7a96f7dfb7b3bfbf8673" title="Request an exclusive access lock to a service object.">RobotRaconteur::RobotRaconteurNode::RequestObjectLock()</a> function with the <code>RobotRaconteurObjectLockFlags_CLIENT_LOCK</code> flag specified. <a class="el" href="class_robot_raconteur_1_1_object_locked_exception.html" title="Exception thrown when attempting to access a locked service object.">RobotRaconteur::ObjectLockedException</a> will be thrown if the object is already locked. The lock is released using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a52fb5b31209ac66cd1b7a51ab9e3c622" title="Release an excluse access lock previously locked with RequestObjectLock() or AsyncRequestObjectLock()">RobotRaconteur::RobotRaconteurNode::ReleaseObjectLock()</a>. An example of user locks: </p><pre class="fragment">using namespace RobotRaconteur;

// Assume "c" is a connected client object reference

RobotRaconteurNode::s()-&gt;RequestObjectLock(c, RobotRaconteurObjectLockFlags_CLIENT_LOCK);

// If successful, the object is now locked, only allowing the current session to use the object

// When done with the lock, release it.

RobotRaconteurNode::s()-&gt;ReleaseObjectLock(c);
</pre><p>Asynchronous versions of the lock and unlock functions are available. See RobotRaconteur::RobootRaconteurNode::AsyncRequestObjectLock() and <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a4a95071780ea9e0c8e5efb09c8bda0e4" title="Asynchronously release an excluse access lock previously locked with RequestObjectLock() or AsyncRequ...">RobotRaconteur::RobotRaconteurNode::AsyncReleaseObjectLock()</a>.</p>
<h2><a class="anchor" id="cpp_client_monitor_locks"></a>
Monitor Locks</h2>
<p>Monitor locks provide a single-threaded lock on the service object. There is no asynchronous version since it is inherently a threaded concept. Monitor locks are created using the <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a20f7a8892481899ab761f0169737475e" title="Creates a monitor lock on a specified object.">RobotRaconteur::RobotRaconteurNode::MonitorEnter()</a> function, and released using the RobotRaconteurNode::MonitorExit() function. A convenience scoped lock fence is available, <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node_1_1_scoped_monitor_lock.html" title="Wrapper for RobotRaconteurNode::MonitorEnter() and RobotRaconteurNode::MonitorExit() to take advantag...">RobotRaconteur::RobotRaconteurNode::ScopedMonitorLock</a>. Its use is recommended. An example: </p><pre class="fragment">using namespace RobotRaconteur;

// Assume "c" is a connected client object reference

{
    RobotRaconteurNode::ScopedMonitorLock monitor_lock(c,1000);

    // If successful, the object is now monitor locked.

}

// Lock is released when monitor_lock is destroyed
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
