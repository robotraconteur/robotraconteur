<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: C++ Core Library Introduction and Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Core Library Introduction and Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_C__Users_wasonj_Documents_RobotRaconteur2_robotraconteur_docs_cpp_cpp_introduction"></a> The flagship implementation of Robot Raconteur is the Robot Raconteur Core library. It is open-source using the Apache 2.0 license. The source code can be found at [<a href="https://github.com/robotraconteur/robotraconteur">https://github.com/robotraconteur/robotraconteur</a>]. This section discusses the C++ implentation of the Robot Raconteur framework. The "Framework" section should be read before this section (See <a class="el" href="introduction.html">Introduction</a>).</p>
<p>The Robot Raconteur Core library provides a C++ API, and "wrappers" for other languages including Python, Java, C#, and MATLAB. <b>C++ programming is an advanced topic, and not recommended for novice programmers. Use of one of the wrapped languages is recommended.</b></p>
<p>The C++ library uses the <a href="https://www.boost.org/">Boost C++ Libraries</a>, in particular the <a href="https://www.boost.org/doc/libs/1_72_0/doc/html/boost_asio.html">Boost.Asio</a> networking and communication library. The C++ library is multithreaded and asynchronous. Multithreading means that multiple threads can safely interact with the core library. Asynchronous means that functions can be invoked, with the result returned later in a callback instead of the thread waiting for completion of the operation. Multithreading and asynchronous programming is enabled through the use of the boost::asio::io_context class. This class implements network event handling and thread dispatching. See threading for more details on using threading.</p>
<p>Robot Raconteur Core uses <a href="https://cmake.org">CMake</a> for its build system. CMake files are provided for use with <code>find_package()</code>. It is recommended that projects use CMake with Robot Raconteur.</p>
<p>The Robot Raconteur Core library has been designed to have very few dependencies. These dependencies are typically limited to <a href="https://boost.org">Boost C++ Libraryis</a>, <a href="https://openssl.org">OpenSSL</a> on non-Windows platforms, and a handful of device-driver related packages on Linux when the HardwareTransport is built. (These device-driver related packages are not required at runtime unless the HardwareTransport is being used.) Having a limited number of dependencies makes Robot Raconteur highly portable and easy to embed in other programs as a plugin.</p>
<p>Robot Raconteur Core is written using the C++98 standard. This choice was made to ease porting to industrial operating systems that may not support C++11. C++11 convenience template aliases are provided for many types when C++11 is available, and their use is recommended.</p>
<p>Robot Raconteur Core is distributed as a static library. While it can be built as a shared library, this is not recommended since the generated wrappers must perfectly match the Robot Raconteur library version. Statically linking the Robot Raconteur library guarantees that they will match.</p>
<h1><a class="anchor" id="cpp_installation"></a>
Installation</h1>
<p>This section only covers C++ library installation. See the project <a href="https://github.com/robotraconteur/robotraconteur/blob/master/README.md">README</a> for other languages and the most up to date instructions.</p>
<p>Use of these installation methods is recommended since they will automatically install dependencies.</p>
<h2>Windows</h2>
<p><code>vcpkg</code> is used to install the Robot Raconteur C++ library. See <a href="https://github.com/microsoft/vcpkg">https://github.com/microsoft/vcpkg</a> for installation instructions.</p>
<p>Note that once built, the <code>vcpkg</code> toolchain file must be specified using the <code>CMAKE_TOOLCHAIN_FILE</code> CMake variable. See <a href="https://github.com/microsoft/vcpkg#quick-start-windows">https://github.com/microsoft/vcpkg#quick-start-windows</a> for a quick-start on using <code>vcpkg</code> with your project.</p>
<p>To build Robot Raconteur, clone the <code>vcpkg-robotraconteur</code> overlay repo in the vcpkg directory:</p>
<div class="fragment"><div class="line">git clone https://github.com/robotraconteur/vcpkg-robotraconteur.git</div>
</div><!-- fragment --><p>and build the library:</p>
<div class="fragment"><div class="line">vcpkg --overlay-ports=vcpkg-robotraconteur\ports install robotraconteur</div>
</div><!-- fragment --><p>To build x64, use:</p>
<div class="fragment"><div class="line">vcpkg --overlay-ports=vcpkg-robotraconteur\ports install robotraconteur:x64-windows</div>
</div><!-- fragment --><h2>Ubuntu Xenial, Bionic, and Focal</h2>
<p>A PPA is available for Robot Raconteur. <a href="https://launchpad.net/~robotraconteur/+archive/ubuntu/ppa">https://launchpad.net/~robotraconteur/+archive/ubuntu/ppa</a></p>
<div class="fragment"><div class="line">sudo add-apt-repository ppa:robotraconteur/ppa -y</div>
<div class="line">sudo apt-get update</div>
<div class="line">sudo apt-get install robotraconteur-dev</div>
</div><!-- fragment --><p>The Robot Raconteur package will be immediately available in the CMake search path.</p>
<h2>Mac OSX</h2>
<p>Use <code>brew</code> to install the Robot Raconteur C++ library.</p>
<div class="fragment"><div class="line">brew install robotraconteur/robotraconteur/robotraconteur</div>
</div><!-- fragment --><p>The Robot Raconteur package will be immediately available in the CMake search path.</p>
<h2>Other Platforms</h2>
<p>Other platforms must be built from source.</p>
<h1><a class="anchor" id="cpp_building"></a>
Building</h1>
<p>This section only covers building the C++ library. See the project <a href="https://github.com/robotraconteur/robotraconteur/blob/master/README.md">README</a> for other languages and the most up to date instructions.</p>
<p>Building the C++ library is straight forward and unlikely to cause errors, however building the wrappers for other languages can be challenging. It is recommended that the <code>.github/workflows/main.yml</code> GitHub Action be used to build the wrappers.</p>
<p>When building using CMake, the "generator" and "build configuration" can be specified. See <a href="https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html">CMake Generators</a> and CMake <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#build-tool-mode">CMake Build Tool Mode</a> for more information. Valid build configurations are Debug, Release, RelWithDebInfo, and MinSizeRel.</p>
<h2>Windows</h2>
<p>Building the core library requires Visual Studio 2012 through 2019, Boost 1.72.0, and CMake. Follow the instructions on the Boost website to build Boost. Alternatively, Boost can be built using the <a href="https://github.com/Microsoft/vcpkg">vcpkg</a> utility.</p>
<p>If boost was built using <code>vcpkg</code>, use the following commands to build: </p><pre class="fragment">mkdir build &amp;&amp; cd build
cmake -G &lt;generator&gt; .. -DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg_toolchain_path&gt; -DBUILD_GEN=ON
cmake --build . -C Debug
cmake --build . --target install
</pre><h2>Linux</h2>
<p>Building on linux requires several packages to be installed. For a Debian based system, the following will install the required dependencies: </p><pre class="fragment">sudo apt install zlib1g-dev libssl-dev libdbus-1-dev libbluetooth-dev cmake g++ build-essential libboost-all-dev libusb-1.0-0-dev
</pre><p>To build the library: </p><pre class="fragment">mkdir build &amp;&amp; cd build
cmake -DBUILD_GEN=ON ..
cmake --build . -C Debug
cmake --build . --target install
</pre><h2>Mac OSX</h2>
<p>Building on Mac OSX requires XCode and the XCode Developer Tools to be installed. See <a href="https://developer.apple.com/library/archive/technotes/tn2339/_index.html">Apple Technical Note TN2339</a> It also requires Homebrew to be installed.</p>
<p>Install required dependencies: </p><pre class="fragment">brew install boost openssl cmake
</pre><p>To build the library: </p><pre class="fragment">mkdir build &amp;&amp; cd build
cmake -G "Xcode" -DBUILD_GEN=ON -DOPENSSL_ROOT_DIR=/usr/local/opt/openssl -DOPENSSL_USE_STATIC_LIBS=ON ..
cmake --build . _C Debug
cmake --build . --target install
</pre><p>Note that Mac OSX has a version of OpenSSL installed that is incompatible with new software being built. It is critical that <code>OPENSSL_ROOT_DIR</code> and <code>OPENSSL_USE_STATIC_LIBS</code> be used to prevent collision with the default OpenSSL version.</p>
<h1><a class="anchor" id="cpp_ros"></a>
ROS Support</h1>
<p>Robot Raconteur can be built and utilized from within ROS. To use, clone the robotraconteur repository into catkin_ws/src, run rosdep to install dependencies, and use catkin_make_isolated or catkin_tools to build. By default, the resulting build will not have ROS support and will only build the core static library. To build with ROS support, RobotRaconteurGen, and Python, the CMake option <code>ROBOTRACONTEUR_ROS</code> must be set.</p>
<p>Before building, run <code>rosdep</code>: </p><pre class="fragment">rosdep install --from-paths src --ignore-src -r -y
</pre><p>To build with <code>catkin_make_isolated</code>: </p><pre class="fragment">catkin_make_isolated --cmake-args -DROBOTRACONTEUR_ROS=1
</pre><p>To build with <code>catkin_tools</code>: </p><pre class="fragment">catkin config --cmake-args -DROBOTRACONTEUR_ROS=1
catkin build
</pre><p>Note that SWIG version 4.0.0 MUST be installed before attempting to build the Python bindings. Ubuntu 20.04 Focal includes SWIG 4.0.0, but older versions of Ubuntu do not. Robot Raconteur will not build using theese older versions installed from apt! For these older Ubuntu versions, SWIG must be built from source Install to /usr/local so catkin can find the swig executable. See <a href="https://github.com/swig/swig/wiki/Getting-Started">here</a> for SWIG installation instructions.</p>
<h1><a class="anchor" id="cpp_intro_cmake_thunk_source_gen"></a>
CMake and Robot Raconteur Thunk Source Generation</h1>
<p>Using Robot Raconteur from CMake is straightforward. In your CMakeLists.txt file, use <code>find_package</code> to find Robot Raconteur: </p><pre class="fragment">find_package(RobotRaconteur REQUIRED)
</pre><p>Robot Raconteur uses Service Definitions to define objects, value types, exceptions, constants, and enums. For dynamic languages like Python and MATLAB, these types are handled automatically. Compiled languages like C++ need to have these types generated at compile time. This is accomplished using the <code>RobotRaconteurGen</code> utility. See <a class="el" href="robotraconteurgen.html"><code>RobotRaconteurGen</code> Utility</a> for more information on this utility. Robot Raconteur provides a CMake macro to call <code>RobotRaconteurGen</code>. </p><pre class="fragment">ROBOTRACONTEUR_GENERATE_THUNK(&lt;SRCS&gt; &lt;HDRS&gt; &lt;ROBDEF_FILES&gt; [MASTER_HEADER] [AUTO_IMPORT] [INCLUDE_DIRS &lt;INCLUDE_DIR1&gt; [&lt;INCLUDE_DIR2&gt; ...]])
</pre><p>See <a class="el" href="robotraconteur_generate_thunk.html">CMake <code>ROBOTRACONTEUR_GENERATE_THUNK</code> Macro</a> for more details on using the <code>ROBOTRACONTEUR_GENERATE_THUNK</code> macro.</p>
<p>Add the <code>&lt;src_files_out&gt;</code> variable to your input sources in the <code>add_executable()</code> or <code>add_library()</code> command.</p>
<p>For your targets, add the RobotRaconteurCore target as a dependency. This will automatically add the required include directories and required libraries. </p><pre class="fragment">target_link_libraries(my_target RobotRaconteurCore)
</pre><p>See the C++ examples for example CMakeLists.txt files.</p>
<p>If the <code>MASTER_HEADER</code> header is used, use the following include in program header files: </p><pre class="fragment">#include &lt;RobotRaconteur.h&gt;
#include "robotraconteur_generated.h"
</pre><h1><a class="anchor" id="cpp_boost_library"></a>
Boost Library</h1>
<p>The boost libraries are used extensively throughout Robot Raconteur The following classes are of particular interest by software using Robot Raconteur:</p>
<ul>
<li><code>boost::shared_ptr&lt;T&gt;</code></li>
<li><code>boost::make_shared&lt;T&gt;</code></li>
<li><code>boost::enable_shared_from_this&lt;T&gt;</code></li>
<li><code>boost::function&lt;...&gt;</code></li>
<li><code>boost::bind&lt;...&gt;</code></li>
<li><code>boost::signals2::signal&lt;...&gt;</code></li>
<li><code>boost::thread</code></li>
<li><code>boost::recursive_mutex</code></li>
<li><code>boost::posix_time::ptime</code></li>
</ul>
<p>Documentation for these types can be found in the <a href="https://www.boost.org/doc/libs/">Boost documentation</a>.</p>
<p>Robot Raconteur uses a number of preprocessor defines for Boost and C++11 types. These are all defined in <code><a class="el" href="_robot_raconteur_config_8h.html">RobotRaconteurConfig.h</a></code> These are used to allow for configurability. By default, the following defines are used: </p><pre class="fragment">#define RR_SHARED_PTR std::shared_ptr
#define RR_MAKE_SHARED std::make_shared
#define RR_WEAK_PTR std::weak_ptr
#define RR_ENABLE_SHARED_FROM_THIS std::enable_shared_from_this
#define RR_DYNAMIC_POINTER_CAST std::dynamic_pointer_cast
#define RR_STATIC_POINTER_CAST std::static_pointer_cast
#define RR_INTRUSIVE_PTR boost::intrusive_ptr
#define RR_UNORDERED_MAP boost::unordered_map
</pre><p>There are a number of defines that are used for incompatibilities between Boost and C++ versions. Consult <code><a class="el" href="_robot_raconteur_config_8h.html">RobotRaconteurConfig.h</a></code> for there definitions, since the definitions are configuration dependent. </p><pre class="fragment">RR_MOVE_ARG
RR_MOVE
RR_BOOST_ASIO_IO_CONTEXT
RR_BOOST_ASIO_STRAND
RR_BOOST_ASIO_POST(context, func)
RR_BOOST_ASIO_BUFFER_CAST(type,buf)
RR_BOOST_ASIO_STRAND_WRAP(strand, f)
RR_BOOST_ASIO_NEW_STRAND(context)
RR_BOOST_PLACEHOLDERS
</pre><h1><a class="anchor" id="cpp_smart_pointers"></a>
Smart Pointers and Aliases</h1>
<p>Robot Raconteur uses smart pointers for memory management. Smart pointers use "reference counting" to track the number of currently active references to an object or data. When the number of references go to zero, the object is deleted.</p>
<p>Two types of smart pointers are used: standard smart pointers, implemented using <code>boost::shared_ptr&lt;T&gt;</code>, and intrusive pointers, implemented using <code>boost::intrusive_ptr&lt;T&gt;</code>. The difference between these pointers is how the reference count is stored in memory. <code>boost::shared_ptr&lt;T&gt;</code> allocates a small amount of separate memory on the heap using <code>new</code> to store the reference count. This has the advantage of not affecting the object itself, but has the overhead of allocting and destroying this extra memory segment. <code>boost::intrusive_ptr</code> requires the object or structure to have a field specifically for reference counting declared in the object/structure itself.</p>
<p>Robot Raconteur uses <code>boost::shared_ptr&lt;T&gt;</code> for API objects, service objects, and service object references (proxies). <code>boost::intrusive_ptr&lt;T&gt;</code> is used for all value types. Value types inherit from <a class="el" href="class_robot_raconteur_1_1_r_r_value.html" title="Base class for all Robot Raconteur value types (except primitives)">RobotRaconteur::RRValue</a>, which contains the field for reference counting.</p>
<p>The preprocessor macros <code>RR_SHARED_PTR</code> and <code>RR_INTRUSIVE_PTR</code> are used internally for shared and intrusive pointer types. These are simply aliases to <code>boost::shared_ptr&lt;T&gt;</code> and <code>boost::intrusive_ptr&lt;T&gt;</code>.</p>
<p>For C++11 capable compilers, "template aliases" are available to make the code look cleaner. API types and generated types have these aliases declared. (RobotRaconteurGen will generate the aliases). A few (pseudocode) examples of aliases and their expansion: </p><pre class="fragment">RobotRaconteurNodePtr = boost::shared_ptr&lt;RobotRaconteurNode&gt;
RRArrayPtr&lt;int&gt; = boost::intrusive_ptr&lt;RRArray&lt;int&gt; &gt;
MyObjectPtr = boost::shared_ptr&lt;MyObject&gt; // Service definition generated object
MyStructPtr = boost::intrusive_ptr&lt;MyObject&gt; // Service definition generated struct
</pre><h1>Boost string_ref</h1>
<p><code>boost::string_ref</code> is used for string parameters in the Robot Raconteur library. The <code>boost::string_ref</code> is used instead of <code>std::string</code> to prevent runtime copies. It can be initialized from a <code>std::string</code>, a <code>char*</code> and length, or a string literal. It can be converted back to a string using <code>boost::string_ref::to_string()</code>. The conversions are normally done automatically, so the user does not need to do anything different compared to using normal <code>std::string</code> parameters. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
