<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: Service Definitions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Service Definitions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The following example code shows the code contained in the "experimental.create2.robdef" file. It is a <em>service definition</em>. Service definition files are plain text files that describe the <em>object types</em> and <em>value types</em> (data types). Object types are <em>references</em>, meaning that on the client they are simply an advanced reference (sometimes called a "proxy") to the service. Value types are the actual data that are transmitted between client and service. They are always passed by <em>value</em>, meaning that they are copied between the client or service when transmitted. </p><pre class="fragment">#Service to provide sample interface to the iRobot Create
service experimental.create2

stdver 0.10

struct SensorPacket
    field uint8 ID
    field uint8[] Data
end

object Create
    constant int16 DRIVE_STRAIGHT 32767
    constant int16 SPIN_CLOCKWISE -1
    constant int16 SPIN_COUNTERCLOCKWISE 1 

    function void Drive(int16 velocity, int16 radius)

    function void StartStreaming()
    function void StopStreaming()

    property int32 DistanceTraveled [readonly]
    property int32 AngleTraveled [readonly]
    property uint8 Bumpers [readonly]

    event Bump()

    wire SensorPacket packets [readonly]

    callback uint8[] play_callback(int32 DistanceTraveled, int32 AngleTraveled)
end
</pre><p>The first line in the service definition contains the keyword <code>service</code> followed by the name of the service type. The names of services follow similar rules to Java package names. For experimental software, the name should be prefixed with <code>experimental</code>, for example <code>experimental.create2</code>. For hobbyists and standalone software, the name should be prefixed with <code>community</code> and your username, for example <code>community.myusername.create</code>, where <code>myusername</code> is replaced with your robotraconteur.com username. If a domain name for an organization is available it can be used in the same way as Java packages, for example <code>com.wasontech.examples.create2</code>. Unless you have valid ownership of a domain, <code>experimenta</code> or <code>community</code> should be used.</p>
<p>Next in the service there should be <code>stdver</code> and the minimum version of Robot Raconteur required to access the service. For now this should be <code>0.10</code>. Example <code>createinterface</code> does not show it, but there can also be one or more <code>import</code> to reference structures and objects in other service definitions. The rest of service definition defines the <em>structures</em> and <em>objects</em> of the service definition. (Lines starting with <code>#</code> are comments.)</p>
<h1><a class="anchor" id="service_definition_names"></a>
Names</h1>
<p>User-defined names are used throughout service definitions. These names must:</p>
<ul>
<li>Contain only letters, numbers, and underscores</li>
<li>Not begin with a number</li>
<li>Not begin or end with an underscore</li>
<li>Not begin with "rr" or "robotraconteur" in any upper and lower case combination<ul>
<li>Service name segments are exempt from this rule</li>
</ul>
</li>
<li>Not begin with:<ul>
<li><code>get_</code></li>
<li><code>set_</code></li>
<li><code>async_</code></li>
</ul>
</li>
<li>Not be a keyword</li>
</ul>
<p>The following keywords are reserved:</p>
<p><code>object</code> <code>end</code> <code>option</code> <code>service</code> <code>struct</code> <code>import</code> <code>implements</code> <code>field</code> <code>property</code> <code>function</code> <code>event</code> <code>objref</code> <code>pipe</code> <code>callback</code> <code>wire</code> <code>memory</code> <code>void</code> <code>int8</code> <code>uint8</code> <code>int16</code> <code>uint16</code> <code>int32</code> <code>uint32</code> <code>int64</code> <code>uint64</code> <code>single</code> <code>double</code> <code>string</code> <code>varvalue</code> <code>varobject</code> <code>exception</code> <code>using</code> <code>constant</code> <code>enum</code> <code>pod</code> <code>namedarray</code> <code>cdouble</code> <code>csingle</code> <code>bool</code> <code>stdver</code></p>
<h1><a class="anchor" id="value_types"></a>
Value Types</h1>
<p>Value types are the data that are passed between the client and service. Value types can be <em>primitives</em>, <em>structures</em>, <em>pods</em>, <em>namedarrays</em>, <em>maps</em>, <em>lists</em> <em>multidimensional arrays</em>, or <em>enums</em>.</p>
<h2>Primitives</h2>
<p>Primitives consist of scalar numbers, single dimensional number arrays, and strings. The table below contains the primitives that are available for use. Primitive numerical types can be turned into arrays by appending brackets <code>[]</code> to the end, for example <code>int32[]</code> is an array of 32 bit signed integers. If a fixed size array is desired, a number can be included between the brackets for the desired array size, for example <code>int32[8]</code> has a fixed length of 8 integers. If an array is desired that has a maximum size, a <code>-</code> sign can be included in the brackets, for example <code>int32[100-]</code> can have up to 100 integers. Strings are always arrays so the brackets are not valid. The <code>void</code> type is only used for function declarations that do not have a return value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Bytes/Element </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void</code> </td><td class="markdownTableBodyNone">0 </td><td class="markdownTableBodyNone">Void  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>double</code> </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">Double precision floating point  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>single</code> </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">Single precision floating point  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int8</code> </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">Signed 8-bit integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint8</code> </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">Unsigned 8-bit integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int16</code> </td><td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">Signed 16-bit integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint16</code> </td><td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">Unsigned 16-bit integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int32</code> </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">Signed 32-bit integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint32</code> </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">Unsigned 32-bit integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int64</code> </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">Signed 64-bit integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>uint64</code> </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">Unsigned 64-bit integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>string</code> </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">UTF-8 string  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cdouble</code> </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">Complex double precision floating point  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>csingle</code> </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">Complex single precision floating point  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>bool</code> </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">Logical boolean  </td></tr>
</table>
<h2>Structures</h2>
<p>Structures are collections of value types; structures can contain primitives, other structures, maps, or multidimensional arrays. The example <code>experimental.create2</code> service definition shows the definition of the structure <code>SensorPacket</code>. A structure is started with the keyword <code>struct</code> followed by the structure name. It is ended with the <code>end</code> keyword. The entries in the structure are defined with the keyword <code>field</code> followed by the type, and finally the name of the field. If a structure from a different service definition is used, first the referenced service definition is imported at the top of the service definition and the structure is referenced by the external service definition <code>dot</code> the name of the structure.</p>
<h2>Pods</h2>
<p>Pods (short for "plain-old-data") are similar to structures, but are more restricted to ensure they have the same size. All data stored in pods are stored contiguously (c-style), while structs use pointers to the data. Pods can only contain pods, arrays of pods (fixed or max length), namedarrays, and namedarrays arrays (fixed or max length). Only numeric primitives may be used; strings, structs, lists, and maps may not be stored in pods. A pod is started with the keyword <code>pod</code> followed by the pod name. It is ended with the <code>end</code> keyword. The entries in the pod are defined with the keyword <code>field</code> followed by the type, and finally the name of the field. If a pod from a different service definition is used, first the referenced service definition is imported at the top of the service definition and the pod is referenced by the external service definition <code>dot</code> the name of the pod. Pods can be used with arrays and multi-dim arrays.</p>
<h2>Namedarrays</h2>
<p>Namedarrays are a union type designed to store numeric arrays that also have specific meanings attached to each entry. An example is a 3D vector. The vector can either be viewed as a 3x1 array, or as a structure containing three fields, (x,y,z). A namedarray stores the contained data as a primitive array, but allows the data to be viewed as a structure. Namedarrays should be used when possible since they have the most compact memory format. Namedarrays can only contain numeric primitives, fixed numeric primitive arrays (no multidimarrays), other namedarrays (with the same numeric type), and fixed arrays of namedarrays. A namedarray is started with the keyword <code>namedarray</code> followed by the namedarray name. It is ended with the <code>end</code> keyword. The entries in the namedarray are defined with the keyword <code>field</code> followed by the type, and finally the name of the field. If a namedarray from a different service definition is used, first the referenced service definition is imported at the top of the service definition and the namedarray is referenced by the external service definition <code>dot</code> the name of the namedarray. Namedarrays can be used with arrays and multi-dim arrays.</p>
<h2>Maps</h2>
<p>Maps can either be keyed by <code>int32</code> or <code>string</code>. In other languages they would be called <code>Dictionary</code>, <code>Hashtable</code>, or <code>Map</code>. The contained data is a value type, but the contained data may not be another container type (map or list). They are created with curly braces. For example, <code>string{int32}</code> would be a map of strings keyed by an integer. <code>string{string}</code> would be a map of strings keyed by another string. <code>SensorPacket{string}</code> and <code>int32[]{int32}</code> are also valid examples. <code>string{int32}{int32}</code> is <b>not</b> valid. There can only be one dimension of map keying and/or lists.</p>
<h2>Lists</h2>
<p>Lists follow similar rules to maps. They are created with curly braces. For example, <code>string{list}</code> would be a list of strings. <code>SensorPacket{list}</code> and <code>int32[]{list}</code> are also valid examples. <code>string{list}{list}</code> is <b>not</b> valid. There can only be one dimension of lists and/or map keying.</p>
<h2>Multidimensional Arrays</h2>
<p>The multidimensional arrays allow for the transmission of real or complex matrices of any dimension. They are defined by putting a <code>*</code> inside the brackets of an array. For example, <code>double[*]</code> defines a multidimensional array of doubles. Multidimensional arrays can also have fixed dimensions. For example <code>double[3,3]</code> defines a 3x3 matrix. The dimensions are in matrix (column-major) order.</p>
<h2>Enums</h2>
<p>Enums are a special representation of int32 that names each value. Enums are aliases, with the value be stored as int32 internally. An enum is started with the keyword <code>enum</code> followed by the enum name. It is ended with the <code>end</code> keyword. The values are specified with a <code>name = value</code> format, separated by commas. Values can be signed integers, unsigned hexadecimal, or omitted to implicitly increment from the last value. </p><pre class="fragment">enum myenum
    value1 = -1,
    value2 = 0xF1,
    value3,
    value4
end
</pre><h2>varvalue</h2>
<p>In certain situations it may be desirable to put in a "wildcard" value type. The varvalue type allows this. Use with caution!</p>
<p><b>Note: structs, maps, lists, and varvalue can be null. All other types are non-nullable. (NULL, None, etc. depending on language).</b></p>
<h1><a class="anchor" id="object_types"></a>
Object Types</h1>
<p>Objects begin with the keyword <code>object</code> followed by the name of the object, and closed with the keywords <code>end</code>. Objects have <code>members</code> that implement functionality. Within Robot Raconteur there are eight types of members: Properties, Functions, Events, ObjRefs, Pipes, Callbacks, Wires, and Memories . They are defined between <code>object</code> and <code>end</code>, with one member per line.</p>
<h2>Properties</h2>
<p>Keyword: <code>property</code></p>
<p>Properties are similar to class variables (fields). They can be written to (set) or read from (get). A property can take on any valid value type. A property is defined within an object with the keyword <code>property</code> followed by the value type of the property, and finally the name of the property. (All member names within an objectmust be unique). An example: </p><pre class="fragment">property double myvar
</pre><p>Properties can use modifiers <code>readonly</code>, <code>writeonly</code>, <code>urgent</code>, and/or <code>perclient</code>. See modifiers.</p>
<h2>Functions</h2>
<p>Keyword: <code>function</code></p>
<p>Functions take zero or more value type parameters, and return a single value type. The parameters of the functions must all have unique names. The return value of the function may be <code>void</code> if there is no return. A function is defined by the keyword <code>function</code> followed by the return type, followed by the name of the function. The parameters follow as a comma separated list of parameter type and parameter name. The parameter list is enclosed with parenthesis. An example: </p><pre class="fragment">function double addTwoNumbers(int32 a, double b)
</pre><p>Functions can also return a "generator", which is a form of iterator. (These generators are modeled after Python generators.) This is useful for long running operations or to return large amounts of data. Generators take three forms. The first is when each iteration of the generator takes a parameter and returns a value. This takes the form: </p><pre class="fragment">function double{generator} addManyNumbers(int32 a, double{generator} b)}
</pre><p>In this example, the <code>a</code> parameter is sent with the function call, while <code>b</code> and <code>return</code> are sent and received using the <code>Next</code> function of the generator.</p>
<p>The next form of the generator returns a value each iteration of the generator. </p><pre class="fragment">function double{generator} getSequence(int32 a, double b)
</pre><p>In this example, <code>a</code> and <code>b</code> are sent with the function call, and <code>return</code> is returned using the <code>Next</code> function of the generator.</p>
<p>The last form takes a parameter each iteration. </p><pre class="fragment">function void accumulateNumbers(double{generator} b)}
</pre><p>Note that the generator return must be <code>void</code> or a generator type. Each call to <code>Next</code> will receive a parameter.</p>
<p>Generators will throw either <code>StopIterationException</code> to signal that the generator is finished, or it will throw <code>OperationAbortedException</code> to signal that there was an error and the generator should be destroyed. Generators clients must call <code>Close</code> or <code>Abort</code> on a generator if a <code>StopIterationException</code> or other exception is not received.</p>
<p>Generators that represent long running operations should return from <code>Next</code> with updated status information at least every 10 seconds to prevent timeout errors.</p>
<p>Functions can use the <code>urgent</code> modifier. See modifiers.</p>
<h2>Events</h2>
<p>Keyword: <code>event</code></p>
<p>Events provide a way for the service to notify clients that an event has occurred. When an event is fired, every client reference receives the event. How the event is handled is language-specific. An event is defined similar to a function, however there is no return. The parameters are passed to the client. There is no return. An example: </p><pre class="fragment">event somethingHappened(string what, double when)
</pre><p>Note that events do not have flow control, so they should be used sparingly.</p>
<p>Events can use the <code>urgent</code> modifier. See modifiers.</p>
<h2>Object References</h2>
<p>Keyword: <code>objref</code></p>
<p>A service consists of any number of objects. The <b>root object</b> is the object first referenced when connection to a service. The other object references are obtained through <code>objref</code> members. These members return a reference to the specified object. An objref is defined by the keyword <code>objref</code> followed by the object type followed by the objref member name. The object type can be <code>varobject</code> to return any valid object type (Use with caution!). The objref can also be indexed by number ([],{int32}) or by string ({string}). This returns a different reference based on the index. It does not return a set of references. An example: </p><pre class="fragment">objref mysubobj anotherobj{string}
</pre><p>If an object from a different service definition is used, first the referenced service definition is imported at the top of the service definition and the object is referenced by the external service definition <code>dot</code> the name of the object.</p>
<h2>Pipes</h2>
<p>Keyword: <code>pipe</code></p>
<p>Pipes provide full-duplex first-in, first-out (FIFO) connections between the client and service. Pipes are unique to each client, and are indexed so that the same member can handle multiple connections. The pipe member allows for the creation of <code>PipeEndpoint</code> pairs. One endpoint is on the client side, and the other is on the server side. For each connected pipe endpoint pair, packets that are sent by the client appear at service end, and packets that are sent by the service end up on the client side. Packets can be retrieved in order from the receive queue in the <code>PipeEndpoint</code>. The type of the packets is defined by the member definition. An endpoint can request a Packet Acknowledgment to be sent once the packet is received by setting <code>RequestPacketAck</code> to true. <code>SendPacket</code> is used to send packets, and <code>ReceivePacket</code> is used to receive the next packet in the queue. <code>Available</code> can be used to determine is more packets are available to receive. Pipe endpoint pairs are created with the <code>Connect</code> function on the client. Either the client or the service can close the endpoint pair using the <code>Close</code> function. A pipe is specified by the keyword <code>pipe</code> followed by the packet type, followed by the member name of the pipe. An example: </p><pre class="fragment">pipe double[] sensordata
</pre><p>Pipes can use modifiers <code>readonly</code>, <code>writeonly</code>, and <code>unreliable</code>. See modifiers. Pipes are normally reliable, with packets guaranteed to arrive in order without loss, as long as the transport connection is active. Pipes marked <code>unreliable</code> do not guarantee delivery or order of packets. Pipes marked <code>readonly</code> are often used with <code>PipeBroadcaster</code> to send packets to all connected clients.</p>
<h2>Callbacks</h2>
<p>Keyword: <code>callback</code></p>
<p>Callbacks are essentially <code>reverse functions</code>, meaning that they allow a service to call a function on a client. Because a service can have multiple clients connected, the service must specify which client to call. The syntax is equivalent to the <code>function</code>, just replace <code>function</code> with <code>callback</code>. An example: </p><pre class="fragment">callback double addTwoNumbersOnClient(int32 a, double b)
</pre><p>Callbacks do not support generators.</p>
<h2>Wires</h2>
<p>Keyword: <code>wire</code></p>
<p>Wires are very similar to pipes, however rather than providing a stream of packets the wire is used when only the "most recent" value is of interest. It is similar in concept to a "port" in Simulink. Wires may be transmitted over lossy channels or channels with latency where packets may not arrive or may arrive out of order. In these situations the lost or out of order packet will be discarded and only the newest value will be used. Each packet has a timestamp of when it is sent (from the sender's clock). Wires are full duplex like pipes meaning it has two-way communication, but unlike pipes they are not indexed so there is only one connection per client object reference. The wire allows for a <code>WireConnection</code> pair to be created with one <code>WireConnection</code> on the client and the other <code>WireConnection</code> on the service. Unlike pipes, each wire member can only create one connection pair per client, per service object instance. The <code>WireConnection</code> is used by setting the <code>OutValue</code> to the current value. This sends the new value to the opposite <code>WireConnection</code>, which updates its <code>InValue</code>. The same can be reversed. For instance, setting the <code>OutValue</code> on the service changes the <code>InValue</code> on the client, and setting the <code>OutValue</code> on the client changes the <code>InValue</code> on the service. It as also possible to receive the <code>LastValueReceivedTime</code> and <code>LastValueSentTime</code> to read the timestamps on the values. Note that <code>LastValueReceivedTime</code> is in the <em>sender's</em> clock, not the local clock and is generated when it is first transmitted. Either the client or the service can close the <code>WireConnection</code> pair using the <code>Close</code> function.</p>
<p>When a <code>WireConnection</code> pair is created by the client, the most recent values begin streaming between the pair. Sometimes the client needs to read the <code>InValue</code> or set the <code>OutValue</code>, but does not require a streaming update. The <code>Wire</code> provides <code>PeekInValue</code>, <code>PeekOutValue</code>, and <code>PokeOutValue</code> for this purpose. These functions use request-response instead of streaming the most recent values.</p>
<p>An example wire member definition: </p><pre class="fragment">wire dobule[2] currentposition
</pre><p>Wires can use modifiers <code>readonly</code> or <code>writeonly</code>. See modifiers.</p>
<h2>Memories</h2>
<p>Keyword: <code>memory</code></p>
<p>Memories represent a random-access segment of numeric primitive arrays, numeric primitive multi-dim arrays, pod arrays, pod multi-dim arrays, namedarrays arrays, and namedarrays multi-dim arrays. The memory member is available for two reasons: it will break down large read and writes into smaller calls to prevent buffer overruns (most transports limit message sizes to 10 MB) and the memory also provides the basis for future shared-memory segments. An example: </p><pre class="fragment">memory double[] datahistory
</pre><p>Memories can use modifiers <code>readonly</code> or <code>writeonly</code>. See modifiers.</p>
<h1><a class="anchor" id="constants"></a>
Constants</h1>
<p>Constants can be specified using the \texttt{constant} keyword. The constants can be numbers, single dimensional arrays, or strings. Constants can be declared either in the global service definition scope or in objects. </p><pre class="fragment">constant uint32 myconst 0xFB}
constant double[] myarray {10.3, 584.9, 594}
constant string mystring "Hello world!"
</pre><h1><a class="anchor" id="exceptions"></a>
Exceptions</h1>
<p>Robot Raconteur will transparently pass exceptions thrown by the receiver to the caller for transactions such as functions, properties, callbacks, and memory reads/writes. Normally these exceptions are of the type RobotRaconteurRemoteException which is a universal container for all types of exceptions. In some cases it is useful to have named exceptions that can be passed from receiver to caller and keep their class type. These custom exceptions inherit from RobotRaconteurRemoteException. Service definitions can define these exceptions. Exceptions are defined by starting the line with <code>exception</code> followed by the name of the exception. For example, the following line will define the exception "MyException" which can then be used in any of the supported languages: </p><pre class="fragment">exception MyException
</pre><h1><a class="anchor" id="using"></a>
Using</h1>
<p>To reduce the clutter in a service definition file, the <code>using</code> statement can be used to alias an imported type. </p><pre class="fragment">using example.importeddef.obj1 
</pre><p><code>as</code> can be used to change the name locally. </p><pre class="fragment">using exmaple.importeddef.obj1 as another_obj1
</pre><h1><a class="anchor" id="conventions"></a>
Conventions</h1>
<p>Some conventions are recommended for service definition formatting:</p>
<ul>
<li>Service names should use Java style package names, using reverse domain name order. All letters should be lowercase. <code>experimental</code> or <code>communication</code> can be used for the TLD if no domain is available.</li>
<li>Enumeration, structure, pod, namedarray, and object names should be nouns with each internal word capitalized (UpperCamelCase)</li>
<li>All letters in constant names should be capitalized with internal words separated with underscores (ALL_CAPS)</li>
<li>Field names, member names, parameter names, modifier names, and enumeration values should use lowercase for letters, and separate each internal word with underscores (snake_case)</li>
<li>Service definition scope declaration should not be indented. Fields, members, and enum values should be indented four spaces. Tabs should not be used for indentation.</li>
<li>It is suggested that lines be split after 79 characters using the line continuation character <code>\</code></li>
<li>Line continuations should be indented four spaces more than the line before the continuation. Additional line continuations should match the indentation of the first continuation.</li>
<li>Comments should match the indentation of the relevant declaration </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
