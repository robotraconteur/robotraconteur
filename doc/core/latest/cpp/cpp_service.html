<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: C++ Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Services </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_C__Users_wasonj_Documents_RobotRaconteur2_robotraconteur_docs_cpp_cpp_service"></a> Robot Raconteur is an object-oriented client-service RPC framework. Services expose objects, which are made available to clients using "object references", sometimes referred to as "proxies". See <a class="el" href="introduction.html">Introduction</a> for an overview of the Robot Raconteur framework.</p>
<p>The object types and their members are defined in "service definition" files. See <a class="el" href="service_definition.html">Service Definitions</a> for more information on how service objects are defined. C++ uses <code>RobotRaconteurGen</code> to generate "thunk" source that implements the object and value types defined in service definitions. See <a class="el" href="cpp_introduction.html#cpp_intro_cmake_thunk_source_gen">CMake and Robot Raconteur Thunk Source Generation</a>, <a class="el" href="robotraconteurgen.html"><code>RobotRaconteurGen</code> Utility</a>, and <a class="el" href="robotraconteur_generate_thunk.html">CMake <code>ROBOTRACONTEUR_GENERATE_THUNK</code> Macro</a> for more information on thunk source and thunk source generation.</p>
<p>For C++, the thunk source generates an abstract class with pure virtual functions for accessing the members. Services implement these abstract interfaces by creating objects that implement the defined members. Robot Raconteur then creates object references and member proxies to allow clients to interact with the members from the remote node.</p>
<p>Developing C++ services is not a trivial task. Because of the design of C++, the creation of security flaws or other terminal bugs is difficult to avoid for novice programmers. The use of Python, C#, or Java is recommended unless C++ is absolutely necessary.</p>
<h1>Registering Services</h1>
<p>Services are registered with a node using <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a074209e23f46fbdd14dd43aa7773caf7" title="Registers a service for clients to connect.">RobotRaconteur::RobotRaconteurNode::RegisterService()</a>. This function takes the name of the service, the name of the service definition of the root object, and the root object instance. The root object must implement an abstract interface generated from a service definition. See <a class="el" href="cpp_service.html#cpp_service_implement_objects">Implementing Service Objects</a>. Once registered, the root object will be available to services.</p>
<p>The node must be configured to accept incoming connections. See <a class="el" href="cpp_node_setup.html">C++ Node Setup</a>.</p>
<p>The service may have security configured. See <a class="el" href="cpp_service.html#cpp_service_security">Service Security</a>.</p>
<h1><a class="anchor" id="cpp_service_server_context"></a>
Server Context</h1>
<p>Each service is managed by an instance of <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">RobotRaconteur::ServerContext</a>. This object interacts with the node to receive and send messages. It manages the service objects and client connections. See <a class="el" href="class_robot_raconteur_1_1_server_context.html" title="Context for services registered in a node for use by clients.">RobotRaconteur::ServerContext</a> for the public API. It can be accessed using the RobotRaconteur::RRServiceObject interface, the return from <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a074209e23f46fbdd14dd43aa7773caf7" title="Registers a service for clients to connect.">RobotRaconteur::RobotRaconteurNode::RegisterService()</a>, or using the <a class="el" href="class_robot_raconteur_1_1_server_context.html#ae341049bab4fb4710b4bbfc0f07cc1c8" title="Get the current ServerContext.">RobotRaconteur::ServerContext::GetCurrentServerContext()</a> function.</p>
<h1><a class="anchor" id="cpp_service_server_endpoint"></a>
Server Endpoints</h1>
<p>Each client has a <a class="el" href="class_robot_raconteur_1_1_server_endpoint.html" title="Server endpoint representing a client connection.">RobotRaconteur::ServerEndpoint</a> associated with it. It can be accessed during member calls using <a class="el" href="class_robot_raconteur_1_1_server_endpoint.html#a357c10bed763628d1a9862c02d8018cf" title="Returns the current server endpoint.">RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()</a>. The server endpoint is used by members to identify a client. The function <a class="el" href="class_robot_raconteur_1_1_server_endpoint.html#a9771dc6e0d91500a9eb401325dc96756" title="Returns the current authenticated user.">RobotRaconteur::ServerEndpoint::GetCurrentAuthenticatedUser()</a> can be used to retrieve the authentication for the current server endpoint. To retrieve the <code>uint32_t</code> endpoint ID, use <a class="el" href="class_robot_raconteur_1_1_server_endpoint.html#a357c10bed763628d1a9862c02d8018cf" title="Returns the current server endpoint.">RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()</a>-&gt;GetLocalEndpoint().</p>
<h1><a class="anchor" id="cpp_service_service_path"></a>
Service Paths</h1>
<p>Each object in a service has a "service path" that uniquely identifies the object. See <a class="el" href="nodes_and_communication.html#service_paths">Service Paths</a> for more information.</p>
<h1><a class="anchor" id="cpp_service_implement_objects"></a>
Implementing Service Objects</h1>
<p>Services expose implementations of object types for use by clients. These implementations contain the real functionaly that the service provides. For instance, a robot driver service object would have members that command the robot. This command can be done through a proprietary API provided by the robot vendor, directly using hardware registers, or one of the other variety of ways that software can interact directly with hardware. The implementation may also be a software component such as a robot planner. The members are used to command the planner to generate robot plans based on parameters passed through the members. Robot Raconteur is not specific about what the implementation of each service object does, rather Robot Raconteur is designed to provide access to the object members from a remote node through a client connection. It is up to the developer of the service to decide what the implemented object actually does. It is also up to the service developer to decide what object, member, and value types need to be used to implement a service. The use of standardized or commonly used service definitions is recommended to increase compatibility between services. Custom service definitions can be created if necessary, but should be avoided if possible.</p>
<p>The thunk source generated by <code>RobotRaconteurGen</code> or the CMake macro contains an "abstract interface" and a "default implementation" for each object type defined in the service definition. The "abstract interface" is a C++ class with pure virtual functions for each member. On the client, these pure virtual functions are implemented to proxy the interactions to the service. On the service side, a class implementing these virtual functions is expected. The implementation of the interface should extend the interface. A "default implementation" is also generated by the thunk source alongside the abstract interface. This is a bare-bones implementation extending the abstract interface. The service developer can extend this "default implementation" instead of extending the abstract interface directly. The developer can use the behavior of the "default implementation", overriding member virtual functions when necessary to change the behavior of the object. The rest of this section assumes that the developer chooses to use the "default implementation".</p>
<p><b>Note that virtual inheritance must always be used with Robot Raconteur service objects!</b></p>
<p>Consider the following example service definition: </p><pre class="fragment">service experimental.service_example1

object MyObject
    property double my_property
    function void my_function()
end
</pre><p>The generated C++ "abstract interface" thunk source results in the following: </p><pre class="fragment">// In namespace experimental::service_example1
// Modified for brevity
class MyObject : public virtual RobotRaconteur::RRObject
{
public:
    virtual double get_my_property()=0;
    virtual void set_my_property(double value)=0;

    virtual void my_function()=0;
};

using MyObjectPtr = boost::shared_ptr&lt;MyObject&gt;;
</pre><p>The service developer is responsible for developing a subclass of <code>MyObject</code> that implements all of the pure virtual functions. The exact form of pure virtual function function for each member is discussed later in this section.</p>
<p>The "default implementation" for <code>MyObject</code> results in the following declaration: </p><pre class="fragment">// In namespace experimental::service_example1
// Modified for brevity
class MyObject_default_impl : public virtual MyObject, public virtual RobotRaconteur::RRObject_default_impl
{
protected:
    double rrvar_my_property;

public:
    MyObject_default_impl();
    virtual double get_my_property();
    virtual void set_my_property(double value);

    virtual void my_function();        
};
</pre><p>and implementation: </p><pre class="fragment">// In namespace experimental::service_example1
// Modified for brevity

MyObject_default_impl::MyObject_default_impl()
{
    rrvar_my_property=0.0;
}

double MyObject_default_impl::get_my_property()
{
    boost::mutex::scoped_lock lock(this_lock);
    return rrvar_my_property;
}
void MyObject_default_impl::set_my_property(double value)
{
    boost::mutex::scoped_lock lock(this_lock);
    rrvar_my_property = value;
}
void MyObject_default_impl::my_function()
{
    throw RobotRaconteur::NotImplementedException("");
}
</pre><p>The "default implementation" is a class named with the object name with <code>_default_impl</code> appended. In the above example, the property <code>my_property</code> and function <code>my_function</code> are implemented by the default implementation. The property implementation stores the value of the property in a class field named with the property named prefixd with <code>rrvar_</code>. The accessors use <code>this_lock</code> for thread locking. <code>this_lock</code> is defined in <a class="el" href="class_robot_raconteur_1_1_r_r_object__default__impl.html" title="Base class for default service object implementations.">RobotRaconteur::RRObject_default_impl</a>, which is a virtual base class of all default implementations. Thu function <code>my_function</code> will throw <a class="el" href="class_robot_raconteur_1_1_not_implemented_exception.html" title="Exception thrown if a member is not implemented.">RobotRaconteur::NotImplementedException</a> when invoked. The service developer must implement this virtual function in the subclass of the default implementation.</p>
<p>The following is an example implementation of <code>MyObject</code> that uses the default implementation: </p><pre class="fragment">using namespace RobotRaconteur;
using namespace experimental::service_example1

class MyObjectImpl : public virtual MyObject_default_impl
{
public:
    virtual void set_my_property(double value)
    {
        if (value &lt; 0.0)
        {
            throw RobotRaconteur::InvalidArgumentException("my_property must not be negative");
        }

        boost::mutex::scoped_lock lock(this_lock);
        rrvar_my_property = value;
    }

    virtual void my_function()
    {
        double p;
        {
            boost::mutex::scoped_lock lock(this_lock);
            p = rrvar_my_property;
        }
        std::cout &lt;&lt; "my_property is currently: " &lt;&lt; p &lt;&lt; std::endl;
    }  
};
</pre><p>This implementation does a bounds check on <code>my_property</code>, and implements <code>my_function</code> to print the current value to the terminal on the service side. Note the use of <code>this_lock</code> to protect <code>rrvar_my_property</code>. This is necessary because member calls on service objects come from the thread pool. Multiple threads may call members concurrently, which can lead to data corruption. Use <code>this_lock</code> to protect data that can be corrupted by concurrent calls. See <a class="el" href="cpp_threading_and_async.html">C++ Multithreading and Asynchronous Functions</a> for more information on the thread pool.</p>
<p>The generated thunk source also provides an "abstract default implementation". The "abstract default implementation" ends with <code>_abstract_default_impl</code> and is intended to be used if a class extends another <code>_default_impl</code> class.</p>
<h2><a class="anchor" id="cpp_service_irrserviceobject_interface"></a>
&lt;tt&gt;IRRServiceObject&lt;/tt&gt; Interface</h2>
<p>Object members such as <code>pipe</code>, <code>wire</code>, and <code>callback</code> need to be initialized by the service before they can be used. Service objects may inherit RobotRaconteur::IRRServiceObjectIntereface to be notified when the object has been initialized. The function <a class="el" href="class_robot_raconteur_1_1_i_r_r_service_object.html#ab45c25bc3c3e9c9694208a1387007ab1" title="Function called after service object has been initialized.">RobotRaconteur::IRRServiceObject::RRServiceObjectInit()</a> is called when the initialization is complete.</p>
<p>An example that improves <code>MyObjectImpl</code> to implement <code>IRRServiceObject</code>: </p><pre class="fragment">using namespace RobotRaconteur;
using namespace experimental::service_example1

class MyObjectImpl : public virtual MyObject_default_impl, public virtual IRRServiceObject
{
protected:
    boost::weak_ptr&lt;ServerContext&gt; ctx;
    std::string this_service_path;

public:

    virtual void RRServiceObjectInit(boost::weak_ptr&lt;ServerContext&gt; ctx, const std::string&amp; service_path)
    {
        // Save ctx and service_path for later use
        this-&gt;ctx = ctx;
        this_service_path = service_path;

        // Do other initialization tasks here
    }

    virtual void set_my_property(double value)
    {
        if (value &lt; 0.0)
        {
            throw RobotRaconteur::InvalidArgumentException("my_property must not be negative");
        }

        boost::mutex::scoped_lock lock(this_lock);
        rrvar_my_property = value;
    }

    virtual void my_function()
    {
        double p;
        {
            boost::mutex::scoped_lock lock(this_lock);
            p = rrvar_my_property;
        }
        std::cout &lt;&lt; "my_property is currently: " &lt;&lt; p &lt;&lt; std::endl;
    }  
};
</pre><h2><a class="anchor" id="cpp_service_property"></a>
Property Members</h2>
<p>Property members allow clients to "get" and "set" a property value on the service object. Properties may use any valid Robot Raconteur value type.</p>
<p>Property members are implemented as two access functions in the object, a "get" and "set" function. The "get" function is the name of member prepended with <code>get_</code>. It takes no arguments, and returns the current value. The "set" function is the name of the member prepended with <code>set_</code>. It takes the new property value, and returns void. Service objects must implement the accesor functions, or use the <code>_default_impl</code> defaul implementation of the property.</p>
<p>For example, the property definition: </p><pre class="fragment">property double my_property
</pre><p>An example implementation of the property accessors: </p><pre class="fragment">virtual double get_my_property()
{
    boost::mutex::scoped_lock lock(this_lock);

    // Return the current property value here
}
virtual void set_my_property(double val)
{
    boost::mutex::scoped_lock lock(this_lock);

    // Set the property value here
}
</pre><p>Properties can be declared <code>readonly</code> or <code>writeonly</code> using member modifiers. If a property is <code>readonly</code>, the <code>set_</code> accessor function is not used. If a property is <code>writeonly</code>, the <code>get_</code> accessor function is not used.</p>
<p>Properties can be implemented as asynchronous functions instead of the synchronous accessors above. The thunk source generates an asynchronous version of the abstract interface class that has asynchronous versions of the property member accessors and function members. The asynchronous interface starts with <code>async_</code> followed by the object name. The asynchronous accessor functions start with <code>async_get_</code> and <code>async_set_</code>. If the service object extends the asynchronous interface, the property and function members will always call the asynchronous versions. The <code>async_set_</code> accessor will not be generated if the property is declared <code>readonly</code>. The <code>async_get_</code> accessor will not be generated if the property is declared <code>writeonly</code>.</p>
<h2><a class="anchor" id="cpp_service_function"></a>
Function Members</h2>
<p>Function members allow clients to invoke a function on the service object. Functions may have zero or more value type parameters, and return a value or be declared <code>void</code> for no return. Functions may be "normal", not using a generator, or be "generator functions" which return a generator.</p>
<h3><a class="anchor" id="cpp_service_normal_functions"></a>
Normal Functions</h3>
<p>Normal functions accept zero or more value type parameters, invoke the remote function with these parameters, and return the result, or <code>void</code>. They are implemented in the abstract interface as a C++ function with the same name as the member.</p>
<p>For example, the function definition: </p><pre class="fragment">function double addTwoNumbers(int32 a, double b)
</pre><p>An example implementation of the function: </p><pre class="fragment">virtual double addTwoNumbers(int32_t a, double b)
{
    return (double)a + b;
}
</pre><p>An example function definition with no parameters and void return: </p><pre class="fragment">functon void do_something()
</pre><p>An example implementation of the function: </p><pre class="fragment">virtual void do_something()
{
    // Do the operation
}
</pre><p>Functions can be implemented as asynchronous functions instead of synchronous functions. The thunk source generates an asynchronous version of the abstract interface class that has asynchronous versions of function members. The asynchronous interface starts with <code>async_</code> followed by the object name. The asynchronous function implementation start with <code>async_</code> followed by the member name. If the service object extends the asynchronous interface, the asynchronous versions of the functions will always be called.</p>
<h3><a class="anchor" id="cpp_service_generator_functions"></a>
Generator Functions</h3>
<p>Generator functions are similar to normal functions, but instead of returning a value or void, they return a generator. A generator is similar to an iterator, or can implement a coroutine. See <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> and <a class="el" href="service_definition.html#service_definition_function">Functions</a> for more discussion on generators.</p>
<p>Generators may be Type 1, 2, or 3 depending on the argument and return value configuration for <code>Next()</code>. See <a class="el" href="cpp_client.html#cpp_client_generator_functions">Generator Functions</a> for a discussion of these different generator types.</p>
<p>The service implementation of generator functions must return a generator object. This generator object must extend <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a>. The client will then be able to call the generator using the generator reference provided to the client. <a class="el" href="class_robot_raconteur_1_1_generator.html" title="Generator type for use with generator functions, with parameter and return.">RobotRaconteur::Generator</a> has pure virtual functions for <code>Next()</code>, <code>Abort()</code>, <code>Close()</code>, and the asynchronous versions <code>AsyncNext()</code>, <code>AsyncAbort()</code>, and <code>AsyncClose()</code>. By default, the service will always call the asynchronous versions of these functions. If the service prefers to use synchronous versions of these function, the generator implementation can extend <a class="el" href="class_robot_raconteur_1_1_sync_generator.html" title="Helper class for synchronous service generators.">RobotRaconteur::SyncGenerator</a>.</p>
<p>An example service definition containing a generator function to count to 100 with a given start: </p><pre class="fragment">service experimental.service_example2

object MyObject
    function int32{generator} count_to_100(int32 start)
end
</pre><p>An implementation of <code>MyObject</code> and the generator returned by <code>count_to_100()</code>: </p><pre class="fragment">using namespace RobotRaconteur;
using namespace experimental::service_example2;

class CountTo100Generator : public virtual SyncGenerator&lt;int32_t,void&gt;
{
protected:
    int32_t count = 0;        
    bool aborted = false;
    bool closed = false;
    boost::mutex this_lock;

public:
    CountTo100Generator(int32_t start)
    {
        count = start;
    }

    virtual int32_t Next()
    {
        boost::mutex::scoped_lock lock(this_lock);

        if (aborted)
        {
            // Throw OperationAbortedException if the generator was aborted
            throw OperationAbortedException("");
        }

        if (closed || count &gt; 100)
        {
            // Throw StopIterationException if generator is complete or closed
            closed = true;
            throw StopIterationException("");
        }

        return count++;
    }

    virtual void Close()
    {
        boost::mutex::scoped_lock lock(this_lock);
        // Close the generator
        closed = true;
    }

    virtual void Abort()
    {
        boost::mutex::scoped_lock lock(this_lock);
        // Abort the generator
        aborted = true;
    }    
};

class MyObjectImpl : public virtual MyObject_default_impl
{
public:
    GeneratorPtr&lt;int32_t,void&gt; count_to_100(int32_t start)
    {
        boost::mutex::scoped_lock lock(this_lock);

        if (start &lt; 1 || start &gt; 100)
        {
            throw InvalidArgumentException("start must be between 1 and 100");
        }

        return boost::make_shared&lt;CountTo100Generator&gt;(start);
    }
};
</pre><p>As shown in the above example, the generator should return values until complete. If the generator runs out of values or is closed, it should throw <a class="el" href="class_robot_raconteur_1_1_stop_iteration_exception.html" title="Exception thrown when a generator has finished sending results.">RobotRaconteur::StopIterationException</a>. If the generator is aborted, it should throw <a class="el" href="class_robot_raconteur_1_1_operation_aborted_exception.html" title="Exception thrown when an operation is aborted.">RobotRaconteur::OperationAbortedException</a>. Abort should be used in situations where any modifications the generator may have made should not be commited. It can also be used if the generator represents a physical motion, like executing a robot trajectory, that requires the motion to be rapidly aborted.</p>
<h2><a class="anchor" id="cpp_service_event"></a>
Event Members</h2>
<p>Events are used by the service to notify all connected clients an event has occurred. Events may have zero or more value type parameters. Events are sent to all connected clients. In C++, events are implemented using <code>boost::signals2::signal</code>. See the documentation for <code>boost::signals2::signal</code> for more information on using Boost.Signals2. An example event definition: </p><pre class="fragment">event somethingHappened(string what, double when)
</pre><p>The abstract interface generates an accessor for a <code>boost::signals2::signal</code> reference to be returned by the service. The service needs to create an instance of the signal as a field in the class, and return a reference to that instance in the accessor function. The <code>_default_impl</code> class does this automatically, creating a field <code>rrvar_</code> followed by the event member name.</p>
<p>The following example shows the event being fired from a class extending <code>_default_impl</code>. </p><pre class="fragment">// In the same C++ class as the event, extending from the "_default_impl" class

void fire_event(const std::string&amp; what, double when)
{
    boost::mutex::scoped_lock lock(this_lock);
    rrvar_somethingHappened(what, when);
}
</pre><p>The <code>fire_event()</code> function will trigger the signal. The service listens to this signal, and will forward the event to all connected clients.</p>
<h2><a class="anchor" id="cpp_service_objref"></a>
ObjRef Members</h2>
<p>ObjRef members are used to access other objects within a service. See <a class="el" href="nodes_and_communication.html#service_paths">Service Paths</a> for more information on objrefs and service paths. An example objref definition:</p>
<p>objref MyOtherObject other_object</p>
<p>This objref definition results in an accessor function in the abstract interface that needs to be implemented: </p><pre class="fragment">class MyOtherObjectImpl : public virtual MyOtherObject
{
    // TODO: Implement the other object 
};

// In the object owning the other_object member:

virtual MyOtherObjectPtr get_other_object()
{
    // Return a new object, or a pointer to an existing object
    return boost::make_shared&lt;MyOtherObject&gt;();
};
</pre><p>ObjRefs may also be indexed with an <code>int32_t</code> or <code>string</code>. See <a class="el" href="cpp_client.html#cpp_client_objref">ObjRef Members</a> for a discussion of the different forms of the accessor function. The index is passed to the service as a parameter to the accessor function. It is up to the service to decide what object to return based on the index. If the index is invalid, <a class="el" href="class_robot_raconteur_1_1_invalid_argument_exception.html" title="Exception thrown for an invalid argument.">RobotRaconteur::InvalidArgumentException</a> should be thrown.</p>
<p>ObjRefs also use the <code>async_</code> asynchronous abstract interface if the service object extends it. The asynchronous accessor function is prefixed with <code>async_get_</code>.</p>
<h2><a class="anchor" id="cpp_service_pipe"></a>
Pipe Members</h2>
<p>Pipe members provide reliable (or optionally unreliable) data streams between clients and service, in either direction. See <a class="el" href="class_robot_raconteur_1_1_pipe.html">RobotRaconteur::Pipe</a> for a discussion of pipes.</p>
<p>An example pipe definition: </p><pre class="fragment">pipe double[] sensordata
</pre><p>Results in the following pure virtual functions being generated in the abstract interface that need to be implemented by the service object: </p><pre class="fragment">virtual PipePtr&lt;RRArrayPtr&lt;double&gt;&gt; get_sensordata();
virtual void set_sensordata(PipePtr&lt;RRArrayPtr&lt;double&gt;&gt; pipe);
</pre><p>Pipes are initialized by the service when the root service object is registered, or after service objects are returned from objref members. The service will call the <code>set_</code> accessor function with a pipe server for use by the service. The service object is expected to store a reference to this pipe server, and accept incoming connection requests from clients. The service uses RobotRaconteur::Pipe::SetConnectCallback() to specify a callback function to invoke when clients request pipe connections. Each time a client connects a pipe, the callback is invoked with a RobotRaconteur::PipeEndpointPtr that the service can use to send and/or receive packets with the client. If the service needs to reject the incoming pipe connection, the callback can throw an exception. This exception will abort the connection, and pass the exception back to the client. The service is responsible for maintaining a reference to the RobotRaconteur::PipeEndpointPtr, but the reference is still owned by the pipe. It is recommended that <code>boost::weak_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html" title="Pipe endpoint used to transmit reliable or unreliable data streams.">RobotRaconteur::PipeEndpoint</a>&lt;T&gt;&gt;</code> be used to store the endpoint pointer to avoid memory leaks.</p>
<p>Pipes declared <code>readonly</code> may only send packets on the service side. Pipes declared <code>writeonly</code> may only receive packets on the service side.</p>
<p>There is a helper class <a class="el" href="class_robot_raconteur_1_1_pipe_broadcaster.html" title="Broadcaster to send packets to all connected clients.">RobotRaconteur::PipeBroadcaster</a> that can be used when the service needs to send the same packets to every connected client. It should only be used with pipes declared <code>readonly</code>. The pipe broadcaster has optional flow control, that tracks how many packets are "in flight", and compares it to the "maximum backlog". If the number of packets in flight exceeds the maximum backlog, sending packets is paused. (This flow control method only works with reliable pipes.)</p>
<p>The <code>_default_impl</code> will automatically create a <a class="el" href="class_robot_raconteur_1_1_pipe_broadcaster.html" title="Broadcaster to send packets to all connected clients.">RobotRaconteur::PipeBroadcaster</a> for <code>readonly</code> pipes. The pipe broadcaster is stored in a field <code>rrvar_</code> followed by the name of the pipe member.</p>
<p>An example, assuming that the <code>sensordata</code> pipe is in <code>MyObject</code>, and using <code>IRRServiceObject</code> to set the maximum backlog: </p><pre class="fragment">class MyObjectImpl : public virtual MyObject_default_impl, public virtual IRRServiceObject
{
public:

    virtual void RRServiceObjectInit(boost::weak_ptr&lt;ServerContext&gt; ctx, const std::string&amp; service_path)
    {
        // Set the maximum backlog to prevent overloading the transport
        rrvar_sensordata-&gt;SetMaxBacklog(3);
    }

protected:

    void SendData(RRArrayPtr&lt;double&gt; data)
    {
        boost::mutex::scoped_lock lock(this_lock);

        // Test to make sure that rrvar_sensordata has been initialized            
        if (rrvar_sensordata)
        {
            // Send the packet, don't wait for send completion
            rrvar_sensordata-&gt;AsyncSendPacket(data,[]());
        }
    }
};
</pre><p><code>AsyncSendPacket()</code> is used to prevent the <code>SendData()</code> function from blocking the thread.</p>
<p>If the pipe member is not marked <code>readonly</code>, the <code>_default_impl</code> will store RobotRaconteur::PipePtr in <code>rrvar_</code>. Use RobotRaconteur::Pipe::SetConnectCallback() in <code>RRServiceObjectInit</code> to set the connect callback function.</p>
<h2><a class="anchor" id="cpp_service_callback"></a>
Callback Members</h2>
<p>Callbacks allow the service to invoke a function on a specific client. The definition is nearly identical to a <code>function</code> member, except the keyword is <code>callback</code> and generators are not supported. An example callback definition: </p><pre class="fragment">callback double addTwoNumbersOnClient(int32 a, double b)
</pre><p>The callback is managed by an instance of <a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">RobotRaconteur::Callback</a>. The example results pure virtual functions being generated in the abstract interface that need to be implemented by the service object: </p><pre class="fragment">virtual CallbackPtr&lt;boost::function&lt;double (int32_t, double)&gt; &gt; get_addTwoNumbersOnClient();
virtual void set_addTwoNumbersOnClient(CallbackPtr&lt;boost::function&lt;double (int32_t, double)&gt; &gt; callback);
</pre><p>The service object needs to store the RobotRaconteur::CallbackPtr in a field so it can retrieve proxies to client callbacks. The <code>_default_impl</code> automatically handles this, and stores the RobotRaconteru::CallbackPtr in a field <code>rrvar_</code> followed by the member name.</p>
<p>Service objects retrieve proxies to the client callbacks using <a class="el" href="class_robot_raconteur_1_1_callback.html#a084ba6c950b75801137272b9096d11b5" title="Get the proxy function to call the callback for the specified client on the service side.">RobotRaconteur::Callback::GetClientFunction()</a>. This function takes a <code>uint32_t</code> client endpoint ID to select which client to call. This client endpoint ID can be determined using <a class="el" href="class_robot_raconteur_1_1_server_endpoint.html#a357c10bed763628d1a9862c02d8018cf" title="Returns the current server endpoint.">RobotRaconteur::ServerEndpoint::GetCurrentEndpoint()</a>-&gt;GetLocalEndpoint() called during a function member or property member request.</p>
<p>An example service definition demonstrating using a callback: </p><pre class="fragment">service experimental.service_example3

object MyObject
    function void other_function()
    callback double addTwoNumbersOnClient(int32 a, double b)
end
</pre><p>An implementation of <code>addTwoNumbersOnClient()</code> that will call the last client to invoke <code>other_function()</code>: </p><pre class="fragment">using namespace ::experimental::service_example3;

class MyObjectImpl : public virtual MyObject_default_impl
{
    uint32_t client_id = 0;

public:
    virtual void other_function()
    {
        // Store the endpoint ID
        boost::mutex::scoped_lock lock(this_lock);
        client_id = ServerEndpoint::GetCurrentEndpoint()-&gt;GetLocalEndpoint();
    }

protected:
    double invoke_add(int32_t a, double b)
    {
        boost::function&lt;double(int32_t,double)&gt; cb;
        {
            boost::mutex::scoped_lock lock(this_lock);
            try
            {
                // Get a proxy to the client callback
                cb = rrvar_addTwoNumbersOnClient-&gt;GetClientFunction(client_id);
            }
            catch (std::exception&amp;)
            {
                // If getting the callback failed, set client_id to zero, or invalid
                client_id = 0;
                throw InvalidOperationException("Client ID is not valid");
            }
        }
        return cb(a,b);
    }        
};
</pre><p>The above example will invoke the callback on the last function to call <code>other_function()</code>. The choice of client which client to use depends completely on the purpose of the callback. The callback can be invoked on any connected client. If the client has not specified a callback for use, a <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">RobotRaconteur::InvalidOperationException</a> is thrown.</p>
<h2><a class="anchor" id="cpp_service_wire"></a>
Wire Members</h2>
<p>Wire members provide a "most recent" values. They are typically used to communicate a real-time signal, such as a robot joint angle. See <a class="el" href="class_robot_raconteur_1_1_wire.html" title="wire member type interface">RobotRaconteur::Wire</a> for a discussion of wires.</p>
<p>An example wire definition: </p><pre class="fragment">wire double[2] currentposition
</pre><p>Results in the following functions pure virtual being generated in the abstract interface: </p><pre class="fragment">virtual WirePtr&lt;RRArrayPtr&lt;double&gt;&gt; get_currentposition();
virtual void set_currentposition(WirePtr&lt;RRArrayPtr&lt;double&gt;&gt; wire);
</pre><p>These functions must be implemented by the service object.</p>
<p>Implementing wires can be somewhat complicated. The use of the helper classes <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">RobotRaconteur::WireBroadcaster</a> and <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">RobotRaconteur::WireUnicastReceiver</a> are recommended. Using these two helper classes will be discussed first, followed by a discussion of using the wire without helper classes.</p>
<p>Wires can be marked as <code>readonly</code> or <code>writeonly</code>. If neither is specified, the wire can send values in both directions. Wire memers are usually set to <code>readonly</code> or <code>writeonly</code> for most service designs. While using a full-duplex wire is possible, the need for full-duplex wires is not typical. <code>readonly</code> wires can only send values from service to client. <code>writeonly</code> wires can only send values from client to service.</p>
<p>For <code>readonly</code> wires, the service can use the <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">RobotRaconteur::WireBroadcaster</a> to send the same values to all connected wires. The <code>OutValue</code> is set on the wire broadcaster, and this value is sent to all connected wires. For <code>writeonly</code> wires, the service can use the <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">RobotRaconteur::WireUnicastReceiver</a>. The unicast receiver is desigen to provide the <code>InValue</code> of the most recent wire connection to connect. This <code>InValue</code> is set by the client, providing values from the client to the service. If a client wire connection is already established, it is closed in favor of the more recent connection. Clients locking should be used to prevent other clients from connecting. See <a class="el" href="cpp_client.html#cpp_client_object_locking">Object Locking</a>. The <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">RobotRaconteur::WireBroadcaster</a> and <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">RobotRaconteur::WireUnicastReceiver</a> automate most of the functionality of the wire. In most cases the user simply needs to set the <code>OutValue</code> of the broadcaster and query the <code>InValue</code> of the receiver.</p>
<p>The generated <code>_default_impl</code> class implements the accessor functions for the wires, and stores the wire in class fields named <code>rrvar_</code> appended with the name of the member. The <code>_default_impl</code> has special behavior for <code>readonly</code> and <code>writeonly</code> members. For <code>readonly</code> wire members, the <code>rrvar_</code> field will automatically be initialized with a <a class="el" href="class_robot_raconteur_1_1_wire_broadcaster.html" title="Broadcaster to send values to all connected clients.">RobotRaconteur::WireBroadcaster</a>. For <code>writeonly</code> wire members, the <code>rrvar_</code> field will automatically be initialized with a <a class="el" href="class_robot_raconteur_1_1_wire_unicast_receiver.html" title="Receive the InValue from the most recent connection.">RobotRaconteur::WireUnicastReceiver</a>. (The service can override the <code>get_</code> and <code>set_</code> accessor functions to override this behavior.)</p>
<p>Wires are typically used with a (soft) real-time control loop, such as a robot feedback loop. The following is a simple example of a first-order discrete-time system y[n] = -a*y[n-1] + b*u[n] loop implemented using wires for input and output.</p>
<p>Discrete time loop service definition: </p><pre class="fragment">service experimental.service_example4

object MyObject
    wire double y [readonly]
    wire double u [writeonly]
end
</pre><p>The service object implementation of the discrete time system: </p><pre class="fragment">class MyObjectImpl : public virtual MyObject_default_impl, public virtual IRRServiceObject
{
    double y_n1 = 0;
    double a = 0.1;
    double b = 0.1;
public:

    virtual void RRServiceObjectInit(boost::weak_ptr&lt;ServerContext&gt; ctx, const std::string&amp; service_path)
    {
        rrvar_u-&gt;SetInValueLifespan(250);
    }

    // Run one step of the discrete time system
    void Step()
    {
        boost::mutex::scoped_lock lock(this_lock);

        // If either wire has not been initialized, return
        if (!rrvar_y || !rrvar_u)
        {
            return;
        }

        // Get "u", if not available, use zero
        double u = 0;
        TimeSpec ts;
        uint32_t ep;

        // rrvar_u is initialized to WireUnicastReceiver&lt;double&gt; by MyObject_default_impl
        if (!rrvar_u-&gt;TryGetInValue(u,ts,ep))
        {
            // Set u to zero if no input available
            u = 0;
        }

        double y = - a * y_n1 + b * u;

        // rrvar_y is initialized to WireBroadcaster&lt;double&gt; by MyObject_default_impl

        // Set the out value wire
        rrvar_y-&gt;SetOutValue(y);

        // Save y for next iteration
        y_n1 = y;
    }
};
</pre><p>The RobotRaconteur::WireUnicastReceiver::SetInValueLifespan() is used to give the received input value a finite lifespan. If the client disconnects or stops sending data, the in value will expire, preventing stale data from being received. The <code>Step()</code> function must be called periodically by the program. This is typically done in a loop in <code>main()</code> or from a thread.</p>
<p>For a device like a robot or a senser, the wires would be used to send feedback and receive commands instead of being used with a software discrete time system.</p>
<p>The discussion and examples so far have used the helper classes <code>WireBroadcaster</code> and <code>WireUnicastReceiver</code>. These classes automatically manage the incoming wire connections, peek requests, and poke requests. If the service does not want to use a helper class, it must implement the <code>get_</code> and <code>set_</code> accessors in the object, and it must set callbacks for incoming wire connections, peek in value requests, peek out value requests, and poke out value requests. The relevant functions to set the callbacks are <a class="el" href="class_robot_raconteur_1_1_wire.html#a89d58b49df1160676ebe362b47d4ff8d" title="Set wire connected callback function.">RobotRaconteur::Wire::SetWireConnectCallback()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#a40cf20b646bcebbdc28a5738b72f95dc" title="Set the PeekInValue callback function.">RobotRaconteur::Wire::SetPeekInValueCallback()</a>, <a class="el" href="class_robot_raconteur_1_1_wire.html#ab150ead6b19f631801564c3c854ff335" title="Set the PeekOutValue callback function.">RobotRaconteur::Wire::SetPeekOutValueCallback()</a>, and <a class="el" href="class_robot_raconteur_1_1_wire.html#a91ddf6dc449ab7ef31ce0e178dd9c3c9" title="Set the PokeOutValue callback function.">RobotRaconteur::Wire::SetPokeOutValueCallback()</a>. These callbacks are usually configured in the <code>set_</code> accessor. The <code>set_</code> accessor will only be called once by the service. Manually managing wire connections and peek/poke callbacks is not normally necessary, since the helper classes can be used directly or subclassed to implement wire functionality.</p>
<h2><a class="anchor" id="cpp_service_memory"></a>
Memory Members</h2>
<p>Memories are used to read and write a memory segment on the service. Memories may be numeric arrays, numeric multidimarrays, pod arrays, pod multidimarrays, namedarray arrays, or namedarray multidimarrays. The different types of memories and their corresponding C++ classes are discussed here: <a class="el" href="cpp_client.html#cpp_client_memory">Memory Members</a>.</p>
<p>A numeric array memory client and a numeric multidimarray memory client will be used as examples. Pod and namedarray memories are identical, except for the memory class and the value types being utilized.</p>
<p>Example array memory definition: </p><pre class="fragment">memory double[] datahistory
</pre><p>Results in a single pure virtual accessor function being generated in the abstract interface that must be implemented: </p><pre class="fragment">virtual ArrayMemoryPtr&lt;double&gt; get_datahistory()
{
    // Assume that there is a field storing the data
    RRArrayPtr&lt;double&gt; my_data = self-&gt;my_data_;

    // Return an array memory
    return boost::make_shared&lt;ArrayMemory&gt;(my_data);
}
</pre><p>The service will proxy the read and write requests to the returned memory. The service can return the existing memory C++ classes, however these do not provide any locking or data protection. Is is recommended that the provided C++ classes be extended for the specific needs of the application.</p>
<p>Memory members are a seldomnly used feature. They should only be used when a device provides a true shared memory region, such as a ring buffer or a set of registers that must be exposed, or when there is a very large data set that is randomnly accessed by clients.</p>
<h1><a class="anchor" id="cpp_service_security"></a>
Service Security</h1>
<p>Services can be secured using a <a class="el" href="class_robot_raconteur_1_1_service_security_policy.html" title="Security policy for Robot Raconteur service.">RobotRaconteur::ServiceSecurityPolicy</a> instance. The security policy is passed to <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a074209e23f46fbdd14dd43aa7773caf7" title="Registers a service for clients to connect.">RobotRaconteur::RobotRaconteurNode::RegisterService()</a> function when the service is registered. The constructor takes a map of policies, and a pointer to a user authenticator. Currently, the only authenticator available is <a class="el" href="class_robot_raconteur_1_1_password_file_user_authenticator.html" title="Simple authenticator using a list of username, password hash, and privileges stored in a file or stri...">RobotRaconteur::PasswordFileUserAuthenticator</a>. This authenticator takes a file or string of usernames, passwords, and privileges to authenticate against. See RobotRaconteur::PaswordFileUserAuthenticator for information on the file format. See <a class="el" href="security.html">Security</a> for a discussion of Robot Raconteur security.</p>
<p>The following is a typical example of a secured service being initialized: </p><pre class="fragment">// Username, password, and privileges data, one user per line. Passwords md5 hashed
std::string password_auth_data =
    "user1 79e262a81dd19d40ae008f74eb59edce objectlock" "\n"
    "user2 309825a0951b3cf1f25e27b61cee8243 objectlock" "\n"
    "superuser1 11e5dfc68422e697563a4253ba360615 objectlock,objectlockoverride" "\n";

// Create the service object
MyObjectPtr obj = boost::make_shared&lt;MyObjectImpl&gt;();

std::map&lt;std::string,std::string&gt; policies = {
    {"requirevaliduser", "true"},
    {"allowobjectlock", "true"}
};

// Create the password authenticator
PasswordFileUserAuthenticatorPtr auth = boost::make_shared&lt;PasswordFileUserAuthenticator&gt;(password_auth_data);

// Create the security policy
ServiceSecurityPolicyPtr s = boost::make_shared&lt;ServiceSecurityPolicy&gt;(auth,policies);

// Register the service
RobotRaconteurNode::s()-&gt;RegisterService("my_service", "experimental.service_example5", obj);
</pre><p>The above example has two normal users, "user1" and "user2", and one superuser, "superuser1". The superuser has the "objectlockoverride" privilege, allowing the superuser to unlock any object regardless of which user created the lock. The passwords are stored as md5 hashes. These md5 hashes can be generated using <code>RobotRaconteurGen</code>. See <a class="el" href="robotraconteurgen.html"><code>RobotRaconteurGen</code> Utility</a>. The password data should be stored in a file so it can be modified as users are added and removed.</p>
<h1><a class="anchor" id="cpp_service_locking"></a>
Object Locking</h1>
<p>Clients can request object locks to gain exclusive access. There are three types of object locking: user locks, client locks, and monitor locks. See object_locking and <a class="el" href="cpp_client.html#cpp_client_object_locking">Object Locking</a> for more information on object lock types.</p>
<h2><a class="anchor" id="cpp_service_locking_user_client"></a>
User Locks and Client Locks</h2>
<p>User locks and client locks only require that the "allowobjectlock" policy is set, that the current client is authenticated, and the authenticated client has the "objectlocking" privilege. Object locking at this point is handled automatically by the service. The service can create and release locks on behalf of clients using <a class="el" href="class_robot_raconteur_1_1_server_context.html#a5b85f82525f83ddf8438730836f25b9f" title="Request an object lock on servicepath for user username.">RobotRaconteur::ServerContext::RequestObjectLock()</a>, <a class="el" href="class_robot_raconteur_1_1_server_context.html#a2012163eb7fce64f78778a35c6ab4ba5" title="Request a client lock on servicepath for a specific client connection.">RobotRaconteur::ServerContext::RequestClientObjectLock()</a>, and <a class="el" href="class_robot_raconteur_1_1_server_context.html#a35b7d99e9e720af86e4c3ad54ebe35fd" title="Release a client lock on servicepath.">RobotRaconteur::ServerContext::ReleaseObjectLock()</a>. See each function for more information.</p>
<h2><a class="anchor" id="cpp_service_locking_monitor"></a>
Monitor Locks</h2>
<p>Monitor locks are used to request a thread-exclusive lock. Service objects that wish to be monitor-lockable must extend and implement <a class="el" href="class_robot_raconteur_1_1_i_robot_raconteur_monitor_object.html" title="Service object monitor lock notification.">RobotRaconteur::IRobotRaconteurMonitorObject</a>. This interface contains function to enter the lock, and exit the lock. The simplest implementation will use a <code>boost::mutex</code> to implement the lock. The following example uses this method: </p><pre class="fragment">using namespace RobotRaconteur;

class MyObjectImpl : public virtual MyObjectDefaultImpl, 
    public virtual IRobotRaconteurMonitorObject
{
public:
    virtual void RobotRaconteurMonitorEnter()
    {
        monitor_lock.lock();
    }

    virtual void RobotRaconteurMonitorEnter(int32_t timeout)
    {
        if (timeout==-1)
        {
            RobotRaconteurMonitorEnter();
        }
        else
        {
            monitor_lock.timed_lock(boost::posix_time::milliseconds(timeout));
        }
    }

    virtual void RobotRaconteurMonitorExit()
    {
        monitor_lock.unlock();
    }

protected:
    boost::mutex monitor_lock;
};
</pre><p>The service can also use <code>monitor_lock</code> directly, when it needs to prevent clients from accessing a memory region.</p>
<p><b>Not that unlike client and user locks, monitor locks are not enforced. The client must voluntarily request monitor locks.</b></p>
<h1><a class="anchor" id="cpp_service_attributes"></a>
Service Attributes</h1>
<p>Service attributes are provided by services to help with discovery. The attributes are made available to clients during the discovery process. In C++, the attributes have the type <code>std::map&lt;std::string,RRValuePtr&gt;</code>. The attributes follow the same type rules as <code>varvalue{string}</code>. The attributes map must not contain any types defined in service definitions, since the client won't be able to unpack these types.</p>
<p>An example of using attributes for a service with root object type <code>MyRobot</code>: </p><pre class="fragment">MyRobotPtr robot = boost::make_shared&lt;MyRobot&gt;();
std::map&lt;std::string,RRValuePtr&gt; attributes = 
{
    { "description", stringToRRArray("My awesome robot!") },
    { "location", stringToRRArray("Robotics lab") }
};

ServerContextPtr ctx = RobotRaconteurNode::s()-&gt;RegisterService("my_robot", "experimental.my_robot", robot);
ctx-&gt;SetAttributes(attributes);
</pre><h1><a class="anchor" id="cpp_service_release_path"></a>
Releasing Objects</h1>
<p>When service objects are returned from objref members, the service takes ownership of the object. If the service needs to release the object, it must be done explicitly using the RobotRaconteur::RobotRaconteurNode::ReleaseServicePath() function. This function takes the "service path" of the object to be released. See <a class="el" href="nodes_and_communication.html#service_paths">Service Paths</a> for more information on service paths. The service path of an object can be determined using <a class="el" href="class_robot_raconteur_1_1_i_r_r_service_object.html" title="Interface for service objects to receive service notifications.">RobotRaconteur::IRRServiceObject</a>, or using the function <a class="el" href="class_robot_raconteur_1_1_server_context.html#ae5abe33bf916106fca836bf4903d0507" title="Get the current object service path.">RobotRaconteur::ServerContext::GetCurrentServicePath()</a>. When the service path is released, all connected clients are notified using an event. If the service path contains sensitive data such as a session token, the <a class="el" href="class_robot_raconteur_1_1_server_context.html#aad93dcbc1ccb31780a9b452c5f3a1ea5" title="Release the specified service path and all sub objects.">RobotRaconteur::ServerContext::ReleaseServicePath(boost::string_ref path, const std::vector&lt;uint32_t&gt;&amp; endpoints)</a> overload should be used. This version will only notify the clients specified in the <code>endpoints</code> parameter. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
