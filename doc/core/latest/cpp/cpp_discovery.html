<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: C++ Discovery</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Discovery </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Discovery is used by clients to find available services on the local machine or local network. See discovery for an introduction to discovery.</p>
<p>Nodes and transports must be configured to enable discovery. The <a class="el" href="class_robot_raconteur_1_1_client_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a client only node.">RobotRaconteur::ClientNodeSetup</a>, <a class="el" href="class_robot_raconteur_1_1_server_node_setup.html" title="Initializes a RobotRaconteurNode instance to default configuration for a server and client node.">RobotRaconteur::ServerNodeSetup</a>, and RobotRaconteur::SecureNodeSetup enable node discovery be default. See <a class="el" href="cpp_node_setup.html">C++ Node Setup</a> for more information.</p>
<p>Subscriptions are often a better option than the basic discovery functions since the track services and automatically create connections. See <a class="el" href="cpp_subscriptions.html">C++ Subscriptions</a>.</p>
<p>The C++ library provides "service discovery" and "node discovery".</p>
<h1><a class="anchor" id="cpp_service_discovery"></a>
Service Discovery</h1>
<p>Service discovery is used to find available services on the network. The function <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a5e6a843097e6f17aee2b8660e58a3f48" title="Use discovery to find available services by service type.">RobotRaconteur::RobotRaconteurNode::FindServiceByType()</a> and its asynchronous version <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#ae9adc2c77f3fcb7df3de563cb33a8d36" title="Asynchronously use discovery to find availabe services by service type.">RobotRaconteur::RobotRaconteurNode::AsyncFindServiceByType()</a> are provided by the C++ library for service discovery. They take the fully qualified type of the service type to search for, and the schemes of the transports to search. The functions return a vector of <a class="el" href="class_robot_raconteur_1_1_service_info2.html" title="Contains information about a service found using discovery.">RobotRaconteur::ServiceInfo2</a>. The information in <code><a class="el" href="class_robot_raconteur_1_1_service_info2.html" title="Contains information about a service found using discovery.">RobotRaconteur::ServiceInfo2</a></code> can be used to create connections to the service.</p>
<p>An example using <code>FindServiceByType()</code>: </p><pre class="fragment">using namespace RobotRaconteur;
void main(int argc, char* argv[])
{
    ClientNodeSetup node_setup(ROBOTRACONTEUR_SERVICE_TYPES, argc, argv);

    // Give the node a few seconds to warm up before searching
    boost::this_thread::sleep(boost::posix_time::milliseconds(5000));

    // Parameters for FindServiceByType
    std::string obj_type = "experimental.example_service1.MyObject";
    std::vector&lt;std::string&gt; schemes = {"rr+tcp", "rr+local"};

    std::vector&lt;ServiceInfo2&gt; detected_services = RobotRaconteurNode::s()-&gt;FindServiceByType(obj_type, schemes);

    if (detected_services.empty())
    {
        std::cerr &lt;&lt; "Did not detect any services!" &lt;&lt; std::endl;
        return 1;
    }

    // Print out the discovered services
    for(auto e : detected_services)
    {
        std::cout &lt;&lt; "Name: " &lt;&lt; e.Name &lt;&lt; std::endl;
        std::cout &lt;&lt; "RootObjectType: " &lt;&lt; e.RootObjectType &lt;&lt; std::endl;
        std::cout &lt;&lt; "RootObjectImplements: " &lt;&lt; boost::join(e.RootObjectImplements, ", ") &lt;&lt; std::endl;
        std::cout &lt;&lt; "ConnectionURL: " &lt;&lt; boost::join(e.ConnectionURL,", ") &lt;&lt; std::endl &lt;&lt; std::endl;
    }

    // Connect to the first detected service
    MyObjectPtr c = rr_cast&lt;MyObject&gt;(
        RobotRaconteurNode::s()-&gt;ConnectService(detected_services.front().ConnectionURL);
    );

    // Client c is now connected

    return 0;

}
</pre><h1><a class="anchor" id="cpp_node_discovery"></a>
Node Discovery</h1>
<p>Nodes can be discovered directly, without considering which services are available on the nodes. The functions <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a6f71bf3c96ed4e9a3cd4f953190ef9be" title="Finds nodes on the network with a specified NodeID.">RobotRaconteur::RobotRaconteurNode::FindNodeByID()</a> and <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a683a1c228cbfb70bcc08430f49e52a5a" title="Finds nodes on the network with a specified NodeName.">RobotRaconteur::RobotRaconteurNode::FindNodeByName()</a> are provided by the C++ library for detecting nodes by NodeID and NodeName, respectively. See <a class="el" href="nodes_and_communication.html#nodeid">NodeID and NodeName</a> for more information on NodeID and NodeName. The asynchronous versions <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a63105e3219469c78aad8569a65b5629e" title="Asynchronously finds nodes on the network with the specified NodeID.">RobotRaconteur::RobotRaconteurNode::AsyncFindNodeByID()</a> and <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_node.html#a9bfec4072b487cde383788633d47ac8b" title="Asynchronously finds nodes on the network with the specified NodeName.">RobotRaconteur::RobotRaconteurNode::AsyncFindNodeByName()</a> are also provided.</p>
<p>The node discovery functions return a vector of <a class="el" href="class_robot_raconteur_1_1_node_info2.html" title="Contains information about a node detected using discovery.">RobotRaconteur::NodeInfo2</a>.</p>
<p><b>The results of node discovery are not verified, and are raw discovery information received on the network.</b></p>
<p>An example using discovery by NodeName: </p><pre class="fragment">using namespace RobotRaconteur;
void main(int argc, char* argv[])
{
    ClientNodeSetup node_setup(ROBOTRACONTEUR_SERVICE_TYPES, argc, argv);

    // Give the node a few seconds to warm up before searching
    boost::this_thread::sleep(boost::posix_time::milliseconds(5000));

    // Parameters for FindNodeByName
    std::string node_name = "my_node_name";
    std::vector&lt;std::string&gt; schemes = {"rr+tcp", "rr+local"};

    std::vector&lt;NodeInfo2&gt; detected_nodes = RobotRaconteurNode::s()-&gt;FindNodeByName(node_name, schemes);

    if (detected_nodes.empty())
    {
        std::cerr &lt;&lt; "Did not detect any services!" &lt;&lt; std::endl;
        return 1;
    }

    // Print out the discovered nodes
    for(auto e : detected_nodes)
    {
        std::cout &lt;&lt; "NodeID: " &lt;&lt; e.NodeID.ToString() &lt;&lt; std::endl;
        std::cout &lt;&lt; "NodeName: " &lt;&lt; e.NodeName &lt;&lt; std::endl;
        std::cout &lt;&lt; "ConnectionURL: " &lt;&lt; boost::join(e.ConnectionURL,", ") &lt;&lt; std::endl &lt;&lt; std::endl;
    }

    return 0;

}
</pre><p>The results of node discovery cannot be used directly for connecting to services, since the resulting URLs do not contain the service information. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
