<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Raconteur Core C++ Library: RobotRaconteur::PipeEndpoint&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Raconteur Core C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>RobotRaconteur</b></li><li class="navelem"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_robot_raconteur_1_1_pipe_endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RobotRaconteur::PipeEndpoint&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoint used to transmit reliable or unreliable data streams.  
 <a href="class_robot_raconteur_1_1_pipe_endpoint.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for RobotRaconteur::PipeEndpoint&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_robot_raconteur_1_1_pipe_endpoint.png" usemap="#RobotRaconteur::PipeEndpoint_3C_20T_20_3E_map" alt=""/>
  <map id="RobotRaconteur::PipeEndpoint_3C_20T_20_3E_map" name="RobotRaconteur::PipeEndpoint_3C_20T_20_3E_map">
<area href="class_robot_raconteur_1_1_pipe_endpoint_base.html" title="Base class for PipeEndpoint." alt="RobotRaconteur::PipeEndpointBase" shape="rect" coords="0,0,213,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a83d7f30b86250f3026a4f93647e576b7"><td class="memItemLeft" align="right" valign="top">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt; T &gt; &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a83d7f30b86250f3026a4f93647e576b7">GetPipeEndpointClosedCallback</a> ()</td></tr>
<tr class="memdesc:a83d7f30b86250f3026a4f93647e576b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently configured endpoint closed callback function.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a83d7f30b86250f3026a4f93647e576b7">More...</a><br /></td></tr>
<tr class="separator:a83d7f30b86250f3026a4f93647e576b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6982d846b8e5f92eafcd9921e0df2a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#aa6982d846b8e5f92eafcd9921e0df2a4">SetPipeEndpointClosedCallback</a> (boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt; T &gt; &gt;)&gt; callback)</td></tr>
<tr class="memdesc:aa6982d846b8e5f92eafcd9921e0df2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the endpoint closed callback function.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#aa6982d846b8e5f92eafcd9921e0df2a4">More...</a><br /></td></tr>
<tr class="separator:aa6982d846b8e5f92eafcd9921e0df2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac137dc101ad4fcc0fa3f59d2cd47380c"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#ac137dc101ad4fcc0fa3f59d2cd47380c">SendPacket</a> (typename boost::call_traits&lt; T &gt;::param_type packet)</td></tr>
<tr class="memdesc:ac137dc101ad4fcc0fa3f59d2cd47380c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet to the peer endpoint.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#ac137dc101ad4fcc0fa3f59d2cd47380c">More...</a><br /></td></tr>
<tr class="separator:ac137dc101ad4fcc0fa3f59d2cd47380c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806fea541335ecf2d2703576dccde7f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a806fea541335ecf2d2703576dccde7f7">AsyncSendPacket</a> (typename boost::call_traits&lt; T &gt;::param_type packet, boost::function&lt; void(uint32_t, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;handler)</td></tr>
<tr class="memdesc:a806fea541335ecf2d2703576dccde7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet to the peer endpoint asynchronously.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a806fea541335ecf2d2703576dccde7f7">More...</a><br /></td></tr>
<tr class="separator:a806fea541335ecf2d2703576dccde7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce6a6684ed7cb25b7a4168934eb7bf6"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a5ce6a6684ed7cb25b7a4168934eb7bf6">ReceivePacket</a> ()</td></tr>
<tr class="memdesc:a5ce6a6684ed7cb25b7a4168934eb7bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive the next packet in the receive queue.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a5ce6a6684ed7cb25b7a4168934eb7bf6">More...</a><br /></td></tr>
<tr class="separator:a5ce6a6684ed7cb25b7a4168934eb7bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae58dd88e4ff68b34676503f41e18cb"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#aeae58dd88e4ff68b34676503f41e18cb">PeekNextPacket</a> ()</td></tr>
<tr class="memdesc:aeae58dd88e4ff68b34676503f41e18cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks the next packet in the receive queue.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#aeae58dd88e4ff68b34676503f41e18cb">More...</a><br /></td></tr>
<tr class="separator:aeae58dd88e4ff68b34676503f41e18cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf7f76a9a2caea45fa973822829d352"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a9bf7f76a9a2caea45fa973822829d352">ReceivePacketWait</a> (int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a9bf7f76a9a2caea45fa973822829d352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive the next packet in the receive queue, block if queue is empty.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a9bf7f76a9a2caea45fa973822829d352">More...</a><br /></td></tr>
<tr class="separator:a9bf7f76a9a2caea45fa973822829d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aea1fa6c69ccf324afa0db06115c9c"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a18aea1fa6c69ccf324afa0db06115c9c">PeekNextPacketWait</a> (int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>)</td></tr>
<tr class="memdesc:a18aea1fa6c69ccf324afa0db06115c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the next packet in the receive queue, block if queue is empty.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a18aea1fa6c69ccf324afa0db06115c9c">More...</a><br /></td></tr>
<tr class="separator:a18aea1fa6c69ccf324afa0db06115c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a74cbfb233e32266758bcc41b4947c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a82a74cbfb233e32266758bcc41b4947c">TryReceivePacketWait</a> (T &amp;val, int32_t timeout=<a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a>, bool peek=false)</td></tr>
<tr class="memdesc:a82a74cbfb233e32266758bcc41b4947c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try receiving a packet, optionally blocking if the queue is empty.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a82a74cbfb233e32266758bcc41b4947c">More...</a><br /></td></tr>
<tr class="separator:a82a74cbfb233e32266758bcc41b4947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e4332ad9ac2454dfce3072ee530ab3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a52e4332ad9ac2454dfce3072ee530ab3">Close</a> ()</td></tr>
<tr class="memdesc:a52e4332ad9ac2454dfce3072ee530ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the pipe endpoint.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a52e4332ad9ac2454dfce3072ee530ab3">More...</a><br /></td></tr>
<tr class="separator:a52e4332ad9ac2454dfce3072ee530ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ab324ed11e759730dead10d0fbef7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#ac8ab324ed11e759730dead10d0fbef7c">AsyncClose</a> (boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;handler, int32_t timeout=2000)</td></tr>
<tr class="memdesc:ac8ab324ed11e759730dead10d0fbef7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously close the pipe endpoint.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#ac8ab324ed11e759730dead10d0fbef7c">More...</a><br /></td></tr>
<tr class="separator:ac8ab324ed11e759730dead10d0fbef7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892d86f47803bd5cb2e0acb9c2879bf2"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a892d86f47803bd5cb2e0acb9c2879bf2">GetIndex</a> ()</td></tr>
<tr class="memdesc:a892d86f47803bd5cb2e0acb9c2879bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pipe endpoint index used when endpoint connected.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a892d86f47803bd5cb2e0acb9c2879bf2">More...</a><br /></td></tr>
<tr class="separator:a892d86f47803bd5cb2e0acb9c2879bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f458610a0b0ea948701866cd2ad4d"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#adc3f458610a0b0ea948701866cd2ad4d">GetEndpoint</a> ()</td></tr>
<tr class="memdesc:adc3f458610a0b0ea948701866cd2ad4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Robot Raconteur node Endpoint ID.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#adc3f458610a0b0ea948701866cd2ad4d">More...</a><br /></td></tr>
<tr class="separator:adc3f458610a0b0ea948701866cd2ad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e7bb88e3493af85ea6bb00a8929eea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a07e7bb88e3493af85ea6bb00a8929eea">GetRequestPacketAck</a> ()</td></tr>
<tr class="memdesc:a07e7bb88e3493af85ea6bb00a8929eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if pipe endpoint is requesting acks.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a07e7bb88e3493af85ea6bb00a8929eea">More...</a><br /></td></tr>
<tr class="separator:a07e7bb88e3493af85ea6bb00a8929eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35667c47a40a1a72636124c8e6e89cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a35667c47a40a1a72636124c8e6e89cd7">SetRequestPacketAck</a> (bool ack)</td></tr>
<tr class="memdesc:a35667c47a40a1a72636124c8e6e89cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if pipe endpoint should request packet acks.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a35667c47a40a1a72636124c8e6e89cd7">More...</a><br /></td></tr>
<tr class="separator:a35667c47a40a1a72636124c8e6e89cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b02417f9fc6048aa886f30bcfa507a"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#ae8b02417f9fc6048aa886f30bcfa507a">Available</a> ()</td></tr>
<tr class="memdesc:ae8b02417f9fc6048aa886f30bcfa507a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of packets in the receive queue.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#ae8b02417f9fc6048aa886f30bcfa507a">More...</a><br /></td></tr>
<tr class="separator:ae8b02417f9fc6048aa886f30bcfa507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2313d0ca8f4a4b02ad3c71b871452076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a2313d0ca8f4a4b02ad3c71b871452076">IsUnreliable</a> ()</td></tr>
<tr class="memdesc:a2313d0ca8f4a4b02ad3c71b871452076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if pipe endpoint is unreliable.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a2313d0ca8f4a4b02ad3c71b871452076">More...</a><br /></td></tr>
<tr class="separator:a2313d0ca8f4a4b02ad3c71b871452076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30540f8217352d27009d64b854658864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_robot_raconteur_constants_8h.html#a7420bbe1689d74c66948017ba2d27373">MemberDefinition_Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a30540f8217352d27009d64b854658864">Direction</a> ()</td></tr>
<tr class="memdesc:a30540f8217352d27009d64b854658864"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of the pipe.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a30540f8217352d27009d64b854658864">More...</a><br /></td></tr>
<tr class="separator:a30540f8217352d27009d64b854658864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40239248b4a9aa28a83a8098aa23ed6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#ab40239248b4a9aa28a83a8098aa23ed6">GetIgnoreReceived</a> ()</td></tr>
<tr class="memdesc:ab40239248b4a9aa28a83a8098aa23ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if pipe endpoint is ignoring incoming packets.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#ab40239248b4a9aa28a83a8098aa23ed6">More...</a><br /></td></tr>
<tr class="separator:ab40239248b4a9aa28a83a8098aa23ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d128a167f065a7a474cf550bd2a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a8c3d128a167f065a7a474cf550bd2a6e">SetIgnoreReceived</a> (bool ignore)</td></tr>
<tr class="memdesc:a8c3d128a167f065a7a474cf550bd2a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether pipe endpoint should ignore incoming packets.  <a href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a8c3d128a167f065a7a474cf550bd2a6e">More...</a><br /></td></tr>
<tr class="separator:a8c3d128a167f065a7a474cf550bd2a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0351bd55241ef48d25636e03f17ee8ba"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt; T &gt; &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a0351bd55241ef48d25636e03f17ee8ba">PacketReceivedEvent</a></td></tr>
<tr class="memdesc:a0351bd55241ef48d25636e03f17ee8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal called when a packet has been received.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a0351bd55241ef48d25636e03f17ee8ba">More...</a><br /></td></tr>
<tr class="separator:a0351bd55241ef48d25636e03f17ee8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e50ec80ca478737937fbc73f3bdab84"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt; T &gt; &gt;, uint32_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a6e50ec80ca478737937fbc73f3bdab84">PacketAckReceivedEvent</a></td></tr>
<tr class="memdesc:a6e50ec80ca478737937fbc73f3bdab84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal called when a packet ack has been received.  <a href="class_robot_raconteur_1_1_pipe_endpoint.html#a6e50ec80ca478737937fbc73f3bdab84">More...</a><br /></td></tr>
<tr class="separator:a6e50ec80ca478737937fbc73f3bdab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class RobotRaconteur::PipeEndpoint&lt; T &gt;</h3>

<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoint used to transmit reliable or unreliable data streams. </p>
<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoints are used to communicate data between connected pipe members. See <a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> for more information on pipe members.</p>
<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoints are created by clients using the <a class="el" href="class_robot_raconteur_1_1_pipe.html#aa5e29da44d2aa898ad525a080eec6c31" title="Connect a pipe endpoint.">Pipe::Connect()</a> or <a class="el" href="class_robot_raconteur_1_1_pipe.html#a751b5e1b99863cd5984fd6a1d02765dd" title="Asynchronously connect a pipe endpoint.">Pipe::AsyncConnect()</a> functions. Services receive incoming pipe endpoint connection requests through a callback function specified using the <a class="el" href="class_robot_raconteur_1_1_pipe.html#a80be0c43f5c9727f75fd21239dca3649" title="Set the pipe endpoint connected callback function.">Pipe::SetPipeConnectCallback()</a> function. Services may also use the <a class="el" href="class_robot_raconteur_1_1_pipe_broadcaster.html" title="Broadcaster to send packets to all connected clients.">PipeBroadcaster</a> class to automate managing pipe endpoint lifecycles and sending packets to all connected client endpoints.</p>
<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoints are <em>indexed</em>, meaning that more than one pipe endpoint pair can be created using the same member. This means that multiple data streams can be created independent of each other between the client and service using the same member.</p>
<p>Pipes send reliable packet streams between connected client/service endpoint pairs. Packets are sent using the <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#ac137dc101ad4fcc0fa3f59d2cd47380c" title="Sends a packet to the peer endpoint.">SendPacket()</a> or <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a806fea541335ecf2d2703576dccde7f7" title="Send a packet to the peer endpoint asynchronously.">AsyncSendPacket()</a> functions. Packets are read from the receive queue using the <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a5ce6a6684ed7cb25b7a4168934eb7bf6" title="Receive the next packet in the receive queue.">ReceivePacket()</a>, <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a9bf7f76a9a2caea45fa973822829d352" title="Receive the next packet in the receive queue, block if queue is empty.">ReceivePacketWait()</a>, <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a82a74cbfb233e32266758bcc41b4947c" title="Try receiving a packet, optionally blocking if the queue is empty.">TryReceivePacketWait()</a>, <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a82a74cbfb233e32266758bcc41b4947c" title="Try receiving a packet, optionally blocking if the queue is empty.">TryReceivePacketWait()</a>, or <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#aeae58dd88e4ff68b34676503f41e18cb" title="Peeks the next packet in the receive queue.">PeekNextPacket()</a>. The endpoint is closed using the <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a52e4332ad9ac2454dfce3072ee530ab3" title="Close the pipe endpoint.">Close()</a> or <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#ac8ab324ed11e759730dead10d0fbef7c" title="Asynchronously close the pipe endpoint.">AsyncClose()</a> function.</p>
<p>This class is instantiated by the <a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> class. It should not be instantiated by the user.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The packet data type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8ab324ed11e759730dead10d0fbef7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ab324ed11e759730dead10d0fbef7c">&#9670;&nbsp;</a></span>AsyncClose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::AsyncClose </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>2000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously close the pipe endpoint. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a52e4332ad9ac2454dfce3072ee530ab3" title="Close the pipe endpoint.">Close()</a> but returns asynchronously</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler function to call on completion, possibly with an exception </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a29c8fcdd587ed6c08ce0d17552f43c80">RobotRaconteur::PipeEndpointBase</a>.</p>

</div>
</div>
<a id="a806fea541335ecf2d2703576dccde7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806fea541335ecf2d2703576dccde7f7">&#9670;&nbsp;</a></span>AsyncSendPacket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::AsyncSendPacket </td>
          <td>(</td>
          <td class="paramtype">typename boost::call_traits&lt; T &gt;::param_type&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(uint32_t, boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_robot_raconteur_exception.html">RobotRaconteurException</a> &gt;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet to the peer endpoint asynchronously. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#ac137dc101ad4fcc0fa3f59d2cd47380c" title="Sends a packet to the peer endpoint.">SendPacket()</a>, but returns asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The packet to send </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function to receive the sent packet number or an exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b02417f9fc6048aa886f30bcfa507a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b02417f9fc6048aa886f30bcfa507a">&#9670;&nbsp;</a></span>Available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t RobotRaconteur::PipeEndpointBase::Available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of packets in the receive queue. </p>
<p>Invalid for <em>writeonly</em> pipes.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of packets in the receive queue </dd></dl>

</div>
</div>
<a id="a52e4332ad9ac2454dfce3072ee530ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e4332ad9ac2454dfce3072ee530ab3">&#9670;&nbsp;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the pipe endpoint. </p>
<p>Close the pipe endpoint. Blocks until close complete. The peer endpoint is destroyed automatically. </p>

<p>Reimplemented from <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a9d9d6cff3861fd3ab972c345aab4850b">RobotRaconteur::PipeEndpointBase</a>.</p>

</div>
</div>
<a id="a30540f8217352d27009d64b854658864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30540f8217352d27009d64b854658864">&#9670;&nbsp;</a></span>Direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_robot_raconteur_constants_8h.html#a7420bbe1689d74c66948017ba2d27373">MemberDefinition_Direction</a> RobotRaconteur::PipeEndpointBase::Direction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction of the pipe. </p>
<p>Pipes may be declared <em>readonly</em> or <em>writeonly</em> in the service definition file. (If neither is specified, the pipe is assumed to be full duplex.) <em>readonly</em> pipes may only send packets from service to client. <em>writeonly</em> pipes may only send packets from client to service.</p>
<dl class="section return"><dt>Returns</dt><dd>MemberDefinition_Direction </dd></dl>

</div>
</div>
<a id="adc3f458610a0b0ea948701866cd2ad4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3f458610a0b0ea948701866cd2ad4d">&#9670;&nbsp;</a></span>GetEndpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RobotRaconteur::PipeEndpointBase::GetEndpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Robot Raconteur node Endpoint ID. </p>
<p>Returns the endpoint associated with the ClientContext or <a class="el" href="class_robot_raconteur_1_1_server_endpoint.html" title="Server endpoint representing a client connection.">ServerEndpoint</a> associated with the pipe endpoint.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The Robot Raconteur node Endpoint ID </dd></dl>

</div>
</div>
<a id="ab40239248b4a9aa28a83a8098aa23ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40239248b4a9aa28a83a8098aa23ed6">&#9670;&nbsp;</a></span>GetIgnoreReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::PipeEndpointBase::GetIgnoreReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get if pipe endpoint is ignoring incoming packets. </p>
<p>If true, pipe endpoint is ignoring incoming packets and is not adding incoming packets to the receive queue.</p>
<dl class="section return"><dt>Returns</dt><dd>true <a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoint is ignoring incoming packets </dd>
<dd>
false <a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoint is not ignoring incoming packets </dd></dl>

</div>
</div>
<a id="a892d86f47803bd5cb2e0acb9c2879bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892d86f47803bd5cb2e0acb9c2879bf2">&#9670;&nbsp;</a></span>GetIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RobotRaconteur::PipeEndpointBase::GetIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pipe endpoint index used when endpoint connected. </p>
<dl class="section return"><dt>Returns</dt><dd>int32_t The pipe endpoint index </dd></dl>

</div>
</div>
<a id="a83d7f30b86250f3026a4f93647e576b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d7f30b86250f3026a4f93647e576b7">&#9670;&nbsp;</a></span>GetPipeEndpointClosedCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void (boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt;T&gt; &gt;)&gt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::GetPipeEndpointClosedCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently configured endpoint closed callback function. </p>
<dl class="section return"><dt>Returns</dt><dd>boost::function&lt;void (RR_SHARED_PTR&lt;PipeEndpoint&lt;T&gt; &gt;)&gt; </dd></dl>

</div>
</div>
<a id="a07e7bb88e3493af85ea6bb00a8929eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e7bb88e3493af85ea6bb00a8929eea">&#9670;&nbsp;</a></span>GetRequestPacketAck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::PipeEndpointBase::GetRequestPacketAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get if pipe endpoint is requesting acks. </p>
<dl class="section return"><dt>Returns</dt><dd>true The pipe endpoint is requesting acks </dd>
<dd>
false The pipe endpoint is not requesting acks </dd></dl>

</div>
</div>
<a id="a2313d0ca8f4a4b02ad3c71b871452076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2313d0ca8f4a4b02ad3c71b871452076">&#9670;&nbsp;</a></span>IsUnreliable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotRaconteur::PipeEndpointBase::IsUnreliable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get if pipe endpoint is unreliable. </p>
<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> members may be declared as <em>unreliable</em> using member modifiers in the service definition. Pipes confirm unreliable operation when pipe endpoints are connected.</p>
<dl class="section return"><dt>Returns</dt><dd>true The pipe endpoint is unreliable </dd>
<dd>
false The pipe endpoint is reliable </dd></dl>

</div>
</div>
<a id="aeae58dd88e4ff68b34676503f41e18cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae58dd88e4ff68b34676503f41e18cb">&#9670;&nbsp;</a></span>PeekNextPacket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::PeekNextPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks the next packet in the receive queue. </p>
<p>Returns the first packet in the receive queue, but does not remove it from the queue. Throws an <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> if there are no packets in the receive queue.</p>
<dl class="section return"><dt>Returns</dt><dd>T The next packet in the receive queue </dd></dl>

</div>
</div>
<a id="a18aea1fa6c69ccf324afa0db06115c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aea1fa6c69ccf324afa0db06115c9c">&#9670;&nbsp;</a></span>PeekNextPacketWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::PeekNextPacketWait </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek the next packet in the receive queue, block if queue is empty. </p>
<p>Same as PeekPacket(), but blocks if queue is empty</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds to wait for a packet, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The received packet </dd></dl>

</div>
</div>
<a id="a5ce6a6684ed7cb25b7a4168934eb7bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce6a6684ed7cb25b7a4168934eb7bf6">&#9670;&nbsp;</a></span>ReceivePacket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::ReceivePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive the next packet in the receive queue. </p>
<p>Receive the next packet from the receive queue. This function will throw an <a class="el" href="class_robot_raconteur_1_1_invalid_operation_exception.html" title="Exception thrown when an invalid operation is attempted.">InvalidOperationException</a> if there are no packets in the receive queue. Use <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a9bf7f76a9a2caea45fa973822829d352" title="Receive the next packet in the receive queue, block if queue is empty.">ReceivePacketWait()</a> to block until a packet has been received.</p>
<dl class="section return"><dt>Returns</dt><dd>T The received packet </dd></dl>

</div>
</div>
<a id="a9bf7f76a9a2caea45fa973822829d352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf7f76a9a2caea45fa973822829d352">&#9670;&nbsp;</a></span>ReceivePacketWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::ReceivePacketWait </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive the next packet in the receive queue, block if queue is empty. </p>
<p>Same as <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html#a5ce6a6684ed7cb25b7a4168934eb7bf6" title="Receive the next packet in the receive queue.">ReceivePacket()</a>, but blocks if queue is empty</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds to wait for a packet, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The received packet </dd></dl>

</div>
</div>
<a id="ac137dc101ad4fcc0fa3f59d2cd47380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac137dc101ad4fcc0fa3f59d2cd47380c">&#9670;&nbsp;</a></span>SendPacket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::SendPacket </td>
          <td>(</td>
          <td class="paramtype">typename boost::call_traits&lt; T &gt;::param_type&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a packet to the peer endpoint. </p>
<p>Sends a packet to the peer endpoint. If the pipe is reliable, the packetsare guaranteed to arrive in order. If the pipe is set to unreliable, "best effort" is made to deliver packets, and they are not guaranteed to arrive in order. This function will block until the packet has been transmitted by the transport. It will return before the peer endpoint has received the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The packet number of the sent packet </dd></dl>

</div>
</div>
<a id="a8c3d128a167f065a7a474cf550bd2a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3d128a167f065a7a474cf550bd2a6e">&#9670;&nbsp;</a></span>SetIgnoreReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::PipeEndpointBase::SetIgnoreReceived </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether pipe endpoint should ignore incoming packets. </p>
<p><a class="el" href="class_robot_raconteur_1_1_pipe.html" title="pipe member type interface">Pipe</a> endpoints may optionally desire to ignore incoming data. This is useful if the endpoint is only being used to send packets, and received packets may create a potential memory leak if they are not being removed from the queue. If ignore is true, incoming packets will be discarded and will not be added to the receive queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore</td><td>If true, incoming packets are ignored. If false, the packets are added to the receive queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6982d846b8e5f92eafcd9921e0df2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6982d846b8e5f92eafcd9921e0df2a4">&#9670;&nbsp;</a></span>SetPipeEndpointClosedCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::SetPipeEndpointClosedCallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(boost::shared_ptr&lt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt; T &gt; &gt;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the endpoint closed callback function. </p>
<p>Sets a function to invoke when the pipe endpoint has been closed.</p>
<p><a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> function must accept one argument, receiving the PipeEndpointPtr&lt;T&gt; that was closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35667c47a40a1a72636124c8e6e89cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35667c47a40a1a72636124c8e6e89cd7">&#9670;&nbsp;</a></span>SetRequestPacketAck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotRaconteur::PipeEndpointBase::SetRequestPacketAck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if pipe endpoint should request packet acks. </p>
<p>Packet acks are generated by receiving endpoints to inform the sender that a packet has been received. The ack contains the packet index, the sequence number of the packet. Packet acks are used for flow control by <a class="el" href="class_robot_raconteur_1_1_pipe_broadcaster.html" title="Broadcaster to send packets to all connected clients.">PipeBroadcaster</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>true to request packet acks, otherwise false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82a74cbfb233e32266758bcc41b4947c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a74cbfb233e32266758bcc41b4947c">&#9670;&nbsp;</a></span>TryReceivePacketWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::TryReceivePacketWait </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="_robot_raconteur_constants_8h.html#a797a515f59232a62a9cc8b16df7ee78b">RR_TIMEOUT_INFINITE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>peek</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try receiving a packet, optionally blocking if the queue is empty. </p>
<p>Try receiving a packet with various options. Returns true if a packet has been received, or false if no packet is available instead of throwing an exception on failure. The timeout and peek parameters can be used to modify behavior to provide functionality similar to the various Receive and Peek functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>[out] The received packet </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout in milliseconds. Set to zero for non-blocking operation, an arbitrary value in milliseconds for a finite duration timeout, or RR_TIMEOUT_INFINITE for no timeout </td></tr>
    <tr><td class="paramname">peek</td><td>If true, the packet is not removed from the receive queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true A packet has been successfully received </dd>
<dd>
false No packet has been received. The content of val is undefined. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6e50ec80ca478737937fbc73f3bdab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e50ec80ca478737937fbc73f3bdab84">&#9670;&nbsp;</a></span>PacketAckReceivedEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void (boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt;T&gt; &gt;,uint32_t)&gt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::PacketAckReceivedEvent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal called when a packet ack has been received. </p>
<p>Packet acks are generated if <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint_base.html#a35667c47a40a1a72636124c8e6e89cd7" title="Set if pipe endpoint should request packet acks.">SetRequestPacketAck()</a> is set to true. The receiving endpoint generates acks to inform the sender that the packet has been received.</p>
<p><a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> function must accept two arguments, receiving the PipeEndpointPtr&lt;T&gt; that received the packet ack and the packet number that is being acked. </p>

</div>
</div>
<a id="a0351bd55241ef48d25636e03f17ee8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0351bd55241ef48d25636e03f17ee8ba">&#9670;&nbsp;</a></span>PacketReceivedEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void (boost::shared_ptr&lt;<a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">PipeEndpoint</a>&lt;T&gt; &gt;)&gt; <a class="el" href="class_robot_raconteur_1_1_pipe_endpoint.html">RobotRaconteur::PipeEndpoint</a>&lt; T &gt;::PacketReceivedEvent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal called when a packet has been received. </p>
<p><a class="el" href="class_robot_raconteur_1_1_callback.html" title="callback member type interface">Callback</a> function must accept one argument, receiving the PipeEndpointPtr&lt;T&gt; that received a packet </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/wasonj/Documents/RobotRaconteur2/robotraconteur/RobotRaconteurCore/include/RobotRaconteur/<a class="el" href="_pipe_member_8h_source.html">PipeMember.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
